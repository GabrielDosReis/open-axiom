\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra e04routine.spad}
\author{Brian Dupee}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain E04DGFA e04dgfAnnaType}
<<domain E04DGFA e04dgfAnnaType>>=
)abbrev domain E04DGFA e04dgfAnnaType
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: February 1996
++ Basic Operations: measure, numericalOptimization
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{e04dgfAnnaType} is a domain of \axiomType{NumericalOptimization}
++ for the NAG routine E04DGF, a general optimization routine which
++ can handle some singularities in the input function.  The function
++ \axiomFun{measure} measures the usefulness of the routine E04DGF
++ for the given problem.  The function \axiomFun{numericalOptimization}
++ performs the optimization by using \axiomType{NagOptimisationPackage}.

e04dgfAnnaType(): NumericalOptimizationCategory == Result add
  DF	==> DoubleFloat
  EF	==> Expression Float
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  VPDF	==> Vector Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  LOCDF	==> List OrderedCompletion DoubleFloat
  MDF	==> Matrix DoubleFloat
  MPDF	==> Matrix Polynomial DoubleFloat
  MF	==> Matrix Float
  MEF	==> Matrix Expression Float
  LEDF	==> List Expression DoubleFloat
  VEF	==> Vector Expression Float
  NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
  LSA	==> Record(lfn:LEDF, init:LDF)
  EF2	==> ExpressionFunctions2
  MI	==> Matrix Integer
  INT	==> Integer
  F	==> Float
  NNI	==> NonNegativeInteger
  S	==> Symbol
  LS	==> List Symbol
  MVCF	==> MultiVariableCalculusFunctions
  ESTOOLS2 ==> ExpertSystemToolsPackage2
  SDF	==> Stream DoubleFloat
  LSDF	==> List Stream DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat

  Rep:=Result
  import Rep, NagOptimisationPackage, ExpertSystemToolsPackage

  measure(R:RoutinesTable,args:NOA) ==
    string:String := "e04dgf is "
    positive?(#(args.cf) + #(args.lb) + #(args.ub)) =>
      string := concat(string,"unsuitable for constrained problems. ")
      [0.0,string]
    string := concat(string,"recommended")
    [getMeasure(R,e04dgf@Symbol)$RoutinesTable, string]

  numericalOptimization(args:NOA) ==
    argsFn:EDF := args.fn
    n:NNI := #(variables(argsFn)$EDF)
    fu:DF := float(4373903597,-24,10)$DF
    it:INT := max(50,5*n)
    lin:DF := float(9,-1,10)$DF
    ma:DF := float(1,20,10)$DF
    op:DF := float(326,-14,10)$DF
    x:MDF := mat(args.init,n)
    ArgsFn:Expression Float := edf2ef(argsFn)
    f:Union(fn:FileName,fp:Asp49(OBJFUN)) := [retract(ArgsFn)$Asp49(OBJFUN)]
    e04dgf(n,1$DF,fu,it,lin,true,ma,op,1,1,n,0,x,-1,f)

@
\section{domain E04FDFA e04fdfAnnaType}
<<domain E04FDFA e04fdfAnnaType>>=
)abbrev domain E04FDFA e04fdfAnnaType
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: February 1996
++ Basic Operations: measure, numericalOptimization
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{e04fdfAnnaType} is a domain of \axiomType{NumericalOptimization}
++ for the NAG routine E04FDF, a general optimization routine which
++ can handle some singularities in the input function.  The function
++ \axiomFun{measure} measures the usefulness of the routine E04FDF
++ for the given problem.  The function \axiomFun{numericalOptimization}
++ performs the optimization by using \axiomType{NagOptimisationPackage}.
e04fdfAnnaType(): NumericalOptimizationCategory == Result add
  DF	==> DoubleFloat
  EF	==> Expression Float
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  VPDF	==> Vector Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  LOCDF	==> List OrderedCompletion DoubleFloat
  MDF	==> Matrix DoubleFloat
  MPDF	==> Matrix Polynomial DoubleFloat
  MF	==> Matrix Float
  MEF	==> Matrix Expression Float
  LEDF	==> List Expression DoubleFloat
  VEF	==> Vector Expression Float
  NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
  LSA	==> Record(lfn:LEDF, init:LDF)
  EF2	==> ExpressionFunctions2
  MI	==> Matrix Integer
  INT	==> Integer
  F	==> Float
  NNI	==> NonNegativeInteger
  S	==> Symbol
  LS	==> List Symbol
  MVCF	==> MultiVariableCalculusFunctions
  ESTOOLS2 ==> ExpertSystemToolsPackage2
  SDF	==> Stream DoubleFloat
  LSDF	==> List Stream DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat

  Rep:=Result
  import Rep, NagOptimisationPackage
  import e04AgentsPackage,ExpertSystemToolsPackage

  measure(R:RoutinesTable,args:NOA) ==
    argsFn := args.fn
    string:String := "e04fdf is "
    positive?(#(args.cf) + #(args.lb) + #(args.ub)) =>
      string := concat(string,"unsuitable for constrained problems. ")
      [0.0,string]
    n:NNI := #(variables(argsFn)$EDF)
    (n>1)@Boolean => 
      string := concat(string,"unsuitable for single instances of multivariate problems. ")
      [0.0,string]
    sumOfSquares(argsFn) case "failed" =>
      string := concat(string,"unsuitable.")
      [0.0,string]
    string := concat(string,"recommended since the function is a sum of squares.")
    [getMeasure(R,e04fdf@Symbol)$RoutinesTable, string]

  measure(R:RoutinesTable,args:LSA) ==
    string:String := "e04fdf is recommended"
    [getMeasure(R,e04fdf@Symbol)$RoutinesTable, string]

  numericalOptimization(args:NOA) ==
    argsFn := args.fn
    lw:INT := 14
    x := mat(args.init,1)
    (a := sumOfSquares(argsFn)) case EDF => 
      ArgsFn := vector([edf2ef(a)])$VEF
      f : Union(fn:FileName,fp:Asp50(LSFUN1)) := [retract(ArgsFn)$Asp50(LSFUN1)]
      out:Result := e04fdf(1,1,1,lw,x,-1,f)
      changeNameToObjf(fsumsq@Symbol,out)
    empty()$Result

  numericalOptimization(args:LSA) ==
    argsFn := copy args.lfn
    m:INT := #(argsFn)
    n:NNI := #(variables(args))
    nn:INT := n
    lw:INT := 
--      one?(nn) => 9+5*m
      (nn = 1) => 9+5*m
      nn*(7+n+2*m+((nn-1) quo 2)$INT)+3*m
    x := mat(args.init,n)
    ArgsFn := vector([edf2ef(i)$ExpertSystemToolsPackage for i in argsFn])$VEF
    f : Union(fn:FileName,fp:Asp50(LSFUN1)) := [retract(ArgsFn)$Asp50(LSFUN1)]
    out:Result := e04fdf(m,n,1,lw,x,-1,f)
    changeNameToObjf(fsumsq@Symbol,out)

@
\section{domain E04GCFA e04gcfAnnaType}
<<domain E04GCFA e04gcfAnnaType>>=
)abbrev domain E04GCFA e04gcfAnnaType
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: February 1996
++ Basic Operations: measure, numericalOptimization
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{e04gcfAnnaType} is a domain of \axiomType{NumericalOptimization}
++ for the NAG routine E04GCF, a general optimization routine which
++ can handle some singularities in the input function.  The function
++ \axiomFun{measure} measures the usefulness of the routine E04GCF
++ for the given problem.  The function \axiomFun{numericalOptimization}
++ performs the optimization by using \axiomType{NagOptimisationPackage}.
e04gcfAnnaType(): NumericalOptimizationCategory == Result add
  DF	==> DoubleFloat
  EF	==> Expression Float
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  VPDF	==> Vector Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  LOCDF	==> List OrderedCompletion DoubleFloat
  MDF	==> Matrix DoubleFloat
  MPDF	==> Matrix Polynomial DoubleFloat
  MF	==> Matrix Float
  MEF	==> Matrix Expression Float
  LEDF	==> List Expression DoubleFloat
  VEF	==> Vector Expression Float
  NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
  LSA	==> Record(lfn:LEDF, init:LDF)
  EF2	==> ExpressionFunctions2
  MI	==> Matrix Integer
  INT	==> Integer
  F	==> Float
  NNI	==> NonNegativeInteger
  S	==> Symbol
  LS	==> List Symbol
  MVCF	==> MultiVariableCalculusFunctions
  ESTOOLS2 ==> ExpertSystemToolsPackage2
  SDF	==> Stream DoubleFloat
  LSDF	==> List Stream DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat

  Rep:=Result
  import Rep, NagOptimisationPackage,ExpertSystemContinuityPackage
  import e04AgentsPackage,ExpertSystemToolsPackage

  measure(R:RoutinesTable,args:NOA) ==
    argsFn:EDF := args.fn
    string:String := "e04gcf is "
    positive?(#(args.cf) + #(args.lb) + #(args.ub)) =>
      string := concat(string,"unsuitable for constrained problems. ")
      [0.0,string]
    n:NNI := #(variables(argsFn)$EDF)
    (n>1)@Boolean => 
      string := concat(string,"unsuitable for single instances of multivariate problems. ")
      [0.0,string]
    a := coerce(float(10,0,10))$OCDF
    seg:SOCDF := -a..a
    sings := singularitiesOf(argsFn,variables(argsFn)$EDF,seg)
    s := #(sdf2lst(sings))
    positive? s => 
      string := concat(string,"not recommended for discontinuous functions.")
      [0.0,string]
    sumOfSquares(args.fn) case "failed" =>
      string := concat(string,"unsuitable.")
      [0.0,string]
    string := concat(string,"recommended since the function is a sum of squares.")
    [getMeasure(R,e04gcf@Symbol)$RoutinesTable, string]

  measure(R:RoutinesTable,args:LSA) ==
    string:String := "e04gcf is "
    a := coerce(float(10,0,10))$OCDF
    seg:SOCDF := -a..a
    sings := concat([singularitiesOf(i,variables(args),seg) for i in args.lfn])$SDF
    s := #(sdf2lst(sings))
    positive? s => 
      string := concat(string,"not recommended for discontinuous functions.")
      [0.0,string]
    string := concat(string,"recommended.")
    m := getMeasure(R,e04gcf@Symbol)$RoutinesTable
    m := m-(1-exp(-(expenseOfEvaluation(args))**3))
    [m, string]

  numericalOptimization(args:NOA) ==
    argsFn:EDF := args.fn
    lw:INT := 16
    x := mat(args.init,1)
    (a := sumOfSquares(argsFn)) case EDF => 
      ArgsFn := vector([edf2ef(a)$ExpertSystemToolsPackage])$VEF
      f : Union(fn:FileName,fp:Asp19(LSFUN2)) := [retract(ArgsFn)$Asp19(LSFUN2)]
      out:Result := e04gcf(1,1,1,lw,x,-1,f)
      changeNameToObjf(fsumsq@Symbol,out)
    empty()$Result

  numericalOptimization(args:LSA) ==
    argsFn := copy args.lfn
    m:NNI := #(argsFn)
    n:NNI := #(variables(args))
    lw:INT := 
--      one?(n) => 11+5*m
      (n = 1) => 11+5*m
      2*n*(4+n+m)+3*m
    x := mat(args.init,n)
    ArgsFn := vector([edf2ef(i)$ExpertSystemToolsPackage for i in argsFn])$VEF
    f : Union(fn:FileName,fp:Asp19(LSFUN2)) := [retract(ArgsFn)$Asp19(LSFUN2)]
    out:Result := e04gcf(m,n,1,lw,x,-1,f)
    changeNameToObjf(fsumsq@Symbol,out)

@
\section{domain E04JAFA e04jafAnnaType}
<<domain E04JAFA e04jafAnnaType>>=
)abbrev domain E04JAFA e04jafAnnaType
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: February 1996
++ Basic Operations: measure, numericalOptimization
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{e04jafAnnaType} is a domain of \axiomType{NumericalOptimization}
++ for the NAG routine E04JAF, a general optimization routine which
++ can handle some singularities in the input function.  The function
++ \axiomFun{measure} measures the usefulness of the routine E04JAF
++ for the given problem.  The function \axiomFun{numericalOptimization}
++ performs the optimization by using \axiomType{NagOptimisationPackage}.
e04jafAnnaType(): NumericalOptimizationCategory == Result add
  DF	==> DoubleFloat
  EF	==> Expression Float
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  VPDF	==> Vector Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  LOCDF	==> List OrderedCompletion DoubleFloat
  MDF	==> Matrix DoubleFloat
  MPDF	==> Matrix Polynomial DoubleFloat
  MF	==> Matrix Float
  MEF	==> Matrix Expression Float
  LEDF	==> List Expression DoubleFloat
  VEF	==> Vector Expression Float
  NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
  LSA	==> Record(lfn:LEDF, init:LDF)
  EF2	==> ExpressionFunctions2
  MI	==> Matrix Integer
  INT	==> Integer
  F	==> Float
  NNI	==> NonNegativeInteger
  S	==> Symbol
  LS	==> List Symbol
  MVCF	==> MultiVariableCalculusFunctions
  ESTOOLS2 ==> ExpertSystemToolsPackage2
  SDF	==> Stream DoubleFloat
  LSDF	==> List Stream DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat

  Rep:=Result
  import Rep, NagOptimisationPackage
  import e04AgentsPackage,ExpertSystemToolsPackage

  bound(a:LOCDF,b:LOCDF):Integer ==  
    empty?(concat(a,b)) => 1
--    one?(#(removeDuplicates(a))) and  zero?(first(a)) => 2
    (#(removeDuplicates(a)) = 1) and  zero?(first(a)) => 2
--    one?(#(removeDuplicates(a))) and one?(#(removeDuplicates(b))) => 3
    (#(removeDuplicates(a)) = 1) and (#(removeDuplicates(b)) = 1) => 3
    0  

  measure(R:RoutinesTable,args:NOA) ==
    string:String := "e04jaf is "
    if positive?(#(args.cf)) then
      if not simpleBounds?(args.cf) then
        string := 
          concat(string,"suitable for simple bounds only, not constraint functions.")
    (# string) < 20 => 
      if zero?(#(args.lb) + #(args.ub)) then
        string := concat(string, "usable if there are no constraints")
        [getMeasure(R,e04jaf@Symbol)$RoutinesTable*0.5,string]
      else
        string := concat(string,"recommended")
        [getMeasure(R,e04jaf@Symbol)$RoutinesTable, string]
    [0.0,string]

  numericalOptimization(args:NOA) ==
    argsFn:EDF := args.fn
    n:NNI := #(variables(argsFn)$EDF)
    ibound:INT := bound(args.lb,args.ub)
    m:INT := n 
    lw:INT := max(13,12 * m + ((m * (m - 1)) quo 2)$INT)$INT
    bl := mat(finiteBound(args.lb,float(1,6,10)$DF),n)
    bu := mat(finiteBound(args.ub,float(1,6,10)$DF),n)
    x := mat(args.init,n)
    ArgsFn:EF := edf2ef(argsFn)
    fr:Union(fn:FileName,fp:Asp24(FUNCT1)) := [retract(ArgsFn)$Asp24(FUNCT1)]
    out:Result := e04jaf(n,ibound,n+2,lw,bl,bu,x,-1,fr)
    changeNameToObjf(f@Symbol,out)

@
\section{domain E04MBFA e04mbfAnnaType}
<<domain E04MBFA e04mbfAnnaType>>=
)abbrev domain E04MBFA e04mbfAnnaType
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: February 1996
++ Basic Operations: measure, numericalOptimization
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{e04mbfAnnaType} is a domain of \axiomType{NumericalOptimization}
++ for the NAG routine E04MBF, an optimization routine for Linear functions.
++ The function
++ \axiomFun{measure} measures the usefulness of the routine E04MBF
++ for the given problem.  The function \axiomFun{numericalOptimization}
++ performs the optimization by using \axiomType{NagOptimisationPackage}.
e04mbfAnnaType(): NumericalOptimizationCategory == Result add
  DF	==> DoubleFloat
  EF	==> Expression Float
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  VPDF	==> Vector Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  LOCDF	==> List OrderedCompletion DoubleFloat
  MDF	==> Matrix DoubleFloat
  MPDF	==> Matrix Polynomial DoubleFloat
  MF	==> Matrix Float
  MEF	==> Matrix Expression Float
  LEDF	==> List Expression DoubleFloat
  VEF	==> Vector Expression Float
  NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
  LSA	==> Record(lfn:LEDF, init:LDF)
  EF2	==> ExpressionFunctions2
  MI	==> Matrix Integer
  INT	==> Integer
  F	==> Float
  NNI	==> NonNegativeInteger
  S	==> Symbol
  LS	==> List Symbol
  MVCF	==> MultiVariableCalculusFunctions
  ESTOOLS2 ==> ExpertSystemToolsPackage2
  SDF	==> Stream DoubleFloat
  LSDF	==> List Stream DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat

  Rep:=Result
  import Rep, NagOptimisationPackage
  import e04AgentsPackage,ExpertSystemToolsPackage

  measure(R:RoutinesTable,args:NOA) ==
    (not linear?([args.fn])) or (not linear?(args.cf)) => 
      [0.0,"e04mbf is for a linear objective function and constraints only."]
    [getMeasure(R,e04mbf@Symbol)$RoutinesTable,"e04mbf is recommended" ]

  numericalOptimization(args:NOA) ==
    argsFn:EDF := args.fn
    c := args.cf
    listVars:List LS := concat(variables(argsFn)$EDF,[variables(z)$EDF for z in c])
    n:NNI := #(v := removeDuplicates(concat(listVars)$LS)$LS)
    A:MDF := linearMatrix(args.cf,n)
    nclin:NNI := # linearPart(c)
    nrowa:NNI := max(1,nclin)
    bl:MDF := mat(finiteBound(args.lb,float(1,21,10)$DF),n)
    bu:MDF := mat(finiteBound(args.ub,float(1,21,10)$DF),n)
    cvec:MDF := mat(coefficients(retract(argsFn)@PDF)$PDF,n)
    x := mat(args.init,n)
    lwork:INT := 
      nclin < n => 2*nclin*(nclin+4)+2+6*n+nrowa
      2*(n+3)*n+4*nclin+nrowa
    out:Result := e04mbf(20,1,n,nclin,n+nclin,nrowa,A,bl,bu,cvec,true,2*n,lwork,x,-1)
    changeNameToObjf(objlp@Symbol,out)

@
\section{domain E04NAFA e04nafAnnaType}
<<domain E04NAFA e04nafAnnaType>>=
)abbrev domain E04NAFA e04nafAnnaType
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: February 1996
++ Basic Operations: measure, numericalOptimization
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{e04nafAnnaType} is a domain of \axiomType{NumericalOptimization}
++ for the NAG routine E04NAF, an optimization routine for Quadratic functions.
++ The function
++ \axiomFun{measure} measures the usefulness of the routine E04NAF
++ for the given problem.  The function \axiomFun{numericalOptimization}
++ performs the optimization by using \axiomType{NagOptimisationPackage}.
e04nafAnnaType(): NumericalOptimizationCategory == Result add
  DF	==> DoubleFloat
  EF	==> Expression Float
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  VPDF	==> Vector Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  LOCDF	==> List OrderedCompletion DoubleFloat
  MDF	==> Matrix DoubleFloat
  MPDF	==> Matrix Polynomial DoubleFloat
  MF	==> Matrix Float
  MEF	==> Matrix Expression Float
  LEDF	==> List Expression DoubleFloat
  VEF	==> Vector Expression Float
  NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
  LSA	==> Record(lfn:LEDF, init:LDF)
  EF2	==> ExpressionFunctions2
  MI	==> Matrix Integer
  INT	==> Integer
  F	==> Float
  NNI	==> NonNegativeInteger
  S	==> Symbol
  LS	==> List Symbol
  MVCF	==> MultiVariableCalculusFunctions
  ESTOOLS2 ==> ExpertSystemToolsPackage2
  SDF	==> Stream DoubleFloat
  LSDF	==> List Stream DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat

  Rep:=Result
  import Rep, NagOptimisationPackage
  import e04AgentsPackage,ExpertSystemToolsPackage

  measure(R:RoutinesTable,args:NOA) ==
    string:String := "e04naf is "
    argsFn:EDF := args.fn
    if not (quadratic?(argsFn) and linear?(args.cf)) then
      string :=
        concat(string,"for a quadratic function with linear constraints only.")
    (# string) < 20 => 
      string := concat(string,"recommended")
      [getMeasure(R,e04naf@Symbol)$RoutinesTable, string]
    [0.0,string]

  numericalOptimization(args:NOA) ==
    argsFn:EDF := args.fn
    c := args.cf
    listVars:List LS := concat(variables(argsFn)$EDF,[variables(z)$EDF for z in c])
    n:NNI := #(v := sort(removeDuplicates(concat(listVars)$LS)$LS)$LS)
    A:MDF := linearMatrix(c,n)
    nclin:NNI := # linearPart(c)
    nrowa:NNI := max(1,nclin)
    big:DF := float(1,10,10)$DF
    fea:MDF := new(1,n+nclin,float(1053,-11,10)$DF)$MDF
    bl:MDF := mat(finiteBound(args.lb,float(1,21,10)$DF),n)
    bu:MDF := mat(finiteBound(args.ub,float(1,21,10)$DF),n)
    alin:EDF := splitLinear(argsFn)
    p:PDF := retract(alin)@PDF
    pl:List PDF := [coefficient(p,i,1)$PDF for i in v]
    cvec:MDF := mat([pdf2df j for j in pl],n)
    h1:MPDF := hessian(p,v)$MVCF(S,PDF,VPDF,LS)
    hess:MDF := map(pdf2df,h1)$ESTOOLS2(PDF,DF)
    h2:MEF := map(df2ef,hess)$ESTOOLS2(DF,EF)
    x := mat(args.init,n)
    istate:MI := zero(1,n+nclin)$MI
    lwork:INT := 2*n*(n+2*nclin)+nrowa
    qphess:Union(fn:FileName,fp:Asp20(QPHESS)) := [retract(h2)$Asp20(QPHESS)]
    out:Result := e04naf(20,1,n,nclin,n+nclin,nrowa,n,n,big,A,bl,bu,cvec,fea,
                           hess,true,false,true,2*n,lwork,x,istate,-1,qphess)
    changeNameToObjf(obj@Symbol,out)

@
\section{domain E04UCFA e04ucfAnnaType}
<<domain E04UCFA e04ucfAnnaType>>=
)abbrev domain E04UCFA e04ucfAnnaType
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: November 1997
++ Basic Operations: measure, numericalOptimization
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{e04ucfAnnaType} is a domain of \axiomType{NumericalOptimization}
++ for the NAG routine E04UCF, a general optimization routine which
++ can handle some singularities in the input function.  The function
++ \axiomFun{measure} measures the usefulness of the routine E04UCF
++ for the given problem.  The function \axiomFun{numericalOptimization}
++ performs the optimization by using \axiomType{NagOptimisationPackage}.
e04ucfAnnaType(): NumericalOptimizationCategory == Result add
  DF	==> DoubleFloat
  EF	==> Expression Float
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  VPDF	==> Vector Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  LOCDF	==> List OrderedCompletion DoubleFloat
  MDF	==> Matrix DoubleFloat
  MPDF	==> Matrix Polynomial DoubleFloat
  MF	==> Matrix Float
  MEF	==> Matrix Expression Float
  LEDF	==> List Expression DoubleFloat
  VEF	==> Vector Expression Float
  NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
  LSA	==> Record(lfn:LEDF, init:LDF)
  EF2	==> ExpressionFunctions2
  MI	==> Matrix Integer
  INT	==> Integer
  F	==> Float
  NNI	==> NonNegativeInteger
  S	==> Symbol
  LS	==> List Symbol
  MVCF	==> MultiVariableCalculusFunctions
  ESTOOLS2 ==> ExpertSystemToolsPackage2
  SDF	==> Stream DoubleFloat
  LSDF	==> List Stream DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat

  Rep:=Result
  import Rep,NagOptimisationPackage
  import e04AgentsPackage,ExpertSystemToolsPackage

  measure(R:RoutinesTable,args:NOA) ==
    zero?(#(args.lb) + #(args.ub)) =>
      [0.0,"e04ucf is not recommended if there are no bounds specified"]
    zero?(#(args.cf)) =>
      string:String := "e04ucf is usable but not always recommended if there are no constraints"
      [getMeasure(R,e04ucf@Symbol)$RoutinesTable*0.5,string]
    [getMeasure(R,e04ucf@Symbol)$RoutinesTable,"e04ucf is recommended"]

  numericalOptimization(args:NOA) ==
    Args := sortConstraints(args)
    argsFn := Args.fn
    c := Args.cf
    listVars:List LS := concat(variables(argsFn)$EDF,[variables(z)$EDF for z in c])
    n:NNI := #(v := sort(removeDuplicates(concat(listVars)$LS)$LS)$LS)
    lin:NNI := #(linearPart(c))
    nlcf := nonLinearPart(c)
    nonlin:NNI := #(nlcf)
    if empty?(nlcf) then 
      nlcf := new(n,coerce(first(v)$LS)$EDF)$LEDF
    nrowa:NNI := max(1,lin)
    nrowj:NNI := max(1,nonlin)
    A:MDF := linearMatrix(c,n)
    bl:MDF := mat(finiteBound(Args.lb,float(1,25,10)$DF),n)
    bu:MDF := mat(finiteBound(Args.ub,float(1,25,10)$DF),n)
    liwork:INT := 3*n+lin+2*nonlin
    lwork:INT :=
      zero?(lin+nonlin) => 20*n
      zero?(nonlin) => 2*n*(n+10)+11*lin
      2*n*(n+nonlin+10)+(11+n)*lin + 21*nonlin
    cra:DF := float(1,-2,10)$DF
    fea:DF := float(1053671201,-17,10)$DF
    fun:DF := float(4373903597,-24,10)$DF
    infb:DF := float(1,15,10)$DF
    lint:DF := float(9,-1,10)$DF
    maji:INT := max(50,3*(n+lin)+10*nonlin)
    mini:INT := max(50,3*(n+lin+nonlin))
    nonf:DF := float(105,-10,10)$DF
    opt:DF := float(326,-10,10)$DF
    ste:DF := float(2,0,10)$DF
    istate:MI := zero(1,n+lin+nonlin)$MI
    cjac:MDF := 
      positive?(nonlin) => zero(nrowj,n)$MDF
      zero(nrowj,1)$MDF
    clambda:MDF := zero(1,n+lin+nonlin)$MDF
    r:MDF := zero(n,n)$MDF
    x:MDF := mat(Args.init,n)
    VectCF:VEF := vector([edf2ef e for e in nlcf])$VEF
    ArgsFn:EF := edf2ef(argsFn)
    fasp : Union(fn:FileName,fp:Asp49(OBJFUN)) := [retract(ArgsFn)$Asp49(OBJFUN)]
    casp : Union(fn:FileName,fp:Asp55(CONFUN)) := [retract(VectCF)$Asp55(CONFUN)]
    e04ucf(n,lin,nonlin,nrowa,nrowj,n,A,bl,bu,liwork,lwork,false,cra,3,fea,
            fun,true,infb,infb,fea,lint,true,maji,1,mini,0,-1,nonf,opt,ste,1,
             1,n,n,3,istate,cjac,clambda,r,x,-1,casp,fasp)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain E04DGFA e04dgfAnnaType>>
<<domain E04FDFA e04fdfAnnaType>>
<<domain E04GCFA e04gcfAnnaType>>
<<domain E04JAFA e04jafAnnaType>>
<<domain E04MBFA e04mbfAnnaType>>
<<domain E04NAFA e04nafAnnaType>>
<<domain E04UCFA e04ucfAnnaType>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
