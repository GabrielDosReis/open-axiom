\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra c05.spad}
\author{Godfrey Nolan, Mike Dewar}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package NAGC05 NagRootFindingPackage}
<<package NAGC05 NagRootFindingPackage>>=
)abbrev package NAGC05 NagRootFindingPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:28 1994
++Description: 
++This package uses the NAG Library to calculate real zeros of
++continuous real functions of one or more variables. (Complex
++equations must be expressed in terms of the equivalent larger
++system of real equations.)
++See \downlink{Manual Page}{manpageXXc05}.

NagRootFindingPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    c05adf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ c05adf(a,b,eps,eta,ifail,f)
     ++ locates a zero of a continuous function in a given 
     ++ interval by a combination of the methods of linear interpolation,
     ++ extrapolation and bisection.
     ++ See \downlink{Manual Page}{manpageXXc05adf}.
    c05nbf : (Integer,Integer,Matrix DoubleFloat,DoubleFloat,_
	Integer,Union(fn:FileName,fp:Asp6(FCN))) -> Result 
     ++ c05nbf(n,lwa,x,xtol,ifail,fcn)
     ++ is an easy-to-use routine to find a solution of a system 
     ++ of nonlinear equations by a modification of the Powell hybrid 
     ++ method.
     ++ See \downlink{Manual Page}{manpageXXc05nbf}.
    c05pbf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	DoubleFloat,Integer,Union(fn:FileName,fp:Asp35(FCN))) -> Result 
     ++ c05pbf(n,ldfjac,lwa,x,xtol,ifail,fcn)
     ++ is an easy-to-use routine to find a solution of a system 
     ++ of nonlinear equations by a modification of the Powell hybrid 
     ++ method. The user must provide the Jacobian.
     ++ See \downlink{Manual Page}{manpageXXc05pbf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp1(F))
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Integer)


    c05adf(aArg:DoubleFloat,bArg:DoubleFloat,epsArg:DoubleFloat,_
	etaArg:DoubleFloat,ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"c05adf",_
	["a"::S,"b"::S,"eps"::S,"eta"::S,"x"::S_
	,"ifail"::S,"f"::S]$Lisp,_
	["x"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"eps"::S,"eta"::S_
	,"x"::S,"f"::S]$Lisp_
	,["integer"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,epsArg::Any,etaArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c05nbf(nArg:Integer,lwaArg:Integer,xArg:Matrix DoubleFloat,_
	xtolArg:DoubleFloat,ifailArg:Integer,fcnArg:Union(fn:FileName,fp:Asp6(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"c05nbf",_
	["n"::S,"lwa"::S,"xtol"::S,"ifail"::S,"fcn"::S_
	,"fvec"::S,"x"::S,"wa"::S]$Lisp,_
	["fvec"::S,"wa"::S,"fcn"::S]$Lisp,_
	[["double"::S,["fvec"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp_
	,"xtol"::S,["wa"::S,"lwa"::S]$Lisp,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"lwa"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["fvec"::S,"x"::S,"xtol"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,lwaArg::Any,xtolArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c05pbf(nArg:Integer,ldfjacArg:Integer,lwaArg:Integer,_
	xArg:Matrix DoubleFloat,xtolArg:DoubleFloat,ifailArg:Integer,_
	fcnArg:Union(fn:FileName,fp:Asp35(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"c05pbf",_
	["n"::S,"ldfjac"::S,"lwa"::S,"xtol"::S,"ifail"::S_
	,"fcn"::S,"fvec"::S,"fjac"::S,"x"::S,"wa"::S]$Lisp,_
	["fvec"::S,"fjac"::S,"wa"::S,"fcn"::S]$Lisp,_
	[["double"::S,["fvec"::S,"n"::S]$Lisp,["fjac"::S,"ldfjac"::S,"n"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,"xtol"::S,["wa"::S,"lwa"::S]$Lisp,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"ldfjac"::S,"lwa"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["fvec"::S,"fjac"::S,"x"::S,"xtol"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ldfjacArg::Any,lwaArg::Any,xtolArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package NAGC05 NagRootFindingPackage>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
