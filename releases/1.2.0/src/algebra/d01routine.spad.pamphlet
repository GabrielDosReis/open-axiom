\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra d01routine.spad}
\author{Brian Dupee}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain D01AJFA d01ajfAnnaType}
<<domain D01AJFA d01ajfAnnaType>>=
)abbrev domain D01AJFA d01ajfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01ajfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01AJF, a general numerical integration routine which
++ can handle some singularities in the input function.  The function
++ \axiomFun{measure} measures the usefulness of the routine D01AJF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01ajfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, NagIntegrationPackage, d01AgentsPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    pp:SDF := singularitiesOf(args)
    not (empty?(pp)$SDF) =>
      [0.1,"d01ajf: There is a possible problem at the following point(s): "
           commaSeparate(sdf2lst(pp)) ,ext]
    [getMeasure(R,d01ajf :: S)$RT,
       "The general routine d01ajf is our default",ext]

  numericalIntegration(args:NIA,hints:Result) ==
    ArgsFn := map(convert(#1)$DF,args.fn)$EF2(DF,Float)
    b:Float := getButtonValue("d01ajf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 75*fEvals
    f : Union(fn:FileName,fp:Asp1(F)) := [retract(ArgsFn)$Asp1(F)]
    d01ajf(getlo(args.range),gethi(args.range),args.abserr,args.relerr,4*iw,iw,-1,f)

@
\section{domain D01AKFA d01akfAnnaType}
<<domain D01AKFA d01akfAnnaType>>=
)abbrev domain D01AKFA d01akfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01akfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01AKF, a numerical integration routine which is
++ is suitable for oscillating, non-singular functions.  The function
++ \axiomFun{measure} measures the usefulness of the routine D01AKF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01akfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    pp:SDF := singularitiesOf(args)
    not (empty?(pp)$SDF) =>
      [0.0,"d01akf: There is a possible problem at the following point(s): "
              commaSeparate(sdf2lst(pp)) ,ext]
    o:Float := functionIsOscillatory(args)
    one := 1.0
    m:Float := (getMeasure(R,d01akf@S)$RT)*(one-one/(one+sqrt(o)))**2
    m > 0.8 => [m,"d01akf: The expression shows much oscillation",ext]
    m > 0.6 => [m,"d01akf: The expression shows some oscillation",ext]
    m > 0.5 => [m,"d01akf: The expression shows little oscillation",ext]
    [m,"d01akf: The expression shows little or no oscillation",ext]

  numericalIntegration(args:NIA,hints:Result) ==
    ArgsFn := map(convert(#1)$DF,args.fn)$EF2(DF,Float)
    b:Float := getButtonValue("d01akf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 75*fEvals
    f : Union(fn:FileName,fp:Asp1(F)) := [retract(ArgsFn)$Asp1(F)]
    d01akf(getlo(args.range),gethi(args.range),args.abserr,args.relerr,4*iw,iw,-1,f)

@
\section{domain D01AMFA d01amfAnnaType}
<<domain D01AMFA d01amfAnnaType>>=
)abbrev domain D01AMFA d01amfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01amfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01AMF, a general numerical integration routine which
++ can handle infinite or semi-infinite range of the input function.  The 
++ function \axiomFun{measure} measures the usefulness of the routine D01AMF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01amfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    Range:=rangeIsFinite(args)
    pp:SDF := singularitiesOf(args)
    not (empty?(pp)$SDF) =>
      [0.0,"d01amf: There is a possible problem at the following point(s): "
                     commaSeparate(sdf2lst(pp)), ext]
    [getMeasure(R,d01amf@S)$RT, "d01amf is a reasonable choice if the "
         "integral is infinite or semi-infinite and d01transform cannot "
           "do better than using general routines",ext]

  numericalIntegration(args:NIA,hints:Result) ==
    r:INT
    bound:DF
    ArgsFn := map(convert(#1)$DF,args.fn)$EF2(DF,Float)
    b:Float := getButtonValue("d01amf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 150*fEvals
    f : Union(fn:FileName,fp:Asp1(F)) := [retract(ArgsFn)$Asp1(F)]
    Range:=rangeIsFinite(args)
    if (Range case upperInfinite) then
      bound := getlo(args.range)
      r := 1
    else if (Range case lowerInfinite) then
      bound := gethi(args.range)
      r := -1
    else 
      bound := 0$DF
      r := 2
    d01amf(bound,r,args.abserr,args.relerr,4*iw,iw,-1,f)

@
\section{domain D01APFA d01apfAnnaType}
<<domain D01APFA d01apfAnnaType>>=
)abbrev domain D01APFA d01apfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01apfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01APF, a general numerical integration routine which
++ can handle end point singularities of the algebraico-logarithmic form
++ w(x) = (x-a)^c * (b-x)^d.  The 
++ function \axiomFun{measure} measures the usefulness of the routine D01APF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01apfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, NagIntegrationPackage, d01AgentsPackage, d01WeightsPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    d := (c := 0$DF)
    if ((a := exprHasAlgebraicWeight(args)) case LDF) then
      if  (a.1 > -1) then c := a.1
      if  (a.2 > -1) then d := a.2
    l:INT := exprHasLogarithmicWeights(args)
--    (zero? c) and (zero? d) and (one? l) =>
    (zero? c) and (zero? d) and (l = 1) =>
        [0.0,"d01apf: A suitable singularity has not been found", ext]
    out:LDF := [c,d,l :: DF]
    outany:Any := coerce(out)$AnyFunctions1(LDF)
    ex:Record(key:S,entry:Any) := [d01apfextra@S,outany]
    ext := insert!(ex,ext)$Result
    st:ST :=  "Recommended is d01apf with c = " df2st(c) ", d = " 
                            df2st(d) " and l = " string(l)$ST
    [getMeasure(R,d01apf@S)$RT, st, ext]

  numericalIntegration(args:NIA,hints:Result) ==

    Var:EDF := coerce(args.var)$EDF
    la:Any := coerce(search((d01apfextra@S),hints)$Result)@Any
    list:LDF := retract(la)$AnyFunctions1(LDF)
    Fac1:EDF := (Var - (getlo(args.range) :: EDF))$EDF
    Fac2:EDF := ((gethi(args.range) :: EDF) - Var)$EDF
    c := first(list)$LDF
    d := second(list)$LDF
    l := (retract(third(list)$LDF)@INT)$DF
    thebiz:EDF := (Fac1**(c :: EDF))*(Fac2**(d :: EDF))
    if l > 1 then
      if l = 2 then
        thebiz := thebiz*log(Fac1)
      else if l = 3 then
        thebiz := thebiz*log(Fac2)
      else
        thebiz := thebiz*log(Fac1)*log(Fac2)
    Fn :=  (args.fn/thebiz)$EDF
    ArgsFn := map(convert(#1)$DF,Fn)$EF2(DF,Float)
    b:Float := getButtonValue("d01apf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 75*fEvals
    f : Union(fn:FileName,fp:Asp1(G)) := [retract(ArgsFn)$Asp1(G)]
    d01apf(getlo(args.range),gethi(args.range),c,d,l,args.abserr,args.relerr,4*iw,iw,-1,f)

@
\section{domain D01AQFA d01aqfAnnaType}
<<domain D01AQFA d01aqfAnnaType>>=
)abbrev domain D01AQFA d01aqfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01aqfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01AQF, a general numerical integration routine which
++ can solve an integral of the form \newline
++ \centerline{\inputbitmap{/home/bjd/Axiom/anna/hypertex/bitmaps/d01aqf.xbm}}   
++ The function \axiomFun{measure} measures the usefulness of the routine 
++ D01AQF for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01aqfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    Den := denominator(args.fn)
--    one? Den =>
    (Den = 1) =>
      [0.0,"d01aqf: A suitable weight function has not been found", ext]
    listOfZeros:LDF := problemPoints(args.fn,args.var,args.range)
    numberOfZeros := (#(listOfZeros))$LDF
    zero?(numberOfZeros) =>
      [0.0,"d01aqf: A suitable weight function has not been found", ext]
    numberOfZeros = 1 =>
      s:SDF := singularitiesOf(args)
      more?(s,1)$SDF => 
        [0.0,"d01aqf: Too many singularities have been found", ext]
      cFloat:Float := (convert(first(listOfZeros)$LDF)@Float)$DF
      cString:ST := (convert(cFloat)@ST)$Float
      lany:Any := coerce(listOfZeros)$AnyFunctions1(LDF)
      ex:Record(key:S,entry:Any) := [d01aqfextra@S,lany]
      ext := insert!(ex,ext)$Result
      [getMeasure(R,d01aqf@S)$RT, "Recommended is d01aqf with the "
        "hilbertian weight function of 1/(x-c) where c = " cString, ext]
    [0.0,"d01aqf: More than one factor has been found and so does not "
                "have a suitable weight function",ext]

  numericalIntegration(args:NIA,hints:Result) ==
    Args := copy args
    ca:Any :=  coerce(search((d01aqfextra@S),hints)$Result)@Any
    c:DF := first(retract(ca)$AnyFunctions1(LDF))$LDF
    ci:FI := df2fi(c)$ExpertSystemToolsPackage
    Var:EFI := Args.var :: EFI
    Gx:EFI := (Var-(ci::EFI))*(edf2efi(Args.fn)$ExpertSystemToolsPackage)
    ArgsFn := map(convert(#1)$FI,Gx)$EF2(FI,Float)
    b:Float := getButtonValue("d01aqf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 75*fEvals
    f : Union(fn:FileName,fp:Asp1(G)) := [retract(ArgsFn)$Asp1(G)]
    d01aqf(getlo(Args.range),gethi(Args.range),c,Args.abserr,Args.relerr,4*iw,iw,-1,f)

@
\section{domain D01ALFA d01alfAnnaType}
<<domain D01ALFA d01alfAnnaType>>=
)abbrev domain D01ALFA d01alfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01alfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01ALF, a general numerical integration routine which
++ can handle a list of singularities.  The 
++ function \axiomFun{measure} measures the usefulness of the routine D01ALF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01alfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    streamOfZeros:SDF := singularitiesOf(args)
    listOfZeros:LST := removeDuplicates!(sdf2lst(streamOfZeros))
    numberOfZeros:INT := # listOfZeros
    (numberOfZeros > 15)@Boolean => 
      [0.0,"d01alf: The list of singularities is too long", ext]
    positive?(numberOfZeros) =>
      l:LDF := entries(complete(streamOfZeros)$SDF)$SDF
      lany:Any := coerce(l)$AnyFunctions1(LDF)
      ex:Record(key:S,entry:Any) := [d01alfextra@S,lany]
      ext := insert!(ex,ext)$Result
      st:ST := "Recommended is d01alf with the singularities "
                     commaSeparate(listOfZeros)
      m := 
--        one?(numberOfZeros) => 0.4
        (numberOfZeros = 1) => 0.4
        getMeasure(R,d01alf@S)$RT
      [m, st, ext]
    [0.0, "d01alf: A list of suitable singularities has not been found", ext]

  numericalIntegration(args:NIA,hints:Result) ==
    la:Any := coerce(search((d01alfextra@S),hints)$Result)@Any
    listOfZeros:LDF := retract(la)$AnyFunctions1(LDF)
    l:= removeDuplicates(listOfZeros)$LDF
    n:Integer := (#(l))$List(DF)
    M:Matrix DF := matrix([l])$(Matrix DF)
    b:Float := getButtonValue("d01alf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 75*fEvals
    ArgsFn := map(convert(#1)$DF,args.fn)$EF2(DF,Float)
    f : Union(fn:FileName,fp:Asp1(F)) := [retract(ArgsFn)$Asp1(F)]
    d01alf(getlo(args.range),gethi(args.range),n,M,args.abserr,args.relerr,2*n*iw,n*iw,-1,f)

@
\section{domain D01ANFA d01anfAnnaType}
<<domain D01ANFA d01anfAnnaType>>=
)abbrev domain D01ANFA d01anfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01anfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01ANF, a numerical integration routine which can
++ handle weight functions of the form cos(\omega x) or sin(\omega x).  The 
++ function \axiomFun{measure} measures the usefulness of the routine D01ANF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01anfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01WeightsPackage, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    weight:Union(Record(op:BOP,w:DF),"failed") :=
      exprHasWeightCosWXorSinWX(args)
    weight case "failed" => 
      [0.0,"d01anf: A suitable weight has not been found", ext]
    weight case Record(op:BOP,w:DF) =>
      wany := coerce(weight)$AnyFunctions1(Record(op:BOP,w:DF))
      ex:Record(key:S,entry:Any) := [d01anfextra@S,wany]
      ext := insert!(ex,ext)$Result
      ws:ST := string(name(weight.op)$BOP)$S "(" df2st(weight.w)
                          string(args.var)$S ")"
      [getMeasure(R,d01anf@S)$RT,
        "d01anf: The expression has a suitable weight:- " ws, ext]
    
  numericalIntegration(args:NIA,hints:Result) ==
    a:INT
    r:Any := coerce(search((d01anfextra@S),hints)$Result)@Any
    rec:Record(op:BOP,w:DF) := retract(r)$AnyFunctions1(Record(op:BOP,w:DF))
    Var := args.var :: EDF
    o:BOP := rec.op
    den:EDF := o((rec.w*Var)$EDF)
    Argsfn:EDF := args.fn/den
    if (name(o) = cos@S)@Boolean then a := 1
    else a := 2
    b:Float := getButtonValue("d01anf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 75*fEvals
    ArgsFn := map(convert(#1)$DF,Argsfn)$EF2(DF,Float)
    f : Union(fn:FileName,fp:Asp1(G)) := [retract(ArgsFn)$Asp1(G)]
    d01anf(getlo(args.range),gethi(args.range),rec.w,a,args.abserr,args.relerr,4*iw,iw,-1,f)

@
\section{domain D01ASFA d01asfAnnaType}
<<domain D01ASFA d01asfAnnaType>>=
)abbrev domain D01ASFA d01asfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01asfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01ASF, a numerical integration routine which can
++ handle weight functions of the form cos(\omega x) or sin(\omega x) on an
++ semi-infinite range.  The 
++ function \axiomFun{measure} measures the usefulness of the routine D01ASF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01asfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01WeightsPackage, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:NIA) ==
    ext:Result := empty()$Result
    Range := rangeIsFinite(args)
    not(Range case upperInfinite) =>
      [0.0,"d01asf is not a suitable routine for infinite integrals",ext]
    weight: Union(Record(op:BOP,w:DF),"failed") :=
      exprHasWeightCosWXorSinWX(args)
    weight case "failed" => 
      [0.0,"d01asf: A suitable weight has not been found", ext]
    weight case Record(op:BOP,w:DF) =>
      wany := coerce(weight)$AnyFunctions1(Record(op:BOP,w:DF))
      ex:Record(key:S,entry:Any) := [d01asfextra@S,wany]
      ext := insert!(ex,ext)$Result
      ws:ST := string(name(weight.op)$BOP)$S "(" df2st(weight.w)
                          string(args.var)$S ")"
      [getMeasure(R,d01asf@S)$RT,
        "d01asf: A suitable weight has been found:- " ws, ext]
    
  numericalIntegration(args:NIA,hints:Result) ==
    i:INT
    r:Any := coerce(search((d01asfextra@S),hints)$Result)@Any
    rec:Record(op:BOP,w:DF) := retract(r)$AnyFunctions1(Record(op:BOP,w:DF))
    Var := args.var :: EDF
    o:BOP := rec.op
    den:EDF := o((rec.w*Var)$EDF)
    Argsfn:EDF := args.fn/den
    if (name(o) = cos@S)@Boolean then i := 1
    else i := 2
    b:Float := getButtonValue("d01asf","functionEvaluations")$AttributeButtons
    fEvals:INT := wholePart exp(1.1513*(1.0/(2.0*(1.0-b))))
    iw:INT := 75*fEvals
    ArgsFn := map(convert(#1)$DF,Argsfn)$EF2(DF,Float)
    f : Union(fn:FileName,fp:Asp1(G)) := [retract(ArgsFn)$Asp1(G)]
    err :=
      positive?(args.abserr) => args.abserr
      args.relerr
    d01asf(getlo(args.range),rec.w,i,err,50,4*iw,2*iw,-1,f)

@
\section{domain D01GBFA d01gbfAnnaType}
<<domain D01GBFA d01gbfAnnaType>>=
)abbrev domain D01GBFA d01gbfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01gbfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01GBF, a numerical integration routine which can
++ handle multi-dimensional quadrature over a finite region.  The 
++ function \axiomFun{measure} measures the usefulness of the routine D01GBF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01gbfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:MDNIA) ==
    ext:Result := empty()$Result
    (rel := args.relerr) < 0.01 :: DF => 
      [0.1, "d01gbf: The relative error requirement is too small",ext]
    segs := args.range
    vars := variables(args.fn)$EDF
    for i in 1..# vars repeat
      nia:NIA := [vars.i,args.fn,segs.i,args.abserr,rel]
      not rangeIsFinite(nia) case finite => return
        [0.0,"d01gbf is not a suitable routine for infinite integrals",ext]
    [getMeasure(R,d01gbf@S)$RT, "Recommended is d01gbf", ext]

  numericalIntegration(args:MDNIA,hints:Result) ==
    import Integer
    segs := args.range
    dim:INT := # segs
    low:Matrix DF := matrix([[getlo(segs.i) for i in 1..dim]])$(Matrix DF)
    high:Matrix DF := matrix([[gethi(segs.i) for i in 1..dim]])$(Matrix DF)
    b:Float := getButtonValue("d01gbf","functionEvaluations")$AttributeButtons
    a:Float:= exp(1.1513*(1.0/(2.0*(1.0-b))))
    maxcls:INT := 1500*(dim+1)*(fEvals:INT := wholePart(a))
    mincls:INT := 300*fEvals
    c:Float := nthRoot((maxcls::Float)/4.0,dim)$Float
    lenwrk:INT := 3*dim*(d:INT := wholePart(c))+10*dim
    wrkstr:Matrix DF := matrix([[0$DF for i in 1..lenwrk]])$(Matrix DF)
    ArgsFn := map(convert(#1)$DF,args.fn)$EF2(DF,Float)
    f : Union(fn:FileName,fp:Asp4(FUNCTN)) := [retract(ArgsFn)$Asp4(FUNCTN)]
    out:Result := d01gbf(dim,low,high,maxcls,args.relerr,lenwrk,mincls,wrkstr,-1,f)
    changeName(finest@Symbol,result@Symbol,out)

@
\section{domain D01FCFA d01fcfAnnaType}
<<domain D01FCFA d01fcfAnnaType>>=
)abbrev domain D01FCFA d01fcfAnnaType
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: measure, numericalIntegration
++ Related Constructors: Result, RoutinesTable
++ Description:
++ \axiomType{d01fcfAnnaType} is a domain of \axiomType{NumericalIntegrationCategory}
++ for the NAG routine D01FCF, a numerical integration routine which can
++ handle multi-dimensional quadrature over a finite region.  The 
++ function \axiomFun{measure} measures the usefulness of the routine D01GBF
++ for the given problem.  The function \axiomFun{numericalIntegration}
++ performs the integration by using \axiomType{NagIntegrationPackage}.

d01fcfAnnaType(): NumericalIntegrationCategory == Result add
  EF2	==> ExpressionFunctions2
  EDF	==> Expression DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  FI	==> Fraction Integer
  EFI	==> Expression Fraction Integer
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  S	==> Symbol
  ST	==> String
  LST	==> List String
  RT	==> RoutinesTable
  Rep:=Result
  import Rep, d01AgentsPackage, NagIntegrationPackage

  measure(R:RT,args:MDNIA) ==
    ext:Result := empty()$Result
    segs := args.range
    vars := variables(args.fn)$EDF
    for i in 1..# vars repeat
      nia:NIA := [vars.i,args.fn,segs.i,args.abserr,args.relerr]
      not rangeIsFinite(nia) case finite => return
        [0.0,"d01fcf is not a suitable routine for infinite integrals",ext]
    [getMeasure(R,d01fcf@S)$RT, "Recommended is d01fcf", ext]

  numericalIntegration(args:MDNIA,hints:Result) ==
    import Integer
    segs := args.range
    dim := # segs
    err := args.relerr
    low:Matrix DF := matrix([[getlo(segs.i) for i in 1..dim]])$(Matrix DF)
    high:Matrix DF := matrix([[gethi(segs.i) for i in 1..dim]])$(Matrix DF)
    b:Float := getButtonValue("d01fcf","functionEvaluations")$AttributeButtons
    a:Float:= exp(1.1513*(1.0/(2.0*(1.0-b))))
    alpha:INT := 2**dim+2*dim**2+2*dim+1
    d:Float := max(1.e-3,nthRoot(convert(err)@Float,4))$Float
    minpts:INT := (fEvals := wholePart(a))*wholePart(alpha::Float/d)
    maxpts:INT := 5*minpts
    lenwrk:INT := (dim+2)*(1+(33*fEvals))
    ArgsFn := map(convert(#1)$DF,args.fn)$EF2(DF,Float)
    f : Union(fn:FileName,fp:Asp4(FUNCTN)) := [retract(ArgsFn)$Asp4(FUNCTN)]
    out:Result := d01fcf(dim,low,high,maxpts,err,lenwrk,minpts,-1,f)
    changeName(finval@Symbol,result@Symbol,out)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain D01AJFA d01ajfAnnaType>>
<<domain D01AKFA d01akfAnnaType>>
<<domain D01AMFA d01amfAnnaType>>
<<domain D01AQFA d01aqfAnnaType>>
<<domain D01APFA d01apfAnnaType>>
<<domain D01ALFA d01alfAnnaType>>
<<domain D01ANFA d01anfAnnaType>>
<<domain D01ASFA d01asfAnnaType>>
<<domain D01GBFA d01gbfAnnaType>>
<<domain D01FCFA d01fcfAnnaType>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
