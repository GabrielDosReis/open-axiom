\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra symbol.spad}
\author{Stephen M. Watt}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain SYMBOL Symbol}
<<domain SYMBOL Symbol>>=
)abbrev domain SYMBOL Symbol
++ Author: Stephen Watt
++ Date Created: 1986
++ Date Last Updated: 7 Mar 1991, 29 Apr. 1994 (FDLL)
++ Description:
++   Basic and scripted symbols.
++ Keywords: symbol.
Symbol(): Exports == Implementation where
  L ==> List OutputForm
  Scripts ==> Record(sub:L,sup:L,presup:L,presub:L,args:L)

  Exports ==> Join(OrderedSet, ConvertibleTo InputForm, OpenMath,
        ConvertibleTo Symbol,
         ConvertibleTo Pattern Integer, ConvertibleTo Pattern Float,
          PatternMatchable Integer, PatternMatchable Float) with
     new: () -> %
       ++ new() returns a new symbol whose name starts with %.
     new: % -> %
       ++ new(s) returns a new symbol whose name starts with %s.
     resetNew: () -> Void
       ++ resetNew() resets the internals counters that new() and
       ++ new(s) use to return distinct symbols every time.
     coerce: String -> %
       ++ coerce(s) converts the string s to a symbol.
     name: % -> %
       ++ name(s) returns s without its scripts.
     scripted?: % -> Boolean
       ++ scripted?(s) is true if s has been given any scripts.
     scripts: % -> Scripts
       ++ scripts(s) returns all the scripts of s.
     script: (%, List L) -> %
       ++ script(s, [a,b,c,d,e]) returns s with subscripts a,
       ++ superscripts b, pre-superscripts c, pre-subscripts d,
       ++ and argument-scripts e.  Omitted components are taken to be empty.
       ++ For example, \spad{script(s, [a,b,c])} is equivalent to
       ++ \spad{script(s,[a,b,c,[],[]])}.
     script: (%, Scripts) -> %
       ++ script(s, [a,b,c,d,e]) returns s with subscripts a,
       ++ superscripts b, pre-superscripts c, pre-subscripts d,
       ++ and argument-scripts e.
     subscript: (%, L) -> %
       ++ subscript(s, [a1,...,an]) returns s
       ++ subscripted by \spad{[a1,...,an]}.
     superscript: (%, L) -> %
       ++ superscript(s, [a1,...,an]) returns s
       ++ superscripted by \spad{[a1,...,an]}.
     argscript: (%, L) -> %
       ++ argscript(s, [a1,...,an]) returns s
       ++ arg-scripted by \spad{[a1,...,an]}.
     elt: (%, L) -> %
       ++ elt(s,[a1,...,an]) or s([a1,...,an]) returns s subscripted by \spad{[a1,...,an]}.
     string: % -> String
       ++ string(s) converts the symbol s to a string.
       ++ Error: if the symbol is subscripted.
     list: % -> List %
       ++ list(sy) takes a scripted symbol and produces a list
       ++ of the name followed by the scripts.
     sample: constant -> %
       ++ sample() returns a sample of %

  Implementation ==> add
    count: Reference(Integer) := ref 0
    xcount: AssociationList(%, Integer) := empty()
    istrings:PrimitiveArray(String) :=
                     construct ["0","1","2","3","4","5","6","7","8","9"]
    -- the following 3 strings shall be of empty intersection
    nums:String:="0123456789"
    ALPHAS:String:="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    alphas:String:="abcdefghijklmnopqrstuvwxyz"

    writeOMSym(dev: OpenMathDevice, x: %): Void ==
      scripted? x =>
        error "Cannot convert a scripted symbol to OpenMath"
      OMputVariable(dev, x pretend Symbol)

    OMwrite(x: %): String ==
      s: String := ""
      sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
      dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
      OMputObject(dev)
      writeOMSym(dev, x)
      OMputEndObject(dev)
      OMclose(dev)
      s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
      s

    OMwrite(x: %, wholeObj: Boolean): String ==
      s: String := ""
      sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
      dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
      if wholeObj then
        OMputObject(dev)
      writeOMSym(dev, x)
      if wholeObj then
        OMputEndObject(dev)
      OMclose(dev)
      s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
      s

    OMwrite(dev: OpenMathDevice, x: %): Void ==
      OMputObject(dev)
      writeOMSym(dev, x)
      OMputEndObject(dev)

    OMwrite(dev: OpenMathDevice, x: %, wholeObj: Boolean): Void ==
      if wholeObj then
        OMputObject(dev)
      writeOMSym(dev, x)
      if wholeObj then
        OMputEndObject(dev)

    hd:String    := "*"
    lhd          := #hd
    ord0         := ord char("0")$Character

    istring  : Integer -> String
    syprefix : Scripts -> String
    syscripts: Scripts -> L

    convert(s:%):InputForm == convert(s pretend Symbol)$InputForm
    convert(s:%):Symbol    == s pretend Symbol
    coerce(s:String):%     == VALUES(INTERN(s)$Lisp)$Lisp
    x = y                  == EQUAL(x,y)$Lisp
    x < y                  == GGREATERP(y, x)$Lisp
    coerce(x:%):OutputForm == outputForm(x pretend Symbol)
    subscript(sy, lx)      == script(sy, [lx, nil, nil(), nil(), nil()])
    elt(sy,lx)             == subscript(sy,lx)
    superscript(sy, lx)    == script(sy,[nil(),lx, nil(), nil(), nil()])
    argscript(sy, lx)      == script(sy,[nil(),nil(), nil(), nil(), lx])

    patternMatch(x:%,p:Pattern Integer,l:PatternMatchResult(Integer,%))==
      (patternMatch(x pretend Symbol, p, l pretend
       PatternMatchResult(Integer, Symbol))$PatternMatchSymbol(Integer))
         pretend PatternMatchResult(Integer, %)

    patternMatch(x:%, p:Pattern Float, l:PatternMatchResult(Float, %)) ==
      (patternMatch(x pretend Symbol, p, l pretend
       PatternMatchResult(Float, Symbol))$PatternMatchSymbol(Float))
         pretend PatternMatchResult(Float, %)

    convert(x:%):Pattern(Float) ==
      coerce(x pretend Symbol)$Pattern(Float)

    convert(x:%):Pattern(Integer) ==
      coerce(x pretend Symbol)$Pattern(Integer)

    syprefix sc ==
      ns: List Integer := [#sc.presub, #sc.presup, #sc.sup, #sc.sub]
      while #ns >= 2 and zero? first ns repeat ns := rest ns
      concat concat(concat(hd, istring(#sc.args)),
                                 [istring n for n in reverse_! ns])

    syscripts sc ==
      all := sc.presub
      all := concat(sc.presup, all)
      all := concat(sc.sup, all)
      all := concat(sc.sub, all)
      concat(all, sc.args)

    script(sy: %, ls: List L) ==
      sc: Scripts := [nil(), nil(), nil(), nil(), nil()]
      if not null ls then (sc.sub    := first ls; ls := rest ls)
      if not null ls then (sc.sup    := first ls; ls := rest ls)
      if not null ls then (sc.presup := first ls; ls := rest ls)
      if not null ls then (sc.presub := first ls; ls := rest ls)
      if not null ls then (sc.args   := first ls; ls := rest ls)
      script(sy, sc)

    script(sy: %, sc: Scripts) ==
      scripted? sy => error "Cannot add scripts to a scripted symbol"
      (concat(concat(syprefix sc, string name sy)::%::OutputForm,
                                                syscripts sc)) pretend %

    string e ==
      not scripted? e => PNAME(e)$Lisp
      error "Cannot form string from non-atomic symbols."

-- Scripts ==> Record(sub:L,sup:L,presup:L,presub:L,args:L)
    latex e ==
      s : String := (PNAME(name e)$Lisp) pretend String
      if #s > 1 and s.1 ^= char "\" then
        s := concat("\mbox{\it ", concat(s, "}")$String)$String
      not scripted? e => s
      ss : Scripts := scripts e
      lo : List OutputForm := ss.sub
      sc : String
      if not empty? lo then
        sc := "__{"
        while not empty? lo repeat
            sc := concat(sc, latex first lo)$String
            lo := rest lo
            if not empty? lo then sc := concat(sc, ", ")$String
        sc := concat(sc, "}")$String
        s := concat(s, sc)$String
      lo := ss.sup
      if not empty? lo then
        sc := "^{"
        while not empty? lo repeat
            sc := concat(sc, latex first lo)$String
            lo := rest lo
            if not empty? lo then sc := concat(sc, ", ")$String
        sc := concat(sc, "}")$String
        s := concat(s, sc)$String
      lo := ss.presup
      if not empty? lo then
        sc := "{}^{"
        while not empty? lo repeat
            sc := concat(sc, latex first lo)$String
            lo := rest lo
            if not empty? lo then sc := concat(sc, ", ")$String
        sc := concat(sc, "}")$String
        s := concat(sc, s)$String
      lo := ss.presub
      if not empty? lo then
        sc := "{}__{"
        while not empty? lo repeat
            sc := concat(sc, latex first lo)$String
            lo := rest lo
            if not empty? lo then sc := concat(sc, ", ")$String
        sc := concat(sc, "}")$String
        s := concat(sc, s)$String
      lo := ss.args
      if not empty? lo then
        sc := "\left( {"
        while not empty? lo repeat
            sc := concat(sc, latex first lo)$String
            lo := rest lo
            if not empty? lo then sc := concat(sc, ", ")$String
        sc := concat(sc, "} \right)")$String
        s := concat(s, sc)$String
      s

    anyRadix(n:Integer,s:String):String ==
      ns:String:=""
      repeat
        qr := divide(n,#s)
        n  := qr.quotient
        ns := concat(s.(qr.remainder+minIndex s),ns)
        if zero?(n) then return ns
      
    new() ==
      sym := anyRadix(count()::Integer,ALPHAS)
      count() := count() + 1
      concat("%",sym)::%

    new x ==
      n:Integer :=
        (u := search(x, xcount)) case "failed" => 0
        inc(u::Integer)
      xcount(x) := n
      xx := 
        not scripted? x => string x
        string name x
      xx := concat("%",xx)
      xx :=
        (position(xx.maxIndex(xx),nums)>=minIndex(nums)) => 
          concat(xx, anyRadix(n,alphas))
        concat(xx, anyRadix(n,nums))
      not scripted? x => xx::%
      script(xx::%,scripts x)

    resetNew() ==
      count() := 0
      for k in keys xcount repeat remove_!(k, xcount)
      void

    scripted? sy ==
      not ATOM(sy)$Lisp

    name sy ==
      not scripted? sy => sy
      str := string first list sy
      for i in lhd+1..#str repeat
        not digit?(str.i) => return((str.(i..#str))::%)
      error "Improper scripted symbol"

    scripts sy ==
      not scripted? sy => [nil(), nil(), nil(), nil(), nil()]
      nscripts: List NonNegativeInteger := [0, 0, 0, 0, 0]
      lscripts: List L := [nil(), nil(), nil(), nil(), nil()]
      str  := string first list sy
      nstr := #str
      m := minIndex nscripts
      for i in m.. for j in lhd+1..nstr while digit?(str.j) repeat
          nscripts.i := (ord(str.j) - ord0)::NonNegativeInteger
      -- Put the number of function scripts at the end.
      nscripts := concat(rest nscripts, first nscripts)
      allscripts := rest list sy
      m := minIndex lscripts
      for i in m.. for n in nscripts repeat
        #allscripts < n => error "Improper script count in symbol"
        lscripts.i := [a::OutputForm for a in first(allscripts, n)]
        allscripts := rest(allscripts, n)
      [lscripts.m, lscripts.(m+1), lscripts.(m+2),
                                         lscripts.(m+3), lscripts.(m+4)]

    istring n ==
      n > 9 => error "Can have at most 9 scripts of each kind"
      istrings.(n + minIndex istrings)

    list sy ==
      not scripted? sy =>
         error "Cannot convert a symbol to a list if it is not subscripted"
      sy pretend List(%)

    sample() == "aSymbol"::%

@
\section{SYMBOL.lsp BOOTSTRAP} 
{\bf SYMBOL} depends on a chain of
files. We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf SYMBOL} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf SYMBOL.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<SYMBOL.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |SYMBOL;writeOMSym| (|dev| |x| |$|) (COND ((SPADCALL |x| (QREFELT |$| 21)) (|error| "Cannot convert a scripted symbol to OpenMath")) ((QUOTE T) (SPADCALL |dev| |x| (QREFELT |$| 25))))) 

(DEFUN |SYMBOL;OMwrite;$S;2| (|x| |$|) (PROG (|sp| |dev| |s|) (RETURN (SEQ (LETT |s| "" |SYMBOL;OMwrite;$S;2|) (LETT |sp| (|OM-STRINGTOSTRINGPTR| |s|) |SYMBOL;OMwrite;$S;2|) (LETT |dev| (SPADCALL |sp| (SPADCALL (QREFELT |$| 27)) (QREFELT |$| 29)) |SYMBOL;OMwrite;$S;2|) (SPADCALL |dev| (QREFELT |$| 30)) (|SYMBOL;writeOMSym| |dev| |x| |$|) (SPADCALL |dev| (QREFELT |$| 31)) (SPADCALL |dev| (QREFELT |$| 32)) (LETT |s| (|OM-STRINGPTRTOSTRING| |sp|) |SYMBOL;OMwrite;$S;2|) (EXIT |s|))))) 

(DEFUN |SYMBOL;OMwrite;$BS;3| (|x| |wholeObj| |$|) (PROG (|sp| |dev| |s|) (RETURN (SEQ (LETT |s| "" |SYMBOL;OMwrite;$BS;3|) (LETT |sp| (|OM-STRINGTOSTRINGPTR| |s|) |SYMBOL;OMwrite;$BS;3|) (LETT |dev| (SPADCALL |sp| (SPADCALL (QREFELT |$| 27)) (QREFELT |$| 29)) |SYMBOL;OMwrite;$BS;3|) (COND (|wholeObj| (SPADCALL |dev| (QREFELT |$| 30)))) (|SYMBOL;writeOMSym| |dev| |x| |$|) (COND (|wholeObj| (SPADCALL |dev| (QREFELT |$| 31)))) (SPADCALL |dev| (QREFELT |$| 32)) (LETT |s| (|OM-STRINGPTRTOSTRING| |sp|) |SYMBOL;OMwrite;$BS;3|) (EXIT |s|))))) 

(DEFUN |SYMBOL;OMwrite;Omd$V;4| (|dev| |x| |$|) (SEQ (SPADCALL |dev| (QREFELT |$| 30)) (|SYMBOL;writeOMSym| |dev| |x| |$|) (EXIT (SPADCALL |dev| (QREFELT |$| 31))))) 

(DEFUN |SYMBOL;OMwrite;Omd$BV;5| (|dev| |x| |wholeObj| |$|) (SEQ (COND (|wholeObj| (SPADCALL |dev| (QREFELT |$| 30)))) (|SYMBOL;writeOMSym| |dev| |x| |$|) (EXIT (COND (|wholeObj| (SPADCALL |dev| (QREFELT |$| 31))))))) 

(DEFUN |SYMBOL;convert;$If;6| (|s| |$|) (SPADCALL |s| (QREFELT |$| 44))) 

(PUT (QUOTE |SYMBOL;convert;2$;7|) (QUOTE |SPADreplace|) (QUOTE (XLAM (|s|) |s|))) 

(DEFUN |SYMBOL;convert;2$;7| (|s| |$|) |s|) 

(DEFUN |SYMBOL;coerce;S$;8| (|s| |$|) (VALUES (INTERN |s|))) 

(PUT (QUOTE |SYMBOL;=;2$B;9|) (QUOTE |SPADreplace|) (QUOTE EQUAL)) 

(DEFUN |SYMBOL;=;2$B;9| (|x| |y| |$|) (EQUAL |x| |y|)) 

(PUT (QUOTE |SYMBOL;<;2$B;10|) (QUOTE |SPADreplace|) (QUOTE (XLAM (|x| |y|) (GGREATERP |y| |x|)))) 

(DEFUN |SYMBOL;<;2$B;10| (|x| |y| |$|) (GGREATERP |y| |x|)) 

(DEFUN |SYMBOL;coerce;$Of;11| (|x| |$|) (SPADCALL |x| (QREFELT |$| 51))) 

(DEFUN |SYMBOL;subscript;$L$;12| (|sy| |lx| |$|) (SPADCALL |sy| (LIST |lx| NIL NIL NIL NIL) (QREFELT |$| 54))) 

(DEFUN |SYMBOL;elt;$L$;13| (|sy| |lx| |$|) (SPADCALL |sy| |lx| (QREFELT |$| 56))) 

(DEFUN |SYMBOL;superscript;$L$;14| (|sy| |lx| |$|) (SPADCALL |sy| (LIST NIL |lx| NIL NIL NIL) (QREFELT |$| 54))) 

(DEFUN |SYMBOL;argscript;$L$;15| (|sy| |lx| |$|) (SPADCALL |sy| (LIST NIL NIL NIL NIL |lx|) (QREFELT |$| 54))) 

(DEFUN |SYMBOL;patternMatch;$P2Pmr;16| (|x| |p| |l| |$|) (SPADCALL |x| |p| |l| (QREFELT |$| 63))) 

(DEFUN |SYMBOL;patternMatch;$P2Pmr;17| (|x| |p| |l| |$|) (SPADCALL |x| |p| |l| (QREFELT |$| 69))) 

(DEFUN |SYMBOL;convert;$P;18| (|x| |$|) (SPADCALL |x| (QREFELT |$| 72))) 

(DEFUN |SYMBOL;convert;$P;19| (|x| |$|) (SPADCALL |x| (QREFELT |$| 74))) 

(DEFUN |SYMBOL;syprefix| (|sc| |$|) (PROG (|ns| #1=#:G108218 |n| #2=#:G108219) (RETURN (SEQ (LETT |ns| (LIST (LENGTH (QVELT |sc| 3)) (LENGTH (QVELT |sc| 2)) (LENGTH (QVELT |sc| 1)) (LENGTH (QVELT |sc| 0))) |SYMBOL;syprefix|) (SEQ G190 (COND ((NULL (COND ((|<| (LENGTH |ns|) 2) (QUOTE NIL)) ((QUOTE T) (ZEROP (|SPADfirst| |ns|))))) (GO G191))) (SEQ (EXIT (LETT |ns| (CDR |ns|) |SYMBOL;syprefix|))) NIL (GO G190) G191 (EXIT NIL)) (EXIT (SPADCALL (CONS (STRCONC (QREFELT |$| 37) (|SYMBOL;istring| (LENGTH (QVELT |sc| 4)) |$|)) (PROGN (LETT #1# NIL |SYMBOL;syprefix|) (SEQ (LETT |n| NIL |SYMBOL;syprefix|) (LETT #2# (NREVERSE |ns|) |SYMBOL;syprefix|) G190 (COND ((OR (ATOM #2#) (PROGN (LETT |n| (CAR #2#) |SYMBOL;syprefix|) NIL)) (GO G191))) (SEQ (EXIT (LETT #1# (CONS (|SYMBOL;istring| |n| |$|) #1#) |SYMBOL;syprefix|))) (LETT #2# (CDR #2#) |SYMBOL;syprefix|) (GO G190) G191 (EXIT (NREVERSE0 #1#))))) (QREFELT |$| 77))))))) 

(DEFUN |SYMBOL;syscripts| (|sc| |$|) (PROG (|all|) (RETURN (SEQ (LETT |all| (QVELT |sc| 3) |SYMBOL;syscripts|) (LETT |all| (SPADCALL (QVELT |sc| 2) |all| (QREFELT |$| 78)) |SYMBOL;syscripts|) (LETT |all| (SPADCALL (QVELT |sc| 1) |all| (QREFELT |$| 78)) |SYMBOL;syscripts|) (LETT |all| (SPADCALL (QVELT |sc| 0) |all| (QREFELT |$| 78)) |SYMBOL;syscripts|) (EXIT (SPADCALL |all| (QVELT |sc| 4) (QREFELT |$| 78))))))) 

(DEFUN |SYMBOL;script;$L$;22| (|sy| |ls| |$|) (PROG (|sc|) (RETURN (SEQ (LETT |sc| (VECTOR NIL NIL NIL NIL NIL) |SYMBOL;script;$L$;22|) (COND ((NULL (NULL |ls|)) (SEQ (QSETVELT |sc| 0 (|SPADfirst| |ls|)) (EXIT (LETT |ls| (CDR |ls|) |SYMBOL;script;$L$;22|))))) (COND ((NULL (NULL |ls|)) (SEQ (QSETVELT |sc| 1 (|SPADfirst| |ls|)) (EXIT (LETT |ls| (CDR |ls|) |SYMBOL;script;$L$;22|))))) (COND ((NULL (NULL |ls|)) (SEQ (QSETVELT |sc| 2 (|SPADfirst| |ls|)) (EXIT (LETT |ls| (CDR |ls|) |SYMBOL;script;$L$;22|))))) (COND ((NULL (NULL |ls|)) (SEQ (QSETVELT |sc| 3 (|SPADfirst| |ls|)) (EXIT (LETT |ls| (CDR |ls|) |SYMBOL;script;$L$;22|))))) (COND ((NULL (NULL |ls|)) (SEQ (QSETVELT |sc| 4 (|SPADfirst| |ls|)) (EXIT (LETT |ls| (CDR |ls|) |SYMBOL;script;$L$;22|))))) (EXIT (SPADCALL |sy| |sc| (QREFELT |$| 80))))))) 

(DEFUN |SYMBOL;script;$R$;23| (|sy| |sc| |$|) (COND ((SPADCALL |sy| (QREFELT |$| 21)) (|error| "Cannot add scripts to a scripted symbol")) ((QUOTE T) (CONS (SPADCALL (SPADCALL (STRCONC (|SYMBOL;syprefix| |sc| |$|) (SPADCALL (SPADCALL |sy| (QREFELT |$| 81)) (QREFELT |$| 82))) (QREFELT |$| 47)) (QREFELT |$| 52)) (|SYMBOL;syscripts| |sc| |$|))))) 

(DEFUN |SYMBOL;string;$S;24| (|e| |$|) (COND ((NULL (SPADCALL |e| (QREFELT |$| 21))) (PNAME |e|)) ((QUOTE T) (|error| "Cannot form string from non-atomic symbols.")))) 

(DEFUN |SYMBOL;latex;$S;25| (|e| |$|) (PROG (|ss| |lo| |sc| |s|) (RETURN (SEQ (LETT |s| (PNAME (SPADCALL |e| (QREFELT |$| 81))) |SYMBOL;latex;$S;25|) (COND ((|<| 1 (QCSIZE |s|)) (COND ((NULL (SPADCALL (SPADCALL |s| 1 (QREFELT |$| 83)) (SPADCALL "\\" (QREFELT |$| 40)) (QREFELT |$| 84))) (LETT |s| (STRCONC "\\mbox{\\it " (STRCONC |s| "}")) |SYMBOL;latex;$S;25|))))) (COND ((NULL (SPADCALL |e| (QREFELT |$| 21))) (EXIT |s|))) (LETT |ss| (SPADCALL |e| (QREFELT |$| 85)) |SYMBOL;latex;$S;25|) (LETT |lo| (QVELT |ss| 0) |SYMBOL;latex;$S;25|) (COND ((NULL (NULL |lo|)) (SEQ (LETT |sc| "_{" |SYMBOL;latex;$S;25|) (SEQ G190 (COND ((NULL (COND ((NULL |lo|) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) (GO G191))) (SEQ (LETT |sc| (STRCONC |sc| (SPADCALL (|SPADfirst| |lo|) (QREFELT |$| 86))) |SYMBOL;latex;$S;25|) (LETT |lo| (CDR |lo|) |SYMBOL;latex;$S;25|) (EXIT (COND ((NULL (NULL |lo|)) (LETT |sc| (STRCONC |sc| ", ") |SYMBOL;latex;$S;25|))))) NIL (GO G190) G191 (EXIT NIL)) (LETT |sc| (STRCONC |sc| "}") |SYMBOL;latex;$S;25|) (EXIT (LETT |s| (STRCONC |s| |sc|) |SYMBOL;latex;$S;25|))))) (LETT |lo| (QVELT |ss| 1) |SYMBOL;latex;$S;25|) (COND ((NULL (NULL |lo|)) (SEQ (LETT |sc| "^{" |SYMBOL;latex;$S;25|) (SEQ G190 (COND ((NULL (COND ((NULL |lo|) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) (GO G191))) (SEQ (LETT |sc| (STRCONC |sc| (SPADCALL (|SPADfirst| |lo|) (QREFELT |$| 86))) |SYMBOL;latex;$S;25|) (LETT |lo| (CDR |lo|) |SYMBOL;latex;$S;25|) (EXIT (COND ((NULL (NULL |lo|)) (LETT |sc| (STRCONC |sc| ", ") |SYMBOL;latex;$S;25|))))) NIL (GO G190) G191 (EXIT NIL)) (LETT |sc| (STRCONC |sc| "}") |SYMBOL;latex;$S;25|) (EXIT (LETT |s| (STRCONC |s| |sc|) |SYMBOL;latex;$S;25|))))) (LETT |lo| (QVELT |ss| 2) |SYMBOL;latex;$S;25|) (COND ((NULL (NULL |lo|)) (SEQ (LETT |sc| "{}^{" |SYMBOL;latex;$S;25|) (SEQ G190 (COND ((NULL (COND ((NULL |lo|) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) (GO G191))) (SEQ (LETT |sc| (STRCONC |sc| (SPADCALL (|SPADfirst| |lo|) (QREFELT |$| 86))) |SYMBOL;latex;$S;25|) (LETT |lo| (CDR |lo|) |SYMBOL;latex;$S;25|) (EXIT (COND ((NULL (NULL |lo|)) (LETT |sc| (STRCONC |sc| ", ") |SYMBOL;latex;$S;25|))))) NIL (GO G190) G191 (EXIT NIL)) (LETT |sc| (STRCONC |sc| "}") |SYMBOL;latex;$S;25|) (EXIT (LETT |s| (STRCONC |sc| |s|) |SYMBOL;latex;$S;25|))))) (LETT |lo| (QVELT |ss| 3) |SYMBOL;latex;$S;25|) (COND ((NULL (NULL |lo|)) (SEQ (LETT |sc| "{}_{" |SYMBOL;latex;$S;25|) (SEQ G190 (COND ((NULL (COND ((NULL |lo|) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) (GO G191))) (SEQ (LETT |sc| (STRCONC |sc| (SPADCALL (|SPADfirst| |lo|) (QREFELT |$| 86))) |SYMBOL;latex;$S;25|) (LETT |lo| (CDR |lo|) |SYMBOL;latex;$S;25|) (EXIT (COND ((NULL (NULL |lo|)) (LETT |sc| (STRCONC |sc| ", ") |SYMBOL;latex;$S;25|))))) NIL (GO G190) G191 (EXIT NIL)) (LETT |sc| (STRCONC |sc| "}") |SYMBOL;latex;$S;25|) (EXIT (LETT |s| (STRCONC |sc| |s|) |SYMBOL;latex;$S;25|))))) (LETT |lo| (QVELT |ss| 4) |SYMBOL;latex;$S;25|) (COND ((NULL (NULL |lo|)) (SEQ (LETT |sc| "\\left( {" |SYMBOL;latex;$S;25|) (SEQ G190 (COND ((NULL (COND ((NULL |lo|) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) (GO G191))) (SEQ (LETT |sc| (STRCONC |sc| (SPADCALL (|SPADfirst| |lo|) (QREFELT |$| 86))) |SYMBOL;latex;$S;25|) (LETT |lo| (CDR |lo|) |SYMBOL;latex;$S;25|) (EXIT (COND ((NULL (NULL |lo|)) (LETT |sc| (STRCONC |sc| ", ") |SYMBOL;latex;$S;25|))))) NIL (GO G190) G191 (EXIT NIL)) (LETT |sc| (STRCONC |sc| "} \\right)") |SYMBOL;latex;$S;25|) (EXIT (LETT |s| (STRCONC |s| |sc|) |SYMBOL;latex;$S;25|))))) (EXIT |s|))))) 

(DEFUN |SYMBOL;anyRadix| (|n| |s| |$|) (PROG (|qr| |ns| #1=#:G108274) (RETURN (SEQ (EXIT (SEQ (LETT |ns| "" |SYMBOL;anyRadix|) (EXIT (SEQ G190 NIL (SEQ (LETT |qr| (DIVIDE2 |n| (QCSIZE |s|)) |SYMBOL;anyRadix|) (LETT |n| (QCAR |qr|) |SYMBOL;anyRadix|) (LETT |ns| (SPADCALL (SPADCALL |s| (|+| (QCDR |qr|) (SPADCALL |s| (QREFELT |$| 88))) (QREFELT |$| 83)) |ns| (QREFELT |$| 89)) |SYMBOL;anyRadix|) (EXIT (COND ((ZEROP |n|) (PROGN (LETT #1# |ns| |SYMBOL;anyRadix|) (GO #1#)))))) NIL (GO G190) G191 (EXIT NIL))))) #1# (EXIT #1#))))) 

(DEFUN |SYMBOL;new;$;27| (|$|) (PROG (|sym|) (RETURN (SEQ (LETT |sym| (|SYMBOL;anyRadix| (SPADCALL (QREFELT |$| 9) (QREFELT |$| 90)) (QREFELT |$| 18) |$|) |SYMBOL;new;$;27|) (SPADCALL (QREFELT |$| 9) (|+| (SPADCALL (QREFELT |$| 9) (QREFELT |$| 90)) 1) (QREFELT |$| 91)) (EXIT (SPADCALL (STRCONC "%" |sym|) (QREFELT |$| 47))))))) 

(DEFUN |SYMBOL;new;2$;28| (|x| |$|) (PROG (|u| |n| |xx|) (RETURN (SEQ (LETT |n| (SEQ (LETT |u| (SPADCALL |x| (QREFELT |$| 12) (QREFELT |$| 94)) |SYMBOL;new;2$;28|) (EXIT (COND ((QEQCAR |u| 1) 0) ((QUOTE T) (|+| (QCDR |u|) 1))))) |SYMBOL;new;2$;28|) (SPADCALL (QREFELT |$| 12) |x| |n| (QREFELT |$| 95)) (LETT |xx| (COND ((NULL (SPADCALL |x| (QREFELT |$| 21))) (SPADCALL |x| (QREFELT |$| 82))) ((QUOTE T) (SPADCALL (SPADCALL |x| (QREFELT |$| 81)) (QREFELT |$| 82)))) |SYMBOL;new;2$;28|) (LETT |xx| (STRCONC "%" |xx|) |SYMBOL;new;2$;28|) (LETT |xx| (COND ((NULL (|<| (SPADCALL (SPADCALL |xx| (SPADCALL |xx| (QREFELT |$| 96)) (QREFELT |$| 83)) (QREFELT |$| 17) (QREFELT |$| 97)) (SPADCALL (QREFELT |$| 17) (QREFELT |$| 88)))) (STRCONC |xx| (|SYMBOL;anyRadix| |n| (QREFELT |$| 19) |$|))) ((QUOTE T) (STRCONC |xx| (|SYMBOL;anyRadix| |n| (QREFELT |$| 17) |$|)))) |SYMBOL;new;2$;28|) (COND ((NULL (SPADCALL |x| (QREFELT |$| 21))) (EXIT (SPADCALL |xx| (QREFELT |$| 47))))) (EXIT (SPADCALL (SPADCALL |xx| (QREFELT |$| 47)) (SPADCALL |x| (QREFELT |$| 85)) (QREFELT |$| 80))))))) 

(DEFUN |SYMBOL;resetNew;V;29| (|$|) (PROG (|k| #1=#:G108297) (RETURN (SEQ (SPADCALL (QREFELT |$| 9) 0 (QREFELT |$| 91)) (SEQ (LETT |k| NIL |SYMBOL;resetNew;V;29|) (LETT #1# (SPADCALL (QREFELT |$| 12) (QREFELT |$| 100)) |SYMBOL;resetNew;V;29|) G190 (COND ((OR (ATOM #1#) (PROGN (LETT |k| (CAR #1#) |SYMBOL;resetNew;V;29|) NIL)) (GO G191))) (SEQ (EXIT (SPADCALL |k| (QREFELT |$| 12) (QREFELT |$| 101)))) (LETT #1# (CDR #1#) |SYMBOL;resetNew;V;29|) (GO G190) G191 (EXIT NIL)) (EXIT (SPADCALL (QREFELT |$| 102))))))) 

(DEFUN |SYMBOL;scripted?;$B;30| (|sy| |$|) (COND ((ATOM |sy|) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) 

(DEFUN |SYMBOL;name;2$;31| (|sy| |$|) (PROG (|str| |i| #1=#:G108304 #2=#:G108303 #3=#:G108301) (RETURN (SEQ (EXIT (COND ((NULL (SPADCALL |sy| (QREFELT |$| 21))) |sy|) ((QUOTE T) (SEQ (LETT |str| (SPADCALL (SPADCALL (SPADCALL |sy| (QREFELT |$| 104)) (QREFELT |$| 105)) (QREFELT |$| 82)) |SYMBOL;name;2$;31|) (SEQ (EXIT (SEQ (LETT |i| (|+| (QREFELT |$| 38) 1) |SYMBOL;name;2$;31|) (LETT #1# (QCSIZE |str|) |SYMBOL;name;2$;31|) G190 (COND ((|>| |i| #1#) (GO G191))) (SEQ (EXIT (COND ((NULL (SPADCALL (SPADCALL |str| |i| (QREFELT |$| 83)) (QREFELT |$| 106))) (PROGN (LETT #3# (PROGN (LETT #2# (SPADCALL (SPADCALL |str| (SPADCALL |i| (QCSIZE |str|) (QREFELT |$| 108)) (QREFELT |$| 109)) (QREFELT |$| 47)) |SYMBOL;name;2$;31|) (GO #2#)) |SYMBOL;name;2$;31|) (GO #3#)))))) (LETT |i| (|+| |i| 1) |SYMBOL;name;2$;31|) (GO G190) G191 (EXIT NIL))) #3# (EXIT #3#)) (EXIT (|error| "Improper scripted symbol")))))) #2# (EXIT #2#))))) 

(DEFUN |SYMBOL;scripts;$R;32| (|sy| |$|) (PROG (|lscripts| |str| |nstr| |j| #1=#:G108307 |nscripts| |m| |n| #2=#:G108316 |i| #3=#:G108317 |a| #4=#:G108318 |allscripts|) (RETURN (SEQ (COND ((NULL (SPADCALL |sy| (QREFELT |$| 21))) (VECTOR NIL NIL NIL NIL NIL)) ((QUOTE T) (SEQ (LETT |nscripts| (LIST 0 0 0 0 0) |SYMBOL;scripts;$R;32|) (LETT |lscripts| (LIST NIL NIL NIL NIL NIL) |SYMBOL;scripts;$R;32|) (LETT |str| (SPADCALL (SPADCALL (SPADCALL |sy| (QREFELT |$| 104)) (QREFELT |$| 105)) (QREFELT |$| 82)) |SYMBOL;scripts;$R;32|) (LETT |nstr| (QCSIZE |str|) |SYMBOL;scripts;$R;32|) (LETT |m| (SPADCALL |nscripts| (QREFELT |$| 111)) |SYMBOL;scripts;$R;32|) (SEQ (LETT |j| (|+| (QREFELT |$| 38) 1) |SYMBOL;scripts;$R;32|) (LETT |i| |m| |SYMBOL;scripts;$R;32|) G190 (COND ((OR (|>| |j| |nstr|) (NULL (SPADCALL (SPADCALL |str| |j| (QREFELT |$| 83)) (QREFELT |$| 106)))) (GO G191))) (SEQ (EXIT (SPADCALL |nscripts| |i| (PROG1 (LETT #1# (|-| (SPADCALL (SPADCALL |str| |j| (QREFELT |$| 83)) (QREFELT |$| 41)) (QREFELT |$| 42)) |SYMBOL;scripts;$R;32|) (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#)) (QREFELT |$| 113)))) (LETT |i| (PROG1 (|+| |i| 1) (LETT |j| (|+| |j| 1) |SYMBOL;scripts;$R;32|)) |SYMBOL;scripts;$R;32|) (GO G190) G191 (EXIT NIL)) (LETT |nscripts| (SPADCALL (CDR |nscripts|) (|SPADfirst| |nscripts|) (QREFELT |$| 114)) |SYMBOL;scripts;$R;32|) (LETT |allscripts| (SPADCALL (SPADCALL |sy| (QREFELT |$| 104)) (QREFELT |$| 115)) |SYMBOL;scripts;$R;32|) (LETT |m| (SPADCALL |lscripts| (QREFELT |$| 116)) |SYMBOL;scripts;$R;32|) (SEQ (LETT |n| NIL |SYMBOL;scripts;$R;32|) (LETT #2# |nscripts| |SYMBOL;scripts;$R;32|) (LETT |i| |m| |SYMBOL;scripts;$R;32|) G190 (COND ((OR (ATOM #2#) (PROGN (LETT |n| (CAR #2#) |SYMBOL;scripts;$R;32|) NIL)) (GO G191))) (SEQ (EXIT (COND ((|<| (SPADCALL |allscripts| (QREFELT |$| 117)) |n|) (|error| "Improper script count in symbol")) ((QUOTE T) (SEQ (SPADCALL |lscripts| |i| (PROGN (LETT #3# NIL |SYMBOL;scripts;$R;32|) (SEQ (LETT |a| NIL |SYMBOL;scripts;$R;32|) (LETT #4# (SPADCALL |allscripts| |n| (QREFELT |$| 118)) |SYMBOL;scripts;$R;32|) G190 (COND ((OR (ATOM #4#) (PROGN (LETT |a| (CAR #4#) |SYMBOL;scripts;$R;32|) NIL)) (GO G191))) (SEQ (EXIT (LETT #3# (CONS (SPADCALL |a| (QREFELT |$| 52)) #3#) |SYMBOL;scripts;$R;32|))) (LETT #4# (CDR #4#) |SYMBOL;scripts;$R;32|) (GO G190) G191 (EXIT (NREVERSE0 #3#)))) (QREFELT |$| 119)) (EXIT (LETT |allscripts| (SPADCALL |allscripts| |n| (QREFELT |$| 120)) |SYMBOL;scripts;$R;32|))))))) (LETT |i| (PROG1 (|+| |i| 1) (LETT #2# (CDR #2#) |SYMBOL;scripts;$R;32|)) |SYMBOL;scripts;$R;32|) (GO G190) G191 (EXIT NIL)) (EXIT (VECTOR (SPADCALL |lscripts| |m| (QREFELT |$| 121)) (SPADCALL |lscripts| (|+| |m| 1) (QREFELT |$| 121)) (SPADCALL |lscripts| (|+| |m| 2) (QREFELT |$| 121)) (SPADCALL |lscripts| (|+| |m| 3) (QREFELT |$| 121)) (SPADCALL |lscripts| (|+| |m| 4) (QREFELT |$| 121))))))))))) 

(DEFUN |SYMBOL;istring| (|n| |$|) (COND ((|<| 9 |n|) (|error| "Can have at most 9 scripts of each kind")) ((QUOTE T) (ELT (QREFELT |$| 16) (|+| |n| 0))))) 

(DEFUN |SYMBOL;list;$L;34| (|sy| |$|) (COND ((NULL (SPADCALL |sy| (QREFELT |$| 21))) (|error| "Cannot convert a symbol to a list if it is not subscripted")) ((QUOTE T) |sy|))) 

(DEFUN |SYMBOL;sample;$;35| (|$|) (SPADCALL "aSymbol" (QREFELT |$| 47))) 

(DEFUN |Symbol| NIL (PROG NIL (RETURN (PROG (#1=#:G108325) (RETURN (COND ((LETT #1# (HGET |$ConstructorCache| (QUOTE |Symbol|)) |Symbol|) (|CDRwithIncrement| (CDAR #1#))) ((QUOTE T) (|UNWIND-PROTECT| (PROG1 (CDDAR (HPUT |$ConstructorCache| (QUOTE |Symbol|) (LIST (CONS NIL (CONS 1 (|Symbol;|)))))) (LETT #1# T |Symbol|)) (COND ((NOT #1#) (HREM |$ConstructorCache| (QUOTE |Symbol|)))))))))))) 

(DEFUN |Symbol;| NIL (PROG (|dv$| |$| |pv$|) (RETURN (PROGN (LETT |dv$| (QUOTE (|Symbol|)) . #1=(|Symbol|)) (LETT |$| (GETREFV 124) . #1#) (QSETREFV |$| 0 |dv$|) (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#)) (|haddProp| |$ConstructorCache| (QUOTE |Symbol|) NIL (CONS 1 |$|)) (|stuffDomainSlots| |$|) (QSETREFV |$| 9 (SPADCALL 0 (QREFELT |$| 8))) (QSETREFV |$| 12 (SPADCALL (QREFELT |$| 11))) (QSETREFV |$| 16 (SPADCALL (LIST #2="0" "1" "2" "3" "4" "5" "6" "7" "8" "9") (QREFELT |$| 15))) (QSETREFV |$| 17 "0123456789") (QSETREFV |$| 18 "ABCDEFGHIJKLMNOPQRSTUVWXYZ") (QSETREFV |$| 19 "abcdefghijklmnopqrstuvwxyz") (QSETREFV |$| 37 "*") (QSETREFV |$| 38 (QCSIZE (QREFELT |$| 37))) (QSETREFV |$| 42 (SPADCALL (SPADCALL #2# (QREFELT |$| 40)) (QREFELT |$| 41))) |$|)))) 

(MAKEPROP (QUOTE |Symbol|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|Integer|) (|Reference| 6) (0 . |ref|) (QUOTE |count|) (|AssociationList| |$$| 6) (5 . |empty|) (QUOTE |xcount|) (|List| 28) (|PrimitiveArray| 28) (9 . |construct|) (QUOTE |istrings|) (QUOTE |nums|) (QUOTE ALPHAS) (QUOTE |alphas|) (|Boolean|) |SYMBOL;scripted?;$B;30| (|Void|) (|Symbol|) (|OpenMathDevice|) (14 . |OMputVariable|) (|OpenMathEncoding|) (20 . |OMencodingXML|) (|String|) (24 . |OMopenString|) (30 . |OMputObject|) (35 . |OMputEndObject|) (40 . |OMclose|) |SYMBOL;OMwrite;$S;2| |SYMBOL;OMwrite;$BS;3| |SYMBOL;OMwrite;Omd$V;4| |SYMBOL;OMwrite;Omd$BV;5| (QUOTE |hd|) (QUOTE |lhd|) (|Character|) (45 . |char|) (50 . |ord|) (QUOTE |ord0|) (|InputForm|) (55 . |convert|) |SYMBOL;convert;$If;6| |SYMBOL;convert;2$;7| |SYMBOL;coerce;S$;8| |SYMBOL;=;2$B;9| |SYMBOL;<;2$B;10| (|OutputForm|) (60 . |outputForm|) |SYMBOL;coerce;$Of;11| (|List| 55) |SYMBOL;script;$L$;22| (|List| 50) |SYMBOL;subscript;$L$;12| |SYMBOL;elt;$L$;13| |SYMBOL;superscript;$L$;14| |SYMBOL;argscript;$L$;15| (|PatternMatchResult| 6 23) (|Pattern| 6) (|PatternMatchSymbol| 6) (65 . |patternMatch|) (|PatternMatchResult| 6 |$|) |SYMBOL;patternMatch;$P2Pmr;16| (|PatternMatchResult| (|Float|) 23) (|Pattern| (|Float|)) (|PatternMatchSymbol| (|Float|)) (72 . |patternMatch|) (|PatternMatchResult| (|Float|) |$|) |SYMBOL;patternMatch;$P2Pmr;17| (79 . |coerce|) |SYMBOL;convert;$P;18| (84 . |coerce|) |SYMBOL;convert;$P;19| (|List| |$|) (89 . |concat|) (94 . |concat|) (|Record| (|:| |sub| 55) (|:| |sup| 55) (|:| |presup| 55) (|:| |presub| 55) (|:| |args| 55)) |SYMBOL;script;$R$;23| |SYMBOL;name;2$;31| |SYMBOL;string;$S;24| (100 . |elt|) (106 . |=|) |SYMBOL;scripts;$R;32| (112 . |latex|) |SYMBOL;latex;$S;25| (117 . |minIndex|) (122 . |concat|) (128 . |elt|) (133 . |setelt|) |SYMBOL;new;$;27| (|Union| 6 (QUOTE "failed")) (139 . |search|) (145 . |setelt|) (152 . |maxIndex|) (157 . |position|) |SYMBOL;new;2$;28| (|List| |$$|) (163 . |keys|) (168 . |remove!|) (174 . |void|) |SYMBOL;resetNew;V;29| |SYMBOL;list;$L;34| (178 . |first|) (183 . |digit?|) (|UniversalSegment| 6) (188 . SEGMENT) (194 . |elt|) (|List| 112) (200 . |minIndex|) (|NonNegativeInteger|) (205 . |setelt|) (212 . |concat|) (218 . |rest|) (223 . |minIndex|) (228 . |#|) (233 . |first|) (239 . |setelt|) (246 . |rest|) (252 . |elt|) (CONS IDENTITY (FUNCALL (|dispatchFunction| |SYMBOL;sample;$;35|) |$|)) (|SingleInteger|))) (QUOTE #(|~=| 258 |superscript| 264 |subscript| 270 |string| 276 |scripts| 281 |scripted?| 286 |script| 291 |sample| 303 |resetNew| 307 |patternMatch| 311 |new| 325 |name| 334 |min| 339 |max| 345 |list| 351 |latex| 356 |hash| 361 |elt| 366 |convert| 372 |coerce| 392 |argscript| 402 |OMwrite| 408 |>=| 432 |>| 438 |=| 444 |<=| 450 |<| 456)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE (0 0 0 0 0 0 0 0 0 0 0))) (CONS (QUOTE #(|OrderedSet&| NIL NIL |SetCategory&| |BasicType&| NIL NIL NIL NIL NIL NIL)) (CONS (QUOTE #((|OrderedSet|) (|PatternMatchable| (|Float|)) (|PatternMatchable| 6) (|SetCategory|) (|BasicType|) (|ConvertibleTo| 67) (|ConvertibleTo| 61) (|ConvertibleTo| 23) (|OpenMath|) (|ConvertibleTo| 43) (|CoercibleTo| 50))) (|makeByteWordVec2| 123 (QUOTE (1 7 0 6 8 0 10 0 11 1 14 0 13 15 2 24 22 0 23 25 0 26 0 27 2 24 0 28 26 29 1 24 22 0 30 1 24 22 0 31 1 24 22 0 32 1 39 0 28 40 1 39 6 0 41 1 43 0 23 44 1 50 0 23 51 3 62 60 23 61 60 63 3 68 66 23 67 66 69 1 67 0 23 72 1 61 0 23 74 1 28 0 76 77 2 55 0 0 0 78 2 28 39 0 6 83 2 39 20 0 0 84 1 50 28 0 86 1 28 6 0 88 2 28 0 39 0 89 1 7 6 0 90 2 7 6 0 6 91 2 10 93 2 0 94 3 10 6 0 2 6 95 1 28 6 0 96 2 28 6 39 0 97 1 10 99 0 100 2 10 93 2 0 101 0 22 0 102 1 99 2 0 105 1 39 20 0 106 2 107 0 6 6 108 2 28 0 0 107 109 1 110 6 0 111 3 110 112 0 6 112 113 2 110 0 0 112 114 1 99 0 0 115 1 53 6 0 116 1 99 112 0 117 2 99 0 0 112 118 3 53 55 0 6 55 119 2 99 0 0 112 120 2 53 55 0 6 121 2 0 20 0 0 1 2 0 0 0 55 58 2 0 0 0 55 56 1 0 28 0 82 1 0 79 0 85 1 0 20 0 21 2 0 0 0 53 54 2 0 0 0 79 80 0 0 0 122 0 0 22 103 3 0 64 0 61 64 65 3 0 70 0 67 70 71 1 0 0 0 98 0 0 0 92 1 0 0 0 81 2 0 0 0 0 1 2 0 0 0 0 1 1 0 76 0 104 1 0 28 0 87 1 0 123 0 1 2 0 0 0 55 57 1 0 61 0 75 1 0 67 0 73 1 0 23 0 46 1 0 43 0 45 1 0 0 28 47 1 0 50 0 52 2 0 0 0 55 59 3 0 22 24 0 20 36 2 0 28 0 20 34 2 0 22 24 0 35 1 0 28 0 33 2 0 20 0 0 1 2 0 20 0 0 1 2 0 20 0 0 48 2 0 20 0 0 1 2 0 20 0 0 49)))))) (QUOTE |lookupComplete|))) 

(MAKEPROP (QUOTE |Symbol|) (QUOTE NILADIC) T) 
@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain SYMBOL Symbol>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
