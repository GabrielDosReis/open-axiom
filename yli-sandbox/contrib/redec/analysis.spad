
)abbrev package LPANL LoopAnalysis 
++ Author: Yue Li
++ Date Created: October 27, 2009
++ Date Last Updated: April 3, 2010
++ Description: This package provides library function for extracting 
++ accumulation loops, affine control loops and loop nests from a 
++ function definition syntax
LoopAnalysis(): Public == Private where
  macro ACC == List RepeatAst
  macro LTB == Table(Pair(Identifier, Identifier), ACC)
  macro VTB == Table(Syntax, Syntax)
  macro IFL == Record(lets: List LetAst, globalvars: List Syntax,_
                      conditions: List Syntax)
  Public == with
    extractAccumulationLoop: (DefinitionAst, Identifier, VTB) ->_
                              Pair(LTB, List List Syntax)
      ++ interface for main analysis function defined in redupkg.spad
    extractAffineControlLoop: (DefinitionAst, Identifier, VTB) -> LTB
      ++ interface for analysis function in redupkg.spad,
      ++ this function returns a list of repeatAst which 
      ++ is affine control loop nests of a function definition
    extractAllLoopNest: (DefinitionAst, Identifier, VTB) -> LTB
      ++ interface for analysis function in redupkg.spad,
      ++ this function collects all the loop nests, i.e., loop depth >= 2
    getLoopDepth: RepeatAst -> Integer
      ++ computes the depth of a loop nest
  Private == add
    import SyntaxHelper
    import Syntax

    -- forward declarations of local functions for bootstrap purpose    
    ifOnly?: RepeatAst -> Pair(Boolean, Pair(List LetAst, List LetAst))
      ++ checks whether the body of a single loop ast 
      ++ only contains a single if statement 
    identifyAccumulationLoopFromStatement: (SpadAst, VTB) -> ACC
      ++ collects accumulation loop from each statement
    globalVariableSubstitutions: List LetAst -> List LetAst
      ++ does all forward substitution for all 
      ++ global variables in the loop body
    identifyAffineControlLoopFromStatement: (SpadAst, VTB) -> ACC
      ++ collects all the ACLs from a statement
    isStaticControlLoop?: (RepeatAst, List Identifier,_
                           List Identifier, VTB) -> Boolean
      ++ checks whether a loop is an affine control loop
    verifyStaticControlLoopBody: (SpadAst, List Identifier,_
                                  List Identifier, VTB) -> Boolean
      ++ checks whether a statement satisfies the requirement of 
      ++ static control part
    expressionWithAffineReferenceOnly?:(Syntax, List Identifier, VTB) -> Boolean
      ++ verifies that all the index expressions used in some expression are 
      ++ affine expressions of loop counters

    --Global variables
    -- list for storing all the accumulation loops
    accumulationLoopTable: LTB := empty()

    -- list for storing all the extracted ACL nests
    aclTable: LTB := empty()
    
    -- list for storing all the extracted normal loop nests 
    loopNestTable: LTB := empty()

    -- name of the current function being analyzed
    functionName : Identifier := gensym()

    -- Type environment for global variables such as constructor parameter, 
    -- as well as global variables declared inside the capsule
    globalTypeEnvironment: VTB := empty()

    -- flags
    -- 0 : collect all the repeat ast
    -- 1 : collect qualified repeat ast (accumulation loop)
    -- 2 : collect all acl loop nests
    -- 3 : collect all the loop nests (depth >= 2)
    option: Integer := 0

    -- a set of build in comparison predicate 
    -- predicate used in the if-statement that is allowed in ACL
    -- can only uses predicate in this set
    buildInPredicateSet : List Identifier := [_<, _>, _=, _~_=, _<_=, _>_=] 

    -- a set of element access/set operator names
    buildInAccessFunctions : List Identifier := ['qsetelt!,'setelt,'elt,'qelt]

    -- list for storing all the reduction variables used 
    -- in some accumulation loop, i.e., a list contains 
    -- reduction variable lists obtained respectively from a if-statement's both
    -- branches 
    reductionVariableList : List List Syntax := []

    -- list for storing all the reduction variables used in accumulations 
    -- those accumulations appear in the then branch of some if-statement
    reductionVariableListInThenBranch: List Syntax := []

    -- list for storing all the reduction variables used in accumulations 
    -- those accumulations appear in the else branch of some if-statement
    reductionVariableListInElseBranch: List Syntax := []

    -- checks whether a sequence only contains let statements
    -- if so, also returns the list of let assignments
    letOnlySequence?(b: SequenceAst): Pair(Boolean, List LetAst) ==
      letList : List LetAst := []
      for s in body b repeat
        compound?(s::Syntax) => 
          s case LetAst => letList := cons(s::Syntax::LetAst, letList)
          s case ExitAst and_
          (x:=expression(s::Syntax::ExitAst)) case LetAst =>
            letList := cons(x::Syntax::LetAst, letList) 
          return pair(false, [])
        return pair(false, [])
      pair(true, letList)

    -- checks whether a syntax only contains let statement(s)
    letOnlyBody?(b: SpadAst): Pair(Boolean, List LetAst) ==
      not compound?(b::Syntax)  => pair(false, [])
      b case LetAst             => pair(true, [b::Syntax::LetAst])
      b case SequenceAst        => letOnlySequence?(b::Syntax::SequenceAst)
      pair(false, [])

    -- checks whether the body of a single loop ast only contains let statement
    letOnly?(r: RepeatAst): Pair(Boolean, List LetAst) == letOnlyBody?(body r)

    -- checks whether both branches of an if statement 
    -- contain only let statements
    letInBothBranches?(b: IfAst):_
                              Pair(Boolean, Pair(List LetAst, List LetAst)) ==
      resultOfThen : Pair(Boolean, List LetAst) := pair(false, [])
      resultOfElse : Pair(Boolean, List LetAst) := pair(false, [])
      if hasThenBranch?(b) then resultOfThen := letOnlyBody? thenBranch b
      if hasElseBranch?(b) then resultOfElse := letOnlyBody? elseBranch b
      hasThenBranch?(b) and hasElseBranch?(b) and_
      first(resultOfThen) and first(resultOfElse) => 
        pair(true, pair(second(resultOfThen),second(resultOfElse)))
      hasThenBranch?(b) and_
      not hasElseBranch?(b) and_
      first(resultOfThen) => pair(true, pair(second(resultOfThen), []))
      hasElseBranch?(b) and_
      not hasThenBranch?(b) and_
      first(resultOfElse) => pair(true, pair([], second(resultOfElse))) 
      pair(false, pair([], []))

    -- checks whether there's an if statement in a sequence of statements
    ifAstInSequence?(s: SequenceAst):_
                               Pair(Boolean, Pair(List LetAst, List LetAst)) ==
      (#(b := body s)) = 2 and_
      compound?((b.1)::Syntax) and_
      compound?((b.2)::Syntax) and_
      (b.1 case LetAst) and_
      (b.2 case ExitAst) and_
      (f := expression((b.2)::Syntax::ExitAst)) case IfAst => 
        x := getLhs((b.1)::Syntax::LetAst)$SyntaxHelper
        z := rhs((b.1)::Syntax::LetAst)::Syntax 
        y := (condition(f::Syntax::IfAst))::Syntax 
        x = y and first(letInBothBranches?(f::Syntax::IfAst)) =>
          result : IfAst := (replace(x, f::Syntax, z)$SyntaxHelper)::IfAst
          letInBothBranches?(result)
        pair(false, pair([], []))
      pair(false, pair([], []))

    -- checks whether the body of a loop only contains if-statement
    ifOnly? r ==
      b := body r
      not compound?(b::Syntax) => pair(false, pair([], []))
      b case IfAst             => letInBothBranches?(b::Syntax::IfAst)
      b case SequenceAst       => ifAstInSequence?(b::Syntax::SequenceAst)
      pair(false, pair([], []))

    -- initialize a table for storing the global variables
    -- of a function definition
    initVariableTable(t: VTB, l: List Identifier): VTB ==
      for p in l repeat
        p' := p::Syntax
        t.p'  := makeUnknown()
      t

    -- checks whether some variable is a local variable
    isLocalVariable?(s: Syntax, t: VTB): Boolean == key?(s, t)

    -- does forward substitutions for local variables.
    localVariableSubstitutions!(i: Integer, b: List LetAst,_
                                s: LetAst, var: Syntax): List LetAst ==
      for n in i..#b repeat
        b.n := replaceLetRhs(var, b.n, (rhs s)::Syntax)$SyntaxHelper      
      b

    -- removes uses of local intermediate value assignment after forward 
    -- substitutions of local variables
    removeLocalAssignments(b: List LetAst, toRemove: Set Integer):List LetAst ==
      reverse([b.n for n in 1..#b | not member?(n, toRemove)]@List LetAst)

    -- does forward substitution for local variables, and remove those
    -- uses of local variables as intermediate stores
    eliminateLocalVariable!(b: List LetAst, lv: VTB): List LetAst ==
      toRemove: Set Integer := {}
      current : Integer := 1
      -- local variable substitution
      for s in reverse b repeat
        next := #b-current+2
        if isLocalVariable?(var := getLhs(s)$SyntaxHelper, lv) and_
           (next <= #b) then
          b := localVariableSubstitutions!(next, b, s, var)
          -- mark the intermediate assignment which is ready to be removed
          toRemove := union(next-1, toRemove)
        current := current + 1
      -- remove intermediate assignments over local variable	
      removeLocalAssignments(b, toRemove)

    -- checks whether a variable being assigned in a let statement appears
    -- in the right hand side of the let statement
    lhsInRhs?(x: LetAst): Boolean ==
      l := getLhs(x)$SyntaxHelper
      x' := replaceLetRhs(l, x, makeUnknown())
      not(x::Syntax = x'::Syntax)

    -- global variable for storing the index of statement in a loop
    -- those statements are subjected to be removed after forward substitutions
    toDelete: Set Integer := {}

    -- check whether the index of some variable assignment has been 
    -- marked to be delted
    toBeRemoved?(label: Integer): Boolean ==
      member?(label, toDelete)

    -- checks whether a variable is qualified to be eliminated
    qualifiedForElimination?(b: List LetAst, var: Syntax): Boolean ==
      vars := [getLhs(b.i)$SyntaxHelper for i in 1..#b| not toBeRemoved?(i)]
      member?(var, vars)

    -- generate the simplified loop body
    updateLoopBody!(b: List LetAst, t: List LetAst, i: Integer): List LetAst ==
      for j in 1..#t repeat
        b.(i+j) := t.j
      b

    -- does forward subsitutions for only one global variable assignment
    globalVariableSubstitution(b: List LetAst, b': List LetAst,_
                  i: Integer, i': Integer, l: Syntax, r: Syntax): List LetAst==
      before := b'.i'
      b'.i' : LetAst := replaceLetRhs(l, b'.i', r)$SyntaxHelper
      if not ((before::Syntax) = ((b'.i')::Syntax)) then
        t := globalVariableSubstitutions(b')
        b := updateLoopBody!(b, t, i)
      b
      
    -- mark to remove the index of the statement that is an 
    -- intermediate assignment to some global variable 
    updateDeletionList!(c: Boolean, i: Integer): Void ==
      if c then toDelete := union(i, toDelete)

    -- does all forward substitution for all global variables in the loop body
    globalVariableSubstitutions(b: List LetAst): List LetAst ==
      for i in #b..1 by -1 | ((i <= #b-1) and not toBeRemoved?(i)) repeat
        -- if this assignment is not marked as to be removed, 
        -- continue the substitution for the next assignment
        b' := [b.n for n in (i+1)..#b]
        l := getLhs(b.i)$SyntaxHelper
        r := rhs(b.i)::Syntax
        qualified? := qualifiedForElimination?(b', l)
        for i' in 1..#b' | not toBeRemoved?(i') repeat
          if (not qualified?) and lhsInRhs?(b.i) then
            break
          b := globalVariableSubstitution(b, b', i, i', l, r)
          updateDeletionList!(qualified?, i)
      b

    -- remove those uses of global variables as intermediate stores
    -- this is done after forward substitution
    removeGlobalAssignments(b: List LetAst): List LetAst ==
      [qelt(b, n) for n in 1..#b | not member?(n, toDelete)]@List LetAst

    -- main function for doing forward substitution for the use of global 
    -- variables as intermediate store, and the doing simplification 
    -- after forward substitution
    eliminateGlobalVariable!(b: List LetAst): List LetAst ==
      toDelete := empty()
      b := globalVariableSubstitutions(b)
      removeGlobalAssignments(b)

    -- extracts all the free variables used in an expression
    -- those variables are stroed in a global type environment
    freeVariables(v: Syntax, gv: VTB): List Syntax ==
      result : List Syntax := []
      op := getOperator(v)
      if op case Identifier and key?(op::Identifier::Syntax, gv) then
        result := concat(result, op::Identifier::Syntax)
      for s in getOperands(v) repeat
        compound? s =>
          result := concat(result, freeVariables(s, gv))
        key?(s, gv) =>
          result := concat(result, s)
      result

    -- checks whether there's a variable syntax appeared in some expression
    advanceListWithin?(vars: List Syntax, i: SpadAst, gv: VTB): Boolean ==
      for v in vars repeat
        compound? v =>
          listWithin?(freeVariables(v, gv), i::Syntax)$SyntaxHelper => 
            return true
        within?(v, i::Syntax)$SyntaxHelper => return true
      false

    -- checks whether there's a variable syntax appeared in some expression
    advanceListWithin2?(vars: List Syntax, i: SpadAst, gv: VTB): Boolean ==
      for v in vars repeat
        x := v
        if compound? v and_
           (container := getOperator(v)) case Identifier and_
           key?((c := container::Identifier::Syntax), gv) then
          x := c
        within?(x, i::Syntax)$SyntaxHelper => return true
      false

    -- checks whether the loop iterator 
    withinIterators?(vars: List Syntax, its: List SpadAst, gv: VTB): Boolean ==
      for i in its repeat
        advanceListWithin?(vars, i, gv) => return true
      false

    -- returns the number and syntax of reduction variables used 
    -- on the right hand side of a let assignment
    searchForAccumulationVariable(v: Syntax,_
                                  exp: Syntax): Pair(Integer, List Syntax) ==
      result : List Syntax := []
      counter : Integer := 0
      v = exp =>
        counter := counter + 1
        pair(counter, result)
      compound? exp =>
        expLst := (unlist exp)$SyntaxHelper
        result := concat(result, expLst.1)
        for u in expLst repeat
          if first(r := searchForAccumulationVariable(v, u)) > 0 then
            counter := counter + (first r)
            result  := concat(result, second r)
        pair(counter, result)
      pair(counter, result)

    -- checks whether all the reduction operators are the same one.
    sameOperators?(opList: List Syntax): Boolean == 
      #removeDuplicates(opList) = 1

    -- checks the requirement of the canonical form on let statement:
    -- i.e., the same reduction operator is used for several times on only one
    -- accumulation variable. e.g. f(f(f(f(a, b)......)))   
    verifyCountAndOperator(v: Syntax, exp: Syntax): Boolean ==
      r := searchForAccumulationVariable(v, exp)
      (first r = 1) and sameOperators?(second r)

    -- checks whether the operator used in the right hand side of 
    -- of a let statement contains side-effect function.
    containExclamation?(r: Syntax): Boolean ==
      member?(char("!"::String)$Character, entries(toString(r)$SyntaxHelper)) 
      
    -- verify our new canonical form, pay attention to testing option
    verifyImprovedCanonicalForm(v: Syntax, r: Syntax, its: List SpadAst,_
                   vars: List Syntax, localcount: Integer, gv: VTB): Integer ==
      --if compound?(v) and 
      -- containExclamation?(r)  -- for examining the side effect functions.
      if not containExclamation?(r) and_
         isBinaryExpression?(r) and_
         not withinIterators?(vars, its, gv)_ 
         and verifyCountAndOperator(v, r) and_
         not advanceListWithin2?(remove(v, vars), r::SpadAst, gv) then
        localcount := localcount + 1
      localcount

    -- verify whether a let assignment is doing accumulation
    countEachReduction(s: LetAst, its: List SpadAst, vars: List Syntax,_
                                      localcount: Integer, gv: VTB): Integer ==
      l := getLhs(s)$SyntaxHelper
      r := rhs(s)::Syntax
      localcount := verifyImprovedCanonicalForm(l, r, its, vars, localcount, gv)

    -- examine the statement sequence after forward substitutions 
    -- are independent accumulations
    isReduction?(b: List LetAst, its: List SpadAst, gv: VTB): Boolean ==
      localcount : Integer := 0
      varsInLhs : List Syntax := [getLhs(s)$SyntaxHelper for s in b]
      for s in b repeat
        localcount := countEachReduction(s, its, varsInLhs, localcount, gv)
      localcount = #b =>
        -- pay attention to the order of updating
        if empty? reductionVariableListInThenBranch then
          reductionVariableListInThenBranch := copy varsInLhs
        else
          reductionVariableListInElseBranch := copy varsInLhs
        true
      false

    -- verify whether a sequence of statements only implements independent
    -- accumulations
    verifyReduction(its: List SpadAst, b: List LetAst,_
                                                 gv: VTB, lv: VTB): Boolean ==
      empty?(b) => true
      b := eliminateLocalVariable!(b, lv)
      b := eliminateGlobalVariable!(b)
      isReduction?(b, its, gv)

    -- collect the local variables from each assignment in the body of a loop
    collectLocalVariableofLoop(bl: List LetAst, gv: VTB): VTB ==
      lv : VTB := empty()
      for b in bl repeat
        k := getLhs(b)$SyntaxHelper
        if not key?(k, gv) then
          lv.k := r::Syntax
      lv

    -- collect the global variables from the loop induction variables
    collectLoopInductionVariable(iters: List SpadAst, gv: VTB): VTB ==
      -- currently, we don't handle while loop such as while(i < l) 
      for i in iters repeat
        -- e.g. (STEP i (minr x) 1 (maxr x))
        -- e.g. (IN i l)
        v := first(getOperands(i::Syntax))
        -- an approximation to the initial value of the induction variable
        -- may use more precise value, but I don't see the necessity.
        gv.v := makeUnknown()
      gv

    -- collect all the variables appeared in the predicate expression of 
    -- the condition of an if-statement
    collectVariableFromIfCondition(b: SpadAst, gv: VTB): VTB ==
      (b case IfAst) =>
        con := condition(b::Syntax::IfAst)
        compound?(con::Syntax) and con case LetAst =>
          v := getLhs(con::Syntax::LetAst)$SyntaxHelper
          gv.v := makeUnknown()
          gv
        gv
      gv

    -- checks whether the variables being assigned by a list of let statements
    -- appeared in the predicate expression of some loop
    withInCondition?(thenList: List LetAst,_
                     elseList: List LetAst, b: SpadAst): Boolean ==
      vars := [getLhs(s)$SyntaxHelper for s in concat(thenList, elseList)]
      not compound?(b::Syntax) => false
      b case IfAst => listWithin?(vars, condition(b::Syntax::IfAst)::Syntax)
      b case SequenceAst => 
        s := expression((second(body(_
                     b::Syntax::SequenceAst)))::Syntax::ExitAst)::Syntax::IfAst
        listWithin?(vars, condition(s)::Syntax)
      userError "unexpected body of the verified repeat-if syntax"

    -- checks whether statements in an atomic loop body implements only 
    -- independent accumulations
    verifyAtomicLoopBody(r: RepeatAst, p: Pair(Boolean, List LetAst),_
                                            its: List SpadAst, gv: VTB): ACC ==
      localVariables : VTB := collectLocalVariableofLoop(second p, gv)
      verifyReduction(its, second p, gv, localVariables) =>
        reductionVariableList := concat(reductionVariableList,_
                                        [reductionVariableListInThenBranch])
        [r]
      []

    -- verify whether the statements from each branch either
    -- form an accumulation loop or a sequence of accumulation statements
    -- this handles the accumulation loop whose body has if statement
    -- e.g. for i in 1..10 repeat
    --        even? i => x := x+i
    --        x := x + 1
    verifyLoopWithIfInside(r: RepeatAst, q: Pair(Boolean, Pair(List LetAst,_
                              List LetAst)), its: List SpadAst, gv: VTB): ACC==
      gv' : VTB := collectVariableFromIfCondition(body r, copy gv)
      thenList := first second q
      elseList := second second q
      lvThen  : VTB := collectLocalVariableofLoop(thenList, gv')
      lvElse  : VTB := collectLocalVariableofLoop(elseList, gv')
      verifyReduction(its, thenList, gv', lvThen) and_
      verifyReduction(its, elseList, gv', lvElse) and_
      not withInCondition?(thenList, elseList, body r) =>
        reductionVariableList := concat(reductionVariableList,_
          [concat(reductionVariableListInThenBranch,_
           reductionVariableListInElseBranch)])
        [r]
      []

    -- collect accumulation loop from repeat ast
    -- i.e. to verify whether a repeatAst has the canonical form
    identifyAccumulationLoopFromRepeat(r: RepeatAst, gv: VTB): ACC ==
      not empty?(its := iterators(r)) => 
        it := first its
        -- collect the global variables from the loop induction variables
        -- in the loop iterators
        gv := collectLoopInductionVariable(its, gv)
        -- if this is a while loop, the loop is not qualified, 
        -- and we further search its body
        it case WhileAst => 
          identifyAccumulationLoopFromStatement(body r, copy gv)
        -- if this is a for loop, and only contains let statement
        reductionVariableListInThenBranch := []
        reductionVariableListInElseBranch := []
        first(p := letOnly? r) => verifyAtomicLoopBody(r, p, its, gv)
        first(q := ifOnly? r)  => verifyLoopWithIfInside(r, q, its, gv)
        -- if this is a for loop whose body is a mix of many kinds of statement
        -- we recursively examine the body.
        identifyAccumulationLoopFromStatement(body r, copy gv)
      identifyAccumulationLoopFromStatement(body r, copy gv)

    -- checks whether a repeatAst is a for loop whose iterator
    -- is a step ast, e.g., for i in 1..10 by 2 repeat
    forLoopWithStep?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      empty? iters => false
      loopHead := (first(iters))::Syntax
      compound?(loopHead) and_
      (getOperator(loopHead)::Identifier) = ('STEP::Identifier) =>
        #getOperands(loopHead) = 4  -- to make sure we have both lower and upper bounds.
      false

    -- checks whether a repeat ast is a for loop whose iterator
    -- is a in ast, e.g., for e in l repeat
    forLoopWithInAst?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      empty? iters => false
      loopHead := first iters
      loopHead case InAst

    -- checks whether a repeat ast has a predicate in its 
    -- iterator
    stepForLoopWithCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithStep?(r) and #iters = 2 =>
        iters.2 case SuchThatAst => true
        false
      false

    -- verify that a repeat ast does not have a condition
    stepForLoopWithoutCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithStep?(r) and #iters = 1 

    -- checks that a repeat ast is a for loop, predicating on its loop counter
    inSequenceForLoopWithCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithInAst?(r) and #iters = 2 =>
        iters.2 case SuchThatAst => true
        false
      false

    -- checks that a repeat ast is a for loop, without predicating on its 
    -- condition
    inSequenceForLoopWithoutCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithInAst?(r) and #iters = 1

    -- finds loop counter of a for loop whose iterator is a step ast
    collectLoopCounterFromStep(r: SpadAst): List Identifier ==
      c := first getOperands(r::Syntax)
      c case Identifier => [c::Identifier]
      print(r::OutputForm)
      userError "unexpected loop counter syntax"

    -- collect all the variables appeared in the bound expressions
    -- of a for loop
    collectParametersInBoundFromStep(r: Syntax, gv: VTB): List Identifier ==    
      not compound? r =>
        r case Identifier and key?(r, gv) => [r]
        []
      res : List Identifier := []
      terms := getOperands(r)
      for t in terms repeat
        res := concat(res, collectParametersInBoundFromStep(t, gv))
      res

    -- collect parameters used in the sequence of the in ast of a loop
    -- these paraemeters will further become bound parameters, which is allowed
    -- to be used in an affine index expression
    collectParametersFromSequcneOfInAst(r: Syntax, gv: VTB): List Identifier ==
      collectParametersInBoundFromStep(r, gv)

    -- checks whether a statement wraps a loop inside
    containLoop?(s: SpadAst): Boolean ==
      not compound?(s::Syntax) => false
      s case CaseAst => containLoop?(rhs(s::Syntax::CaseAst))
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          containLoop?(b) => return true
        false  
      s case RepeatAst => true
      s case IfAst =>
        thBranch := thenBranch(s::Syntax::IfAst)
        elBranch := elseBranch(s::Syntax::IfAst)
        if compound?(thBranch::Syntax) then
          containLoop?(thBranch) => return true
        if compound?(elBranch::Syntax) then
          containLoop?(elBranch) => return true
        false
      s case ExitAst =>
        containLoop?(expression(s::Syntax::ExitAst))
      false

    -- compute the loop depth of the body of a loop
    getLoopDepthOfBody(s: SpadAst, depth: Integer): Integer ==
      not compound?(s::Syntax) => depth
      s case CaseAst => 
        getLoopDepthOfBody(rhs(s::Syntax::CaseAst), depth)
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        maxDepth := depth
        for b in bs repeat
          currentDepth := getLoopDepthOfBody(b, depth)
          if currentDepth > maxDepth then
            maxDepth := currentDepth
        maxDepth  
      s case RepeatAst => 
        getLoopDepthOfBody(body(s::Syntax::RepeatAst), inc(depth)) 
      s case IfAst =>
        depthThen : Integer := 0
        depthElse : Integer := 0
        s' := s::Syntax::IfAst
        if hasThenBranch? s' then
          thBranch := thenBranch s'
          depthThen := getLoopDepthOfBody(thBranch, depth)
        if hasElseBranch? s' then
          elBranch := elseBranch s'
          depthElse := getLoopDepthOfBody(elBranch, depth) 
        max(depthElse, depthThen)
      s case ExitAst =>
        getLoopDepthOfBody(expression(s::Syntax::ExitAst), depth)
      depth

    -- computes the depth of a loop
    getLoopDepth(s: RepeatAst): Integer ==
      depth : Integer := 1
      getLoopDepthOfBody(body s, depth)

    -- obtain all the let statement appeared in some statement
    getAllAssignmentFromSyntax(s: SpadAst): List Syntax ==
      not compound?(s::Syntax) => []
      result : List Syntax := []
      s case LetAst => [s::Syntax]
      s case ReturnAst => 
        getAllAssignmentFromSyntax(expression(s::Syntax::ReturnAst))
      s case CaseAst => 
        getAllAssignmentFromSyntax(rhs(s::Syntax::CaseAst))
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          result := concat(result, getAllAssignmentFromSyntax(b))
        result
      s case RepeatAst =>
        getAllAssignmentFromSyntax(body(s::Syntax::RepeatAst))
      s case IfAst =>
        s' := s::Syntax::IfAst
        if hasThenBranch? s' then
          thBranch := thenBranch(s')
          result := concat(result, getAllAssignmentFromSyntax(thBranch))
        if hasElseBranch? s' then
          elBranch := elseBranch(s')
          result := concat(result, getAllAssignmentFromSyntax(elBranch))
        result
      s case ExitAst =>
        getAllAssignmentFromSyntax(expression(s::Syntax::ExitAst))
      result

    -- obtain all the variables being assigned in a list of let statements
    getAllIdentifiersFromAssignments(assignments: List Syntax): List Identifier ==
      res : List Identifier := []
      for a in assignments repeat
        lhs := getLhs(a::SpadAst::LetAst)$SyntaxHelper
        lhs case Identifier => res := concat(res, lhs::Identifier)
      removeDuplicates(res)

    -- checks whether each variable in the list varList is not modified in the 
    -- body of the loop r
    checkInvariance(varList: List Identifier, r: RepeatAst): Boolean ==
      assignmentsInLoop := getAllAssignmentFromSyntax(r::Syntax::SpadAst)
      identifiersBeingAssigned :=_ 
        getAllIdentifiersFromAssignments assignmentsInLoop
      for v in varList repeat
        member?(v, identifiersBeingAssigned) => return false
      true

    -- checks whether an expression is an access form, e.g. a.i
    isAccessForm?(e: Syntax, gv: VTB): Boolean ==
      (op := getOperator(e)) case Identifier and_
      key?(op::Identifier::Syntax, gv)

    -- check whether some operator is an element access/set operator
    -- e.g., elt(a, i), qsetelt!(a, i, b.j)
    isAccessFunction?(e: Syntax): Boolean ==
      (op := getOperator(e)) case Identifier =>
        op' := op::Identifier
        member?(op', buildInAccessFunctions)
      false

    -- verify a subexpression of an index expression 
    -- is an affine expressions of loop counters and symbolic constants
    verifyItemInExpression(l: Syntax, r: Syntax,_
                           loopCounters: List Identifier, gv: VTB): Boolean ==
      not compound?(l) and not compound?(r) =>
        l case Integer and r case Identifier =>
          r' := r::Identifier
          member?(r', loopCounters) or key?(r, gv)
        l case Identifier and r case Integer =>
          l' := l::Identifier
          member?(l', loopCounters) or key?(l, gv)
        false
      false

    -- verify an index expression is an affine expressions of loop counters
    -- and symbolic constants
    verifyIndexExpression(e: Syntax,_
                          loopCounters: List Identifier, gv: VTB): Boolean ==
      not compound?(e) => true
      (op := getOperator(e)) case Identifier =>
        op' := op::Identifier
        op' = '_+::Identifier or op' = '_-::Identifier => 
          for x in getOperands(e) repeat
            not verifyIndexExpression(x, loopCounters, gv) => return false
          true
        op' = '_*::Identifier and #getOperands(e)=2 =>
          l := getOperands(e).1
          r := getOperands(e).2
          verifyItemInExpression(l, r, loopCounters, gv)
        false
      false

    -- verify two dimenstional setelt functions, qsetelt!, setelt
    -- so that all index expressions are affine expressions of loop counters
    -- and symbolic constants
    verifyTwoDimensionSet(operands: List Syntax,_
                          loopCounters: List Identifier, gv: VTB): Boolean ==
      index1 := operands.2
      index2 := operands.3
      c := operands.4
      verifyIndexExpression(index1, loopCounters, gv) and_
      verifyIndexExpression(index2, loopCounters, gv) and_
      expressionWithAffineReferenceOnly?(c, loopCounters, gv)

    -- verify one dimenstional setelt functions, qsetelt!, setelt 
    -- so that all index expressions are affine expressions of loop counters
    -- and symbolic constants
    verifyOneDimensionSet(operands: List Syntax,_
                          loopCounters: List Identifier, gv: VTB): Boolean ==
      index := operands.2
      c := operands.3
      verifyIndexExpression(index, loopCounters, gv) and_
      expressionWithAffineReferenceOnly?(c, loopCounters, gv)

    -- verify two dimenstional element query functions, query, elt
    -- so that all index expressions are affine expressions of loop counters
    -- and symbolic constants
    verifyTwoDimensionElt(operands: List Syntax,_
                          loopCounters: List Identifier, gv: VTB): Boolean ==
      index1 := operands.2
      index2 := operands.3
      verifyIndexExpression(index1, loopCounters, gv) and_
      verifyIndexExpression(index2, loopCounters, gv)

    -- verify one dimenstional element query functions: query, elt
    -- so that all index expressions are affine expressions of loop counters
    -- and symbolic constants
    verifyOneDimensionElt(operands: List Syntax,_
                          loopCounters: List Identifier, gv: VTB): Boolean ==
      index := operands.2
      verifyIndexExpression(index, loopCounters, gv)

    -- verifies that index expressions used in built-in access functions 
    -- are affine expressions of loop counters and symbolic constants
    verifyAccessFunctionParameters(e: Syntax,_
                            loopCounters: List Identifier, gv: VTB): Boolean ==
      op := getOperator(e)::Identifier
      opr := getOperands(e)
      (op = 'qsetelt!) or (op = 'setelt) => 
        #opr = 4 => verifyTwoDimensionSet(opr, loopCounters, gv)
        #opr = 3 => verifyOneDimensionSet(opr, loopCounters, gv)
        false
      (op = 'elt) or(op = 'qelt) => 
        #opr = 3 => verifyTwoDimensionElt(opr, loopCounters, gv)
        #opr = 2 => verifyOneDimensionElt(opr, loopCounters, gv)
      print(e::OutputForm)
      userError "unexpected kind of access library function"

    -- checks whether an expression is an annotated function application
    isAnnotated?(e: Syntax):Boolean ==
      (op := getOperator(e)) case Syntax =>
        (op' := getOperator(op::Syntax)) case Identifier and_
        op'::Identifier = 'elt and #getOperands(op::Syntax) = 2 
      false

    -- verifies that all the index expressions used in some annotated 
    -- function call are affine expressions of loop counters and symbolic
    -- constants
    annotatedExpressionWithAffineReferenceOnly?(e: Syntax,_
                            loopCounters: List Identifier, gv: VTB): Boolean ==
      op := getOperands(getOperator(e)::Syntax).last
      oprs := getOperands(e)
      exp := buildSyntax(op, oprs)
      expressionWithAffineReferenceOnly?(exp, loopCounters, gv)

    -- verifies that all the index expressions used in some expression are 
    -- affine expressions of loop counters and symbolic constants
    expressionWithAffineReferenceOnly?(e: Syntax,_
                            loopCounters: List Identifier, gv: VTB): Boolean ==
      not compound? e => true
      isAnnotated?(e) => annotatedExpressionWithAffineReferenceOnly?(e, loopCounters, gv)
      isAccessForm?(e, gv) => verifyIndexExpression(first getOperands(e), loopCounters, gv)
      isAccessFunction?(e) => verifyAccessFunctionParameters(e, loopCounters, gv)
      for s in unlist(e)$SyntaxHelper repeat
        not expressionWithAffineReferenceOnly?(s, loopCounters, gv) => return false
      true

    -- checks that the index expression of an array reference
    -- is an affine expression of loop counters and symbolic constants
    verifyArrayReference(a: LetAst,_
                            loopCounters: List Identifier, gv: VTB): Boolean ==
      l := getLhs(a)$SyntaxHelper
      r := rhs(a)::Syntax
      b := expressionWithAffineReferenceOnly?(l, loopCounters, gv) and_
      expressionWithAffineReferenceOnly?(r, loopCounters, gv)
      b

    -- verify the expression in the predicate of an if-statement
    -- is an affine expression of loop counters and symbolic constants
    verifyPredicateExpression(a: IfAst,_
                            loopCounters: List Identifier, gv: VTB): Boolean ==
      predicate := condition(a)::Syntax
      not compound?(predicate) => true
      (op := getOperator(predicate)) case Identifier => 
        op' := op::Identifier
        member?(op', buildInPredicateSet) =>
          for opr in getOperands(predicate) repeat
            not expressionWithAffineReferenceOnly?(opr,_
                                              loopCounters, gv) => return false
          true
        expressionWithAffineReferenceOnly?(predicate, loopCounters, gv)
      false

    -- verify whether an if-statement is a static control struct
    -- i.e., the expression in its predicate is an affine expression 
    -- and symbolic constant, also both of its branches are static control parts
    isStaticControlIfStatement?(s: IfAst, loopCounters: List Identifier,_
                         boundParameters: List Identifier, gv: VTB): Boolean ==
      verifyPredicateExpression(s, loopCounters, gv) =>
        thBranch := thenBranch(s)
        elBranch := elseBranch(s)
        if hasThenBranch?(s)$SyntaxHelper then
          not verifyStaticControlLoopBody(thBranch,_
                                     loopCounters, boundParameters, copy gv) =>
            return false
        if hasElseBranch?(s)$SyntaxHelper then
          not verifyStaticControlLoopBody(elBranch,_
                                     loopCounters, boundParameters, copy gv) =>
            return false
        true
      false

    -- verify the body of a loop follows the definition of static control loop
    verifyStaticControlLoopBody(s: SpadAst, loopCounters: List Identifier,_
                         boundParameters: List Identifier, gv: VTB): Boolean ==      
      not compound?(s::Syntax) => true
      s case LetAst => 
        k := getLhs(s)$SyntaxHelper
        gv.k := rhs(s::Syntax::LetAst)::Syntax
        not empty?(loopCounters) =>
          verifyArrayReference(s::Syntax::LetAst, loopCounters, gv)
        true
      s case ColonAst =>
        s' := s::Syntax::ColonAst 
        k := lhs(s')::Syntax
        gv.k := rhs(s')::Syntax
        true
      s case ConstructAst => true
      s case CollectAst => true
      s case ReturnAst => true
      s case CaseAst => false
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          not verifyStaticControlLoopBody(b, loopCounters,_
                                          boundParameters, copy gv) => 
            return false
        true
      s case RepeatAst => 
        isStaticControlLoop?(s::Syntax::RepeatAst, copy loopCounters,_
                             copy boundParameters, copy gv) 
      s case IfAst => 
        isStaticControlIfStatement?(s::Syntax::IfAst, loopCounters,_
                                    boundParameters, copy gv)
      s case ExitAst =>
        e := expression(s::Syntax::ExitAst)
        verifyStaticControlLoopBody(e, loopCounters, boundParameters, gv)
      expressionWithAffineReferenceOnly?(s::Syntax, loopCounters, gv)

    -- checks whether a for loop whose iterator is a step ast is a 
    -- static control loop
    stepForLoopIsSCL?(r: RepeatAst, loopCounters: List Identifier,_
                      boundParameters: List Identifier, gv: VTB): Boolean ==
      iter := first iterators(r)    
      iter' := iter::Syntax
      loopCounters := concat(loopCounters, collectLoopCounterFromStep iter)
      boundParameters := concat(boundParameters,_
                                collectParametersInBoundFromStep(iter', gv))
      not checkInvariance(concat(loopCounters, boundParameters), r) => false
      verifyStaticControlLoopBody(body r, loopCounters, boundParameters, gv)

    -- checks whether a for loop whose iterator is an in ast is a 
    -- static control loop
    inAstForLoopIsSCL?(r: RepeatAst, loopCounters: List Identifier,_
                       boundParameters: List Identifier, gv: VTB): Boolean ==
      iter := (first iterators(r))::Syntax::InAst
      seq := sequence(iter)::Syntax
      boundParameters := concat(boundParameters,_
                                collectParametersFromSequcneOfInAst(seq, gv))
      not checkInvariance(concat(loopCounters, boundParameters), r) => false
      verifyStaticControlLoopBody(body r, loopCounters, boundParameters, gv)

    -- checks whether a loop is a static control loop    
    isStaticControlLoop?(r: RepeatAst, loopCounters: List Identifier,_
                         boundParameters: List Identifier, gv: VTB): Boolean ==
      -- a static control loop must be a for loop
      forLoopWithStep?(r)  => 
        stepForLoopIsSCL?(r, loopCounters, boundParameters, gv)
      forLoopWithInAst?(r) => 
        inAstForLoopIsSCL?(r, loopCounters, boundParameters, gv)
      false

    -- extract the loop counter of a repeatAst, and update the environment
    -- meaning that the loop counter can be viewed as global variable of the loop
    updateGlobalVariableTableWithLoopCounter(s: RepeatAst, gv: VTB): VTB ==
      gv' := copy gv
      iters := iterators(s)
      #iters = 0 => gv'
      iter := first iters
      iter' := iter::Syntax
      ((op := getOperator(iter')) case Identifier) and_ 
      ((op::Identifier = 'IN) or (op::Identifier = 'STEP)) =>
        loopCounter := first(getOperands(iter'))
        gv'.loopCounter := makeUnknown()
        gv'
      gv'

    -- collect accumulation loop from an sequence
    identifyAccumulationLoopFromSequence(s: SpadAst, gv: VTB): ACC ==
      result : ACC := []
      bs := body(s::Syntax::SequenceAst)
      for b in bs repeat
        result := concat(result, identifyAccumulationLoopFromStatement(b, gv))
      result

    -- collect accumulation loop from a if statement
    identifyAccumulationLoopFromIf(s: SpadAst, gv: VTB): ACC ==
      result : ACC := []
      thBranch := thenBranch(s::Syntax::IfAst)
      elBranch := elseBranch(s::Syntax::IfAst)
      if compound?(thBranch::Syntax) then
        result := concat(result,_
                      identifyAccumulationLoopFromStatement(thBranch, copy gv))
      if compound?(elBranch::Syntax) then
        result := concat(result,_
                      identifyAccumulationLoopFromStatement(elBranch, copy gv))
      result

    -- collect accumulation loop from an exit statement
    identifyAccumulationLoopFromExit(s: SpadAst, gv: VTB): ACC ==
      e := expression(s::Syntax::ExitAst)
      identifyAccumulationLoopFromStatement(e, copy gv)

    -- Traverse each statement in a definition body,
    -- collecting accumulation loop from each statement
    identifyAccumulationLoopFromStatement(s: SpadAst, gv: VTB): ACC ==
      not compound?(s::Syntax) => []
      s case LetAst => 
        k := getLhs(s)$SyntaxHelper
        gv.k := rhs(s::Syntax::LetAst)::Syntax
        []
      s case ColonAst => 
        k := lhs(s::Syntax::ColonAst)::Syntax
        gv.k := makeUnknown()
        []
      s case CaseAst => 
        identifyAccumulationLoopFromStatement(rhs(s::Syntax::CaseAst), copy gv)
      s case SequenceAst => 
        identifyAccumulationLoopFromSequence(s, copy gv)
      s case RepeatAst => 
        identifyAccumulationLoopFromRepeat(s::Syntax::RepeatAst, copy gv)
      s case IfAst => 
        identifyAccumulationLoopFromIf(s, copy gv)
      s case ExitAst =>
        identifyAccumulationLoopFromExit(s, copy gv)
      []

    -- collect affine control loop from a sequence statement
    identifyAffineControlLoopFromSequence(s: SpadAst, gv: VTB): ACC ==
      result : ACC := []
      bs := body(s::Syntax::SequenceAst)
      for b in bs repeat
        result := concat(result, identifyAffineControlLoopFromStatement(b, copy gv))
      result

    -- verify affine control loop nest condition
    -- i.e., the loop is a static control loop
    -- and the loop should contain at least another single loop
    isAffineControlLoop?(s: RepeatAst, gv: VTB): Boolean ==
      isStaticControlLoop?(s, [], [], copy gv)_
      and containLoop?(body s)

    -- collect affine control loop from a repeat ast
    identifyAffineControlLoopFromRepeat(s: SpadAst, gv: VTB): ACC ==
      s' := s::Syntax::RepeatAst
      option = 3 =>
        getLoopDepth(s') > 1 => [s']
        []
      -- an ACL should contain at lesat one single loop in its body
      isAffineControlLoop?(s', gv) => [s']
      -- otherwise, we continue to examine its body
      gv' := updateGlobalVariableTableWithLoopCounter(s', copy gv)
      identifyAffineControlLoopFromStatement(body s', gv')

    -- collect affine control loop from if statement
    identifyAffineControlLoopFromIf(s: SpadAst, gv: VTB): ACC ==
      result : ACC := []
      thBranch := thenBranch(s::Syntax::IfAst)
      elBranch := elseBranch(s::Syntax::IfAst)
      if compound?(thBranch::Syntax) then
        result := concat(result,_
                  identifyAffineControlLoopFromStatement(thBranch, copy gv))
      if compound?(elBranch::Syntax) then
        result := concat(result,_
                  identifyAffineControlLoopFromStatement(elBranch, copy gv))
      result

    -- collect affine control loop from exit statement
    identifyAffineControlLoopFromExit(s: SpadAst, gv: VTB): ACC ==
      e := expression(s::Syntax::ExitAst)
      identifyAffineControlLoopFromStatement(e, copy gv)

    -- Traverse each statement in a definition body,
    -- collecting affine control loop from each statement
    identifyAffineControlLoopFromStatement(s: SpadAst, gv: VTB): ACC ==
      not compound?(s::Syntax) => []
      s case LetAst => 
        k := getLhs(s)$SyntaxHelper
        gv.k := rhs(s::Syntax::LetAst)::Syntax
        []
      s case ColonAst => 
        k := lhs(s::Syntax::ColonAst)::Syntax
        gv.k := makeUnknown()
        []
      s case CaseAst => 
        identifyAffineControlLoopFromStatement(rhs(s::Syntax::CaseAst), copy gv)
      s case SequenceAst => 
        identifyAffineControlLoopFromSequence(s, copy gv)
      s case RepeatAst => 
        identifyAffineControlLoopFromRepeat(s, copy gv)
      s case IfAst => 
        identifyAffineControlLoopFromIf(s, copy gv)
      s case ExitAst =>
        identifyAffineControlLoopFromExit(s, copy gv)
      []

    -- initialize the global variable table
    cleanUp(): Void ==
      accumulationLoopTable := empty()
      aclTable := empty()
      loopNestTable := empty()
      reductionVariableList := []

    --  update the final results to be returned 
    -- with a new entry: (pair(d, f), bl)
    updateTable(d: Identifier, f: Identifier, b: RepeatAst, t: LTB): Void ==
      k : Pair(Identifier, Identifier) := pair(d, f)
      key?(k, t) =>
        t.k := cons(b, t.k)
      t.k := [b]

    -- update the final results to be returned 
    -- with a new entry: (pair(d, f), bl)
    updateTable2(d: Identifier, f: Identifier, bl: List RepeatAst, t: LTB): LTB ==
      for b in bl repeat updateTable(d, f, b, t)
      t

    -- fill a variable table with the content stored in the global typing table
    initLocTypeEnvWithGlobalTypeEnv(v: VTB, g: VTB): VTB ==
      for k in keys(g) repeat v.k := g.k
      v

    -- creates a type environment for a function definition
    -- initializing it with global type information, as well as the parameter
    -- type information of the function definition itself
    initializeLocalTypeEnvironment(d: DefinitionAst): VTB ==
      typeEnvironment : VTB := empty()
      parameterList : List Identifier := parameters(head(d)::Syntax::HeadAst)
      typeEnvironment := initVariableTable(typeEnvironment, parameterList)
      typeEnvironment := initLocTypeEnvWithGlobalTypeEnv(typeEnvironment,_
                                                         globalTypeEnvironment)
      typeEnvironment   

    -- collects all the accumulation loops (single loop) from a definition body
    identifyAccumulationLoopFromDefinitionBody(d: DefinitionAst):_
                                                     Pair(Identifier, ACC) == 
      typeEnvironment : VTB := initializeLocalTypeEnvironment d
      functionName := name(head(d)::Syntax::HeadAst)
      -- start analysis
      pair(functionName,_
           identifyAccumulationLoopFromStatement(body d, typeEnvironment))

    -- collects all the affine control loops from a definition body, or, 
    -- collects all the normal loop nests from a definition body
    identifyAffineControlLoopFromDefinitionBody(d: DefinitionAst):_
                                                       Pair(Identifier, ACC) ==
      typeEnvironment : VTB := initializeLocalTypeEnvironment d
      functionName : Identifier := name(head(d)::Syntax::HeadAst)
      -- start analysis
      pair(functionName, identifyAffineControlLoopFromStatement(body d, typeEnvironment))

    -- collect data that is accumulation loop from function definition
    collectAccumulationLoopFromDefinition(sa: SpadAst, ctor: Identifier):Void ==
      -- extract accumulation loop
      analysisResult := identifyAccumulationLoopFromDefinitionBody_
                                                    (sa::Syntax::DefinitionAst)
      functionName := first analysisResult
      accumulationLoops := second analysisResult
      updateTable2(ctor, functionName, accumulationLoops, accumulationLoopTable)   

    -- collect data that is ACL or normal loop nests from function definition
    collectAclOrLoopNestsFromDefinition(sa: SpadAst, ctor: Identifier): Void == 
      -- extract affine control loop or normal loop
      analysisResult := identifyAffineControlLoopFromDefinitionBody_
                                                     (sa::Syntax::DefinitionAst)
      -- update the result table
      functionName   := first analysisResult
      extractedLoops := second analysisResult
      option = 2 => updateTable2(ctor, functionName,_
                                 extractedLoops, aclTable)
      option = 3 => updateTable2(ctor, functionName,_
                                 extractedLoops, loopNestTable)   

    -- collect data from  for top level statements (definitions)
    collectDataFromDefinition(sa: SpadAst, ctor: Identifier): Void ==
      (option = 1) => 
        collectAccumulationLoopFromDefinition(sa, ctor)
      (option = 2) or (option = 3) => 
        collectAclOrLoopNestsFromDefinition(sa, ctor)
      userError "loop analysis option be either 1, 2, or 3"

    -- interface used in redupkg.spad
    -- this function collects accumulation loops from a function definition
    extractAccumulationLoop(defa: DefinitionAst,_
                  ctor: Identifier, tpenv: VTB): Pair(LTB, List List Syntax) ==
      cleanUp()
      option := 1
      globalTypeEnvironment    := copy tpenv
      collectDataFromDefinition(defa::Syntax::SpadAst, ctor)
      pair(copy accumulationLoopTable, copy reductionVariableList)

    -- interface used in redupkg.spad
    -- this function collects ACLs from a function definition
    extractAffineControlLoop(defa: DefinitionAst,_
                             ctor: Identifier, tpenv: VTB): LTB ==
      cleanUp()
      option := 2
      globalTypeEnvironment    := copy tpenv
      collectDataFromDefinition(defa::Syntax::SpadAst, ctor)
      copy aclTable

    -- interface used in redupkg.spad
    -- this function collects normal loop nests from a function definition
    extractAllLoopNest(defa: DefinitionAst,_
                       ctor: Identifier, tpenv: VTB): LTB ==
      cleanUp()
      option := 3
      globalTypeEnvironment    := copy tpenv
      collectDataFromDefinition(defa::Syntax::SpadAst, ctor)
      copy loopNestTable








