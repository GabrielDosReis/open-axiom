
)abbrev package LPANL LoopAnalysis 
++ Author: Yue Li
++ Date Created: October 27, 2009
++ Date Last Updated: April 1, 2010
++ Description: This package provides library function for extracting 
++ accumulation loops, affine control loops and loop nests from a 
++ function definition body
LoopAnalysis(): Public == Private where
  macro ACC == List RepeatAst
  macro LTB == Table(Pair(Identifier, Identifier), ACC)
  macro VTB == Table(Syntax, Syntax)
  macro IFL == Record(lets: List LetAst, globalvars: List Syntax,_
                      conditions: List Syntax)
  Public == with
    extractReductionPatternFromFunctionDefinition: (DefinitionAst, Identifier, VTB) -> Pair(LTB, List List Syntax)
      ++ interface to main analysis function defined in redupkg.spad
    extractAffineControlLoopFromFunctionDefinition: (DefinitionAst, Identifier, VTB) -> LTB
      ++ interface to analysis function in redupkg.spad,
      ++ this function returns a list of repeatAst which is affine control loop nests of a function definition
    extractAllLoopNests: (DefinitionAst, Identifier, VTB) -> LTB
      ++ interface to analysis function in redupkg.spad,
      ++ this function collects all the loop nests, i.e., loop depth >= 2
    getLoopDepth: RepeatAst -> Integer
      ++ computes the depth of a loop nest
  Private == add
    import SpadParser
    import SyntaxHelper
    import Syntax

    -- forward declarations of local functions, for bootstrap purpose
    letOnly?: RepeatAst -> Pair(Boolean, List LetAst)
      ++ checks whether the body of a single loop ast only contains let statement
    ifOnly?: RepeatAst -> Pair(Boolean, Pair(List LetAst, List LetAst))
      ++ checks whether the body of a single loop ast only contains one if statement 
    identifyAccumulationLoop3: (RepeatAst, VTB) -> ACC
    identifyAccumulationLoop2: (SpadAst, VTB) -> ACC 
    identifyAccumulationLoop: DefinitionAst -> ACC
      ++ identifies all the accumulation loops in a function definition
    identifyAccumulationLoop0: DefinitionAst -> Pair(Identifier, ACC)
      ++ identifies all the accumulation loops in a function definition
      ++ this function is called by the library analysis function.
    identifyAffineControlLoop0: DefinitionAst -> Pair(Identifier, ACC)
    searchForAccumulationVariable: (Syntax, Syntax) -> Pair(Integer, List Syntax)

    -- flags
    -- 0 : collect all the repeat ast
    -- 1 : collect qualified repeat ast (accumulation loop)
    -- 2 : collect all acl loop nests
    -- 3 : collect all the loop nests (depth >= 2)
    option: Integer := 0

    vt : VTB := empty()  

    buildInPredicateSet : List Identifier := [_<, _>, _=, _~_=, _<_=, _>_=] 

    collectAffineControlLoop? : Boolean := false

    reductionVariableList : List List Syntax := []

    reductionVariableListInThenBranch: List Syntax := []

    reductionVariableListInElseBranch: List Syntax := []

    collectAccumulationFromStatement: (SpadAst, Identifier) -> Integer

    collectAccumulationFromDefinition: (DefinitionAst, Identifier) -> Integer

    unknownSyn: Syntax == '_?::Identifier::Syntax

    letOnlySequence?(b: SequenceAst): Pair(Boolean, List LetAst) ==
      letList : List LetAst := []
      for b' in body b repeat
        if compound?(b'::Syntax) and b' case LetAst then
          letList := cons(b'::Syntax::LetAst, letList)
        else if compound?(b'::Syntax) and (b' case ExitAst) and ((z:=expression(b'::Syntax::ExitAst)) case LetAst) then
          letList := cons(z::Syntax::LetAst, letList)
        else
          return pair(false, [])   
      pair(true, letList)

    singleLetInBody(b: LetAst): Pair(Boolean, List LetAst) == pair(true, [b])

    letOnlyBody?(b: SpadAst): Pair(Boolean, List LetAst) ==
      not compound?(b::Syntax)  => pair(false, [])
      b case LetAst             => singleLetInBody(b::Syntax::LetAst)
      b case SequenceAst        => letOnlySequence?(b::Syntax::SequenceAst)
      pair(false, [])

    letOnly? r == letOnlyBody? body r

    hasElseBranch?(f: IfAst): Boolean == 
      elsebranch := elseBranch(f)::Syntax
      not compound? elsebranch => not(elsebranch = '%noBranch::Identifier::Syntax)

    hasThenBranch?(f: IfAst): Boolean == 
      thenbranch := thenBranch(f)::Syntax
      not compound? thenbranch => not(thenbranch = '%noBranch::Identifier::Syntax)
      true

    letInBothBranches?(b: IfAst): Pair(Boolean, Pair(List LetAst, List LetAst)) ==
      resultOfThen : Pair(Boolean, List LetAst) := pair(false, [])
      resultOfElse : Pair(Boolean, List LetAst) := pair(false, [])
      if hasThenBranch?(b) then 
        resultOfThen := letOnlyBody? thenBranch b
      if hasElseBranch?(b) then resultOfElse := letOnlyBody? elseBranch b
      hasThenBranch?(b) and hasElseBranch?(b) and_
      first(resultOfThen) and first(resultOfElse) => pair(true, pair(second(resultOfThen),second(resultOfElse)))
      hasThenBranch?(b) and not hasElseBranch?(b) and first(resultOfThen) => pair(true, pair(second(resultOfThen), []))
      hasElseBranch?(b) and not hasThenBranch?(b) and first(resultOfElse) => pair(true, pair([], second(resultOfElse))) 
      pair(false, pair([], []))

    ifAstInSequence?(s: SequenceAst): Pair(Boolean, Pair(List LetAst, List LetAst)) ==
      (#(b := body s)) = 2 and compound?((b.1)::Syntax) and compound?((b.2)::Syntax)_
       and (b.1 case LetAst) and (b.2 case ExitAst) and (f := expression((b.2)::Syntax::ExitAst)) case IfAst => 
        x := getLhs((b.1)::Syntax::LetAst)$SyntaxHelper
        z := rhs((b.1)::Syntax::LetAst)::Syntax 
        y := (condition(f::Syntax::IfAst))::Syntax 
        x = y and first(letInBothBranches?(f::Syntax::IfAst)) =>
          result : IfAst := (replace(x, f::Syntax, z)$SyntaxHelper)::IfAst
          letInBothBranches?(result)
        pair(false, pair([], []))
      pair(false, pair([], []))

    ifOnly? r ==
      b := body r
      not compound?(b::Syntax) => pair(false, pair([], []))
      b case IfAst             => letInBothBranches?(b::Syntax::IfAst)
      b case SequenceAst       => ifAstInSequence?(b::Syntax::SequenceAst)
      pair(false, pair([], []))


    initVariableTable(t: VTB, l: List Identifier): VTB ==
      for p in l repeat
        p' := p::Syntax
        t.p'  := unknownSyn()
      t

    isLocalVariable?(s: Syntax, t: VTB): Boolean == key?(s, t)

    localVariableSubstitutions!(i: Integer, b: List LetAst, s: LetAst, var: Syntax): List LetAst ==
      for n in i..#b repeat
        b.n := replaceLetRhs(var, b.n, (rhs s)::Syntax)$SyntaxHelper      
      b

    removeLocalAssignments(b: List LetAst, toRemove: Set Integer): List LetAst ==
      reverse([b.n for n in 1..#b | not member?(n, toRemove)]@List LetAst)

    eliminateLocalVariable!(b: List LetAst, lv: VTB): List LetAst ==
      toRemove: Set Integer := {}
      current : Integer := 1
      -- local variable substitution
      for s in reverse b repeat
        next := #b-current+2
        if isLocalVariable?(var := getLhs(s)$SyntaxHelper, lv) and (next <= #b) then
          b := localVariableSubstitutions!(next, b, s, var)
          -- mark the intermediate assignment which is ready to be removed
          toRemove := union(next-1, toRemove)
        current := current + 1
      -- remove intermediate assignments over local variable	
      removeLocalAssignments(b, toRemove)

    lhsInRhs?(x: LetAst): Boolean ==
      l := getLhs(x)$SyntaxHelper
      x' := replaceLetRhs(l, x, unknownSyn())
      not(x::Syntax = x'::Syntax)

    toDelete: Set Integer := {}

    toBeRemoved?(label: Integer): Boolean ==
      member?(label, toDelete)

    qualifiedForElimination?(b: List LetAst, var: Syntax): Boolean ==
      vars := [getLhs(b.i)$SyntaxHelper for i in 1..#b| not toBeRemoved?(i)]
      member?(var, vars)

    globalVariableSubstitutions: List LetAst -> List LetAst

    updateLoopBody!(b: List LetAst, t: List LetAst, i: Integer): List LetAst ==
      for j in 1..#t repeat
        b.(i+j) := t.j
      b

    globalVariableSubstitution(b: List LetAst, b': List LetAst, i: Integer, i': Integer, l: Syntax, r: Syntax): List LetAst==
      before := b'.i'
      b'.i' : LetAst := replaceLetRhs(l, b'.i', r)$SyntaxHelper
      if not ((before::Syntax) = ((b'.i')::Syntax)) then
        t := globalVariableSubstitutions(b')
        b := updateLoopBody!(b, t, i)
      b
      
    updateDeletionList!(c: Boolean, i: Integer): Boolean ==
      if c then 
        toDelete := union(i, toDelete)
      true

    globalVariableSubstitutions(b: List LetAst): List LetAst ==
      for i in #b..1 by -1 | ((i <= #b-1) and not toBeRemoved?(i)) repeat
        -- if this assignment is not marked as to be removed, continue the substitution for the next assignment
        b' := [b.n for n in (i+1)..#b]
        l := getLhs(b.i)$SyntaxHelper
        r := rhs(b.i)::Syntax
        qualified? : Boolean := qualifiedForElimination?(b', l)
        for i' in 1..#b' | not toBeRemoved?(i') repeat
          if (not qualified?) and lhsInRhs?(b.i) then
            break
          b := globalVariableSubstitution(b, b', i, i', l, r)
          updateDeletionList!(qualified?, i)
      b
    
    removeGlobalAssignments(b: List LetAst): List LetAst ==
      [qelt(b, n) for n in 1..#b | not member?(n, toDelete)]@List LetAst

    eliminateGlobalVariable!(b: List LetAst): List LetAst ==
      toDelete := empty()
      b := globalVariableSubstitutions(b)
      removeGlobalAssignments(b)

    freeVariables(v: Syntax, gv: VTB): List Syntax ==
      result : List Syntax := []
      op := getOperator(v)
      if op case Identifier and key?(op::Identifier::Syntax, gv) then
        result := concat(result, op::Identifier::Syntax)
      for s in getOperands(v) repeat
        if compound? s then
          result := concat(result, freeVariables(s, gv))
        if not compound? s then
          if key?(s, gv) then
            result := concat(result, s)
      result

    advanceListWithin?(vars: List Syntax, i: SpadAst, gv: VTB): Boolean ==
      for v in vars repeat
        if compound? v then
          listWithin?(freeVariables(v, gv), i::Syntax)$SyntaxHelper => return true
        else 
          within?(v, i::Syntax)$SyntaxHelper => return true
      false

    advanceListWithin2?(vars: List Syntax, i: SpadAst, gv: VTB): Boolean ==
      for v in vars repeat
        x := v
        if compound? v and (container := getOperator(v)) case Identifier and key?((c := container::Identifier::Syntax), gv) then
          x := c
        within?(x, i::Syntax)$SyntaxHelper => return true
      false

    withinIterators?(vars: List Syntax, its: List SpadAst, gv: VTB): Boolean ==
      for i in its repeat
        advanceListWithin?(vars, i, gv) => return true
      false

    isBinaryExpression?(e: Syntax): Boolean ==
      compound?(e) and #getOperands(e) = 2

    searchForAccumulationVariable(v: Syntax, exp: Syntax): Pair(Integer, List Syntax) ==
      result : List Syntax := []
      counter : Integer := 0
      v = exp =>
        counter := counter + 1
        pair(counter, result)
      compound? exp =>
        expLst := (unlist exp)$SyntaxHelper
        result := concat(result, expLst.1)
        for u in expLst repeat
          if first(r := searchForAccumulationVariable(v, u)) > 0 then
            counter := counter + (first r)
            result  := concat(result, second r)
        pair(counter, result)
      pair(counter, result)

    sameOperators?(opList: List Syntax): Boolean == #removeDuplicates(opList) = 1

    verifyCountAndOperator(v: Syntax, exp: Syntax): Boolean ==
      r := searchForAccumulationVariable(v, exp)
      (first r = 1) and sameOperators?(second r)

    containExclamation?(r: Syntax): Boolean ==
      member?(char("!"::String)$Character, entries(toString(r)$SyntaxHelper)) 
      
    -- verify our new canonical form, pay attention to testing option at line 385
    verifyImprovedCanonicalForm(v: Syntax, r: Syntax, its: List SpadAst, vars: List Syntax, localcount: Integer, gv: VTB): Integer ==
      --if compound?(v) and 
      -- containExclamation?(r)  -- for examining the side effect functions.
      if not containExclamation?(r) and isBinaryExpression?(r) and not withinIterators?(vars, its, gv)_ 
         and verifyCountAndOperator(v, r) and not advanceListWithin2?(remove(v, vars), r::SpadAst, gv) then
        localcount := localcount + 1
      localcount

    countEachReduction(s: LetAst, its: List SpadAst, vars: List Syntax, localcount: Integer, gv: VTB): Integer ==
      l := getLhs(s)$SyntaxHelper
      r := rhs(s)::Syntax
      localcount := verifyImprovedCanonicalForm(l, r, its, vars, localcount, gv)

    isReduction?(b: List LetAst, its: List SpadAst, gv: VTB): Boolean ==
      localcount : Integer := 0
      varsInLhs : List Syntax := [getLhs(s)$SyntaxHelper for s in b]
      for s in b repeat
        localcount := countEachReduction(s, its, varsInLhs, localcount, gv)
      localcount = #b =>
        -- pay attention to the order of updating
        if empty? reductionVariableListInThenBranch then
          reductionVariableListInThenBranch := copy varsInLhs
        else
          reductionVariableListInElseBranch := copy varsInLhs
        true
      false

    verifyReduction(its: List SpadAst, b: List LetAst, gv: VTB, lv: VTB): Boolean ==
      empty?(b) => true
      b := eliminateLocalVariable!(b, lv)
      b := eliminateGlobalVariable!(b)
      isReduction?(b, its, gv)

    -- collect the local variables from each assignment in the body of a loop
    collectLocalVariableofLoop(bl: List LetAst, gv: VTB): VTB ==
      lv : VTB := empty()
      for b in bl repeat
        k := getLhs(b)$SyntaxHelper
        if not key?(k, gv) then
          lv.k := r::Syntax
      lv

    -- collect the global variables from the loop induction variables
    collectLoopInductionVariable(iters: List SpadAst, gv: VTB): VTB ==
      -- currently, we don't handle while loop such as while(i < l) 
      for i in iters repeat
        -- e.g. (STEP i (minr x) 1 (maxr x))
        -- e.g. (IN i l)
        v := first(getOperands(i::Syntax))
        -- an approximation to the initial value of the induction variable
        -- may use more precise value, but I don't see the necessity.
        gv.v := unknownSyn()
      gv

    collectVariableFromIfCondition(b: SpadAst, gv: VTB): VTB ==
      (b case IfAst) =>
        con := condition(b::Syntax::IfAst)
        compound?(con::Syntax) and con case LetAst =>
          v := getLhs(con::Syntax::LetAst)$SyntaxHelper
          gv.v := unknownSyn()
          gv
        gv
      gv

    withInCondition?(thenList: List LetAst, elseList: List LetAst, b: SpadAst): Boolean ==
      vars : List Syntax := [getLhs(s)$SyntaxHelper for s in concat(thenList, elseList)]
      not compound?(b::Syntax) => false
      b case IfAst => listWithin?(vars, condition(b::Syntax::IfAst)::Syntax)
      b case SequenceAst => 
        s := expression((second(body(b::Syntax::SequenceAst)))::Syntax::ExitAst)::Syntax::IfAst
        listWithin?(vars, condition(s)::Syntax)
      userError "unexpected body of the verified repeat-if syntax"

    identifyAccumulationLoop3(r: RepeatAst, gv: VTB): ACC ==
      result : ACC := []
      not empty?(iterators(r)) => 
        its := iterators(r)
        it := first its
        -- collect the global variables from the loop induction variables
        -- in the loop iterators
        gv := collectLoopInductionVariable(its, gv)
        -- if this is a while loop
        -- we don't handle reduction implemented in the while loop right now.
        it case WhileAst => 
          result := concat(result, identifyAccumulationLoop2(body(r), copy gv))
        -- if this is a for loop, and only contains let statement
        reductionVariableListInThenBranch := []
        reductionVariableListInElseBranch := []

        first(p := letOnly? r) => 
          lv : VTB := collectLocalVariableofLoop(second p, gv)
          verifyReduction(its, second p, gv, lv) =>
          --not verifyReduction(its, second p, gv, lv) =>
            reductionVariableList := concat(reductionVariableList, [reductionVariableListInThenBranch])
            result := concat(result, [r])
          result := concat(result, [])

        first(q := ifOnly? r) =>
          gv' : VTB := collectVariableFromIfCondition(body r, copy gv)        
          thenList := first second q
          elseList := second second q
          lvThen  : VTB := collectLocalVariableofLoop(thenList, gv')
          lvElse  : VTB := collectLocalVariableofLoop(elseList, gv')
          verifyReduction(its, thenList, gv', lvThen) and_
          verifyReduction(its, elseList, gv', lvElse) and_
          not withInCondition?(thenList, elseList, body r) =>
            reductionVariableList := concat(reductionVariableList, [concat(reductionVariableListInThenBranch, reductionVariableListInElseBranch)])
            result := concat(result, [r])
          result := concat(result, [])
      -- if this is a for loop, and is a mix, then recur
        result := concat(result, identifyAccumulationLoop2(body r, copy gv))
        result

      result := concat(result, identifyAccumulationLoop2(body r, copy gv))
      result

    forLoopWithStep?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      empty? iters => false
      loopHead := (first(iters))::Syntax
      compound?(loopHead) and (getOperator(loopHead)::Identifier) = ('STEP::Identifier) =>
        #getOperands(loopHead) = 4  -- to make sure we have both lower and upper bounds.
      false

    forLoopWithInAst?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      empty? iters => false
      loopHead := first iters
      loopHead case InAst

    stepForLoopWithCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithStep?(r) and #iters = 2 =>
        iters.2 case SuchThatAst => true
        false
      false

    stepForLoopWithoutCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithStep?(r) and #iters = 1 

    inSequenceForLoopWithCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithInAst?(r) and #iters = 2 =>
        iters.2 case SuchThatAst => true
        false
      false

    inSequenceForLoopWithoutCondition?(r: RepeatAst): Boolean ==
      iters := iterators(r)
      forLoopWithInAst?(r) and #iters = 1

    collectLoopCounterFromStep(r: SpadAst): List Identifier ==
      c := first getOperands(r::Syntax)
      c case Identifier => [c::Identifier]
      print(r::OutputForm)
      userError "unexpected loop counter syntax"

    collectParametersInBoundFromStep(r: Syntax, gv: VTB): List Identifier ==    
      not compound? r =>
        r case Identifier and key?(r, gv) => [r]
        []
      res : List Identifier := []
      terms := getOperands(r)
      for t in terms repeat
        res := concat(res, collectParametersInBoundFromStep(t, gv))
      res

    collectParametersFromSequcneOfInAst(r: Syntax, gv: VTB): List Identifier ==
      collectParametersInBoundFromStep(r, gv)

    containLoop?(s: SpadAst): Boolean ==
      not compound?(s::Syntax) => false
      s case LetAst => false
      s case WhileAst => false -- we won't have while loop in ScoP
      s case ColonAst => false
      s case ConstructAst => false
      s case CollectAst => false
      s case ReturnAst => false
      s case CaseAst => containLoop?(rhs(s::Syntax::CaseAst))
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          containLoop?(b) => return true
        false  
      s case RepeatAst => true
      s case IfAst =>
        thBranch := thenBranch(s::Syntax::IfAst)
        elBranch := elseBranch(s::Syntax::IfAst)
        if compound?(thBranch::Syntax) then
          containLoop?(thBranch) => return true
        if compound?(elBranch::Syntax) then
          containLoop?(elBranch) => return true
        false
      s case ExitAst =>
        e := expression(s::Syntax::ExitAst)
        containLoop?(e)
      false

    getLoopDepth2(s: SpadAst, depth: Integer): Integer ==
      not compound?(s::Syntax) => depth
      s case LetAst => depth
      s case WhileAst => depth
      s case ColonAst => depth
      s case ConstructAst => depth
      s case CollectAst => depth
      s case ReturnAst => depth
      s case CaseAst => getLoopDepth2(rhs(s::Syntax::CaseAst), depth)
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        maxDepth := depth
        for b in bs repeat
          currentDepth := getLoopDepth2(b, depth)
          if currentDepth > maxDepth then
            maxDepth := currentDepth
        maxDepth  
      s case RepeatAst => getLoopDepth2(body(s::Syntax::RepeatAst), inc(depth)) 
      s case IfAst =>
        thBranch := thenBranch(s::Syntax::IfAst)
        elBranch := elseBranch(s::Syntax::IfAst)
        depthThen : Integer := 0
        depthElse : Integer := 0
        if compound?(thBranch::Syntax) then
          depthThen := getLoopDepth2(thBranch, depth)
        if compound?(elBranch::Syntax) then
          depthElse := getLoopDepth2(elBranch, depth)
        max(depthElse, depthThen)
      s case ExitAst =>
        e := expression(s::Syntax::ExitAst)
        getLoopDepth2(e, depth)
      depth

    getLoopDepth(s: RepeatAst): Integer ==
      depth : Integer := 1
      getLoopDepth2(body s, depth)

    getAllAssignmentFromSyntax(s: SpadAst): List Syntax ==
      not compound?(s::Syntax) => []
      result : List Syntax := []
      s case LetAst => [s::Syntax]
      s case WhileAst => []
      s case ColonAst => []
      s case ConstructAst => []
      s case CollectAst => []
      s case ReturnAst => []
      s case CaseAst => result := concat(result, getAllAssignmentFromSyntax(rhs(s::Syntax::CaseAst)))
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          result := concat(result, getAllAssignmentFromSyntax(b))
        result
      s case RepeatAst =>
        result := concat(result, getAllAssignmentFromSyntax(body(s::Syntax::RepeatAst)))
      s case IfAst =>
        thBranch := thenBranch(s::Syntax::IfAst)
        elBranch := elseBranch(s::Syntax::IfAst)
        if compound?(thBranch::Syntax) then
          result := concat(result, getAllAssignmentFromSyntax(thBranch))
        if compound?(elBranch::Syntax) then
          result := concat(result, getAllAssignmentFromSyntax(elBranch))
        result
      s case ExitAst =>
        e := expression(s::Syntax::ExitAst)
        result := concat(result, getAllAssignmentFromSyntax(e))
      result

    getAllIdentifiersFromAssignments(assignments: List Syntax): List Identifier ==
      res : List Identifier := []
      for a in assignments repeat
        lhs := getLhs(a::SpadAst::LetAst)$SyntaxHelper
        lhs case Identifier => res := concat(res, lhs::Identifier)
      removeDuplicates(res)

    checkInvariance(varList: List Identifier, r: RepeatAst): Boolean ==
      assignmentsInLoop := getAllAssignmentFromSyntax(r::Syntax::SpadAst)
      identifiersBeingAssigned := getAllIdentifiersFromAssignments assignmentsInLoop
      for v in varList repeat
        member?(v, identifiersBeingAssigned) => return false
      true

    isAccessForm?(e: Syntax, gv: VTB): Boolean ==
      (op := getOperator(e)) case Identifier =>
        (op::Identifier) = 'qelt::Identifier => return true 
        key?(op::Identifier::Syntax, gv)
      false
  
    buildInAccessFunctions : List Identifier := ['qsetelt!, 'setelt, 'elt, 'qelt]

    isAccessFunction?(e: Syntax): Boolean ==
      (op := getOperator(e)) case Identifier =>
        op' := op::Identifier
        member?(op', buildInAccessFunctions)
      false


    verifyItemInExpression(l: Syntax, r: Syntax, loopCounters: List Identifier, gv: VTB): Boolean ==
      not compound?(l) and not compound?(r) =>
        l case Integer and r case Identifier =>
          r' := r::Identifier
          member?(r', loopCounters) or key?(r, gv)
        l case Identifier and r case Integer =>
          l' := l::Identifier
          member?(l', loopCounters) or key?(l, gv)
        false
      false

    verifyIndexExpression(e: Syntax, loopCounters: List Identifier, gv: VTB): Boolean ==
      not compound?(e) => true
      (op := getOperator(e)) case Identifier =>
        op' := op::Identifier
        op' = '_+::Identifier or op' = '_-::Identifier => 
          for x in getOperands(e) repeat
            not verifyIndexExpression(x, loopCounters, gv) => return false
          true
        op' = '_*::Identifier and #getOperands(e)=2 =>
          l := getOperands(e).1
          r := getOperands(e).2
          verifyItemInExpression(l, r, loopCounters, gv)
        false
      false

    expressionWithAffineReferenceOnly?: (Syntax, List Identifier, VTB) -> Boolean

    verifyAccessFunctionParameters(e: Syntax, loopCounters: List Identifier, gv: VTB): Boolean ==
      op := getOperator(e)::Identifier
      opr := getOperands(e)
      op = 'qsetelt! => 
        #opr = 4 =>
          index1 := opr.2
          index2 := opr.3
          c := opr.4
          verifyIndexExpression(index1, loopCounters, gv) and_
          verifyIndexExpression(index2, loopCounters, gv) and_
          expressionWithAffineReferenceOnly?(c, loopCounters, gv)
        #opr = 3 =>
           index1 := opr.2
           c := opr.3
           verifyIndexExpression(index1, loopCounters, gv) and_
           expressionWithAffineReferenceOnly?(c, loopCounters, gv)
        false
      op = 'setelt => 
        #opr = 4 =>
          index1 := opr.2
          index2 := opr.3
          c := opr.4
          verifyIndexExpression(index1, loopCounters, gv) and_
          verifyIndexExpression(index2, loopCounters, gv) and_
          expressionWithAffineReferenceOnly?(c, loopCounters, gv)
        #opr = 3 =>
           index1 := opr.2
           c := opr.3
           verifyIndexExpression(index1, loopCounters, gv) and_
           expressionWithAffineReferenceOnly?(c, loopCounters, gv)
        false
      op = 'elt =>
        #opr = 2 =>
          index1 := opr.2
          verifyIndexExpression(index1, loopCounters, gv)
        #opr = 3 =>
          index1 := opr.2
          index2 := opr.3
          verifyIndexExpression(index1, loopCounters, gv) and_
          verifyIndexExpression(index2, loopCounters, gv)
        false
      op = 'qelt =>
        #opr = 2 =>
          index1 := opr.2
          verifyIndexExpression(index1, loopCounters, gv)
        #opr = 3 =>
          index1 := opr.2
          index2 := opr.3
          verifyIndexExpression(index1, loopCounters, gv) and_
          verifyIndexExpression(index2, loopCounters, gv)
        false
      print(e::OutputForm)
      userError "unexpected kind of access library function"

    isAnnotated?(e: Syntax):Boolean ==
      (op := getOperator(e)) case Syntax =>
        (op' := getOperator(op::Syntax)) case Identifier and_
        op'::Identifier = 'elt and #getOperands(op::Syntax) = 2 
      false

    annotatedExpressionWithAffineReferenceOnly?(e: Syntax, loopCounters: List Identifier, gv: VTB): Boolean ==
      op := getOperands(getOperator(e)::Syntax).last
      oprs := getOperands(e)
      exp := buildSyntax(op, oprs)
      expressionWithAffineReferenceOnly?(exp, loopCounters, gv)
      
    expressionWithAffineReferenceOnly?(e: Syntax, loopCounters: List Identifier, gv: VTB): Boolean ==
      not compound? e => true
      isAnnotated?(e) => annotatedExpressionWithAffineReferenceOnly?(e, loopCounters, gv)
      isAccessForm?(e, gv) => verifyIndexExpression(first getOperands(e), loopCounters, gv)
      isAccessFunction?(e) => verifyAccessFunctionParameters(e, loopCounters, gv)
      for s in unlist(e)$SyntaxHelper repeat
        not expressionWithAffineReferenceOnly?(s, loopCounters, gv) => return false
      true

    verifyArrayReference(a: LetAst, loopCounters: List Identifier, gv: VTB): Boolean ==
      l := getLhs(a)$SyntaxHelper
      r := rhs(a)::Syntax
      b := expressionWithAffineReferenceOnly?(l, loopCounters, gv) and_
      expressionWithAffineReferenceOnly?(r, loopCounters, gv)
      b    

    verifyPredicateExpression(a: IfAst, loopCounters: List Identifier, gv: VTB): Boolean ==
      predicate := condition(a)::Syntax
      not compound?(predicate) => true
      (op := getOperator(predicate)) case Identifier => 
        op' := op::Identifier
        member?(op', buildInPredicateSet) =>
          for opr in getOperands(predicate) repeat
            not expressionWithAffineReferenceOnly?(opr, loopCounters, gv) => return false
          true
        expressionWithAffineReferenceOnly?(predicate, loopCounters, gv)
      false

    identifyAffineControlLoop2: (RepeatAst, List Identifier, List Identifier, VTB) -> Boolean

    verifyStaticControlLoopBody(s: SpadAst, loopCounters: List Identifier, boundParameters: List Identifier, gv: VTB): Boolean ==
      
      not compound?(s::Syntax) => true
      s case LetAst => 
        k := getLhs(s)$SyntaxHelper
        gv.k := rhs(s::Syntax::LetAst)::Syntax
        not empty?(loopCounters) =>
          verifyArrayReference(s::Syntax::LetAst, loopCounters, gv)
        true
      s case WhileAst => false
      s case ColonAst => 
        k := lhs(s::Syntax::ColonAst)::Syntax
        gv.k := unknownSyn()
        true
      s case ConstructAst => true
      s case CollectAst => true
      s case ReturnAst => true
      s case CaseAst => false -- we only allow if statement, instead of case conditionals
      s case SequenceAst =>
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          not verifyStaticControlLoopBody(b, loopCounters, boundParameters, copy gv) => return false
        true
      s case RepeatAst => identifyAffineControlLoop2(s::Syntax::RepeatAst, copy loopCounters, copy boundParameters, copy gv) 
      s case IfAst => 
        verifyPredicateExpression(s::Syntax::IfAst, loopCounters, gv) =>
          thBranch := thenBranch(s::Syntax::IfAst)
          elBranch := elseBranch(s::Syntax::IfAst)
          if hasThenBranch?(s::Syntax::IfAst)$SyntaxHelper then
            not verifyStaticControlLoopBody(thBranch, loopCounters, boundParameters, copy gv) =>
              return false
          if hasElseBranch?(s::Syntax::IfAst)$SyntaxHelper then
            not verifyStaticControlLoopBody(elBranch, loopCounters, boundParameters, copy gv) => 
              return false
          true
        false
      s case ExitAst =>
        e := expression(s::Syntax::ExitAst)
        verifyStaticControlLoopBody(e, loopCounters, boundParameters, gv)
      expressionWithAffineReferenceOnly?(s::Syntax, loopCounters, gv)

    stepForLoopIsACL?(r: RepeatAst, loopCounters: List Identifier, boundParameters: List Identifier, gv: VTB): Boolean ==
      iter := first iterators(r)
      iter' := iter::Syntax
      loopCounters := concat(loopCounters, collectLoopCounterFromStep(iter))
      boundParameters := concat(boundParameters, collectParametersInBoundFromStep(iter', gv))
      not checkInvariance(concat(loopCounters, boundParameters), r) => false
      verifyStaticControlLoopBody(body r, loopCounters, boundParameters, gv)

    inAstForLoopIsACL?(r: RepeatAst, loopCounters: List Identifier, boundParameters: List Identifier, gv: VTB): Boolean ==
      iter := (first iterators(r))::Syntax::InAst
      seq := sequence(iter)::Syntax
      boundParameters := concat(boundParameters, collectParametersFromSequcneOfInAst(seq, gv))
      not checkInvariance(concat(loopCounters, boundParameters), r) => false
      verifyStaticControlLoopBody(body r, loopCounters, boundParameters, gv)
      
    identifyAffineControlLoop2(r: RepeatAst, loopCounters: List Identifier, boundParameters: List Identifier, gv: VTB): Boolean ==
      forLoopWithStep?(r)  => 
        stepForLoopIsACL?(r, loopCounters, boundParameters, gv)
      forLoopWithInAst?(r) => 
        inAstForLoopIsACL?(r, loopCounters, boundParameters, gv)
      false


    updateGlobalVariableTableWithLoopCounter(s: RepeatAst, gv: VTB): VTB ==
      gv' := copy gv
      iters := iterators(s)
      #iters > 0 =>
        iter := first iters
        iter' := iter::Syntax
        ((op := getOperator(iter')) case Identifier) and_ 
        ((op::Identifier = 'IN) or (op::Identifier = 'STEP)) =>
          k := first(getOperands(iter'))
          gv'.k := unknownSyn()
          gv'
        gv'
      gv'

    -- and make two copies of the table once we enter if/case/Repeat
    identifyAccumulationLoop2(s: SpadAst, gv: VTB): ACC ==
      if not compound?(s::Syntax) then return []
      result : ACC := []
      s case LetAst => 
        k := getLhs(s)$SyntaxHelper
        gv.k := rhs(s::Syntax::LetAst)::Syntax
        []
      s case WhileAst => []  
      s case ColonAst => 
        k := lhs(s::Syntax::ColonAst)::Syntax
        gv.k := unknownSyn()
        []
      s case ConstructAst => []
      s case CollectAst => []
      s case ReturnAst => []
      s case CaseAst => result := concat(result, identifyAccumulationLoop2(rhs(s::Syntax::CaseAst), copy gv))
      s case SequenceAst => 
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          result := concat(result, identifyAccumulationLoop2(b, gv))
        result
      s case RepeatAst => 
        result := concat(result, identifyAccumulationLoop3(s::Syntax::RepeatAst, copy gv))
      s case IfAst => 
        thBranch := thenBranch(s::Syntax::IfAst)
        elBranch := elseBranch(s::Syntax::IfAst)
        if compound?(thBranch::Syntax) then
          result := concat(result, identifyAccumulationLoop2(thBranch, copy gv))
        if compound?(elBranch::Syntax) then
          result := concat(result, identifyAccumulationLoop2(elBranch, copy gv))
        result
      s case ExitAst =>
        e := expression(s::Syntax::ExitAst)
        result := concat(result, identifyAccumulationLoop2(e, copy gv))
      result

    identifyAffineControlLoop(s: SpadAst, gv: VTB): ACC ==
      if not compound?(s::Syntax) then return []
      result : ACC := []
      s case LetAst => 
        k := getLhs(s)$SyntaxHelper
        gv.k := rhs(s::Syntax::LetAst)::Syntax
        []
      s case WhileAst => []  
      s case ColonAst => 
        k := lhs(s::Syntax::ColonAst)::Syntax
        gv.k := unknownSyn()
        []
      s case ConstructAst => []
      s case CollectAst => []
      s case ReturnAst => []
      s case CaseAst => result := concat(result, identifyAffineControlLoop(rhs(s::Syntax::CaseAst), copy gv))
      s case SequenceAst => 
        bs := body(s::Syntax::SequenceAst)
        for b in bs repeat
          result := concat(result, identifyAffineControlLoop(b, copy gv))
        result
      s case RepeatAst => 
        s' := s::Syntax::RepeatAst
        if option = 3 then
          getLoopDepth(s') >= 2 => return [s']
          return [] 
        identifyAffineControlLoop2(s', [], [], copy gv) and containLoop?(body(s')) =>
          [s']
        gv' := updateGlobalVariableTableWithLoopCounter(s', copy gv)
        identifyAffineControlLoop(body s', gv') -- this gv needs to be updated.
      s case IfAst => 
        thBranch := thenBranch(s::Syntax::IfAst)
        elBranch := elseBranch(s::Syntax::IfAst)
        if compound?(thBranch::Syntax) then
          result := concat(result, identifyAffineControlLoop(thBranch, copy gv))
        if compound?(elBranch::Syntax) then
          result := concat(result, identifyAffineControlLoop(elBranch, copy gv))
        result
      s case ExitAst =>
        e := expression(s::Syntax::ExitAst)
        result := concat(result, identifyAffineControlLoop(e, copy gv))
      result

    identifyAccumulationLoop d == 
      vt := empty()
      fn : Identifier := name(head(d)::Syntax::HeadAst)
      pl : List Identifier := parameters(head(d)::Syntax::HeadAst)
      -- initialize the variable table with function parameters
      vt := initVariableTable(vt, pl)
      -- start analysis
      identifyAccumulationLoop2(body d, vt)

-- Syntactical analysis for collecting loops (emprical data):
-- 1. iterate through each file of algebra library
-- 2. traverse through the syntax tree of the domain/category/package
-- 3. collect the RepeatAst when entering the implementation body
 
    --Global variables
    count: Integer := 0
    -- loop table stores the final analysis results
    lpTable: LTB := empty()
    rlpTable: LTB := empty()
    aclTable: LTB := empty()
    nlTable: LTB := empty()
    functionName : Identifier := gensym()
    -- Table for storing global variables such as constructor parameter, and global variable in capsule
    cgv: VTB := empty()

    cleanUp(): Void ==
      lpTable := empty()
      rlpTable := empty()
      aclTable := empty()
      nlTable := empty()
      count := 0

    updateTable(d: Identifier, f: Identifier, b: RepeatAst, t: LTB): LTB ==
      k : Pair(Identifier, Identifier) := pair(d, f)
      if key?(k, t) then
        t.k := cons(b, t.k)
      else
        t.k := [b]
      t

    updateTable2(d: Identifier, f: Identifier, bl: List RepeatAst, t: LTB): LTB ==
      for b in bl repeat
        updateTable(d, f, b, t)
      t

    initVtWithGt(v: VTB, g: VTB): VTB ==
      for k in keys(g) repeat
        v.k := g.k
      v

    identifyAccumulationLoop0 d == 
      vt := empty()
      fn : Identifier := name(head(d)::Syntax::HeadAst)
      pl : List Identifier := parameters(head(d)::Syntax::HeadAst)
      -- initialize the variable table with function parameters
      vt := initVariableTable(vt, pl)
      -- insert the constructor global variables and capsule global variables
      vt := initVtWithGt(vt, cgv)
      -- start analysis
      pair(fn, identifyAccumulationLoop2(body d, vt))

    identifyAffineControlLoop0 d ==
      vt := empty()
      fn : Identifier := name(head(d)::Syntax::HeadAst)
      pl : List Identifier := parameters(head(d)::Syntax::HeadAst)
      -- initialize the variable table with function parameters
      vt := initVariableTable(vt, pl)
      -- insert the constructor global variables and capsule global variables
      vt := initVtWithGt(vt, cgv)
      -- start analysis
      pair(fn, identifyAffineControlLoop(body d, vt))

    -- collect the loop ast from a statement
    collectAccumulationFromStatement(dBody: SpadAst, ctor: Identifier): Integer ==
      if not compound?(dBody::Syntax) then return count
      dBody case SignatureAst =>
        count
      dBody case MacroAst => 
        count
      dBody case DefinitionAst => 
        if (option = 1) then
          -- extract accumulation loop
          t : Pair(Identifier, ACC) := identifyAccumulationLoop0(dBody::Syntax::DefinitionAst)
          -- update the result table
          t' := first t
          k : Pair(Identifier, Identifier) := pair(ctor, t')
          rl : ACC := second t
          updateTable2(ctor, t', rl, rlpTable)
          --print("exit!!"::OutputForm)
        else if (option = 2) or (option = 3) then
          -- extract accumulation loop
          t : Pair(Identifier, ACC) := identifyAffineControlLoop0(dBody::Syntax::DefinitionAst)
          -- update the result table
          t' := first t
          k : Pair(Identifier, Identifier) := pair(ctor, t')
          rl : ACC := second t
          option = 2 =>
            updateTable2(ctor, t', rl, aclTable)
          option = 3 =>
            updateTable2(ctor, t', rl, nlTable)
          --print("exit!!"::OutputForm)
        else
          collectAccumulationFromDefinition(dBody::Syntax::DefinitionAst, ctor)
        count
      dBody case SequenceAst =>
        stmtLst:= body(dBody::Syntax::SequenceAst)$SequenceAst
        for stmt in stmtLst repeat
          collectAccumulationFromStatement(stmt, ctor)
        count
      dBody case IfAst => 
        thBranch :=  thenBranch(dBody::Syntax::IfAst)$IfAst
        elBranch := elseBranch(dBody::Syntax::IfAst)$IfAst
        if compound?(thBranch::Syntax) then
          collectAccumulationFromStatement(thBranch, ctor)
        if compound?(elBranch::Syntax) then
          collectAccumulationFromStatement(elBranch, ctor)
        count
      dBody case ReturnAst =>
        rtn := expression(dBody::Syntax::ReturnAst)$ReturnAst
        if compound?(rtn::Syntax) then
          collectAccumulationFromStatement(rtn, ctor)
        count
      dBody case RepeatAst =>
        b := dBody::Syntax::RepeatAst
        updateTable(ctor, functionName, b, lpTable)
        count := count + 1
        count
      dBody case CoerceAst =>
        coeast := dBody::Syntax::CoerceAst
        tp := ((target(coeast))$CoerceAst)::Syntax
        exp := (expression(coeast)$CoerceAst)::Syntax
        coerExp := expression(dBody::Syntax::CoerceAst)$CoerceAst
        if compound?(coerExp::Syntax) then
          collectAccumulationFromStatement(coerExp, ctor)
        count
      dBody case ExitAst =>
        dbexp := expression(dBody::Syntax::ExitAst)$ExitAst
        collectAccumulationFromStatement(dbexp, ctor)
      dBody case LetAst =>
        l := getLhs(dBody::Syntax::LetAst)$SyntaxHelper
        r := (rhs(dBody::Syntax::LetAst)$LetAst)::Syntax
        cgv.l := r
        dlet := rhs(dBody::Syntax::LetAst)$LetAst
        dlhs := lhs(dBody::Syntax::LetAst)$LetAst
        if compound?(dlet::Syntax) then
          if (dlet case CollectAst) or (dlet case ConstructAst) then
            exp := (dlhs::Syntax)
        collectAccumulationFromStatement(dlhs, ctor)
        collectAccumulationFromStatement(dlet, ctor)
      dBody case WhileAst => count  
      dBody case ColonAst => 
        colast := dBody::Syntax::ColonAst
        id := (lhs(colast)$ColonAst)::Syntax
        tp := (rhs(colast)$ColonAst)::Syntax
        cgv.id := unknownSyn()
        count
      dBody case ConstructAst => count
      dBody case CollectAst => count
      dBody case CaseAst => count
      count

    -- collects loop from one function definition
    collectAccumulationFromDefinition(defa: DefinitionAst, ctor: Identifier): Integer ==
      hd := head(defa)$DefinitionAst
      functionName := name hd
      sig := signature(defa)$DefinitionAst
      dBody := body(defa)$DefinitionAst
      collectAccumulationFromStatement(dBody, ctor)
      count

    -- analysis for top level statements (definitions)
    collectAccumulationAtTopLevel(sa: SpadAst, ctor: Identifier): Integer ==
      sa case ColonAst => 
        -- collect the global variable declared in the capsule
        l := lhs(sa::Syntax::ColonAst)::Syntax
        cgv.l := unknownSyn()
        count
      sa case SignatureAst => count
      sa case MacroAst     =>  count
      sa case ImportAst    => count
      sa case DefinitionAst => 
        if (option = 1) then
          -- extract accumulation loop
          t : Pair(Identifier, ACC) := identifyAccumulationLoop0(sa::Syntax::DefinitionAst)
          -- update the result table
          t' := first t
          k : Pair(Identifier, Identifier) := pair(ctor, t')
          rl : ACC := second t
          updateTable2(ctor, t', rl, rlpTable)
        else if (option = 2) or (option = 3) then
          -- extract accumulation loop
          t : Pair(Identifier, ACC) := identifyAffineControlLoop0(sa::Syntax::DefinitionAst)
          -- update the result table
          t' := first t
          k : Pair(Identifier, Identifier) := pair(ctor, t')
          rl : ACC := second t
          option = 2 =>
            updateTable2(ctor, t', rl, aclTable)
          option = 3 =>
            updateTable2(ctor, t', rl, nlTable)
          --print("exit!!"::OutputForm)
        else
          collectAccumulationFromDefinition(sa::Syntax::DefinitionAst, ctor)
        count
      sa case SequenceAst => collectAccumulationFromStatement(sa, ctor)
      sa case LetAst => 
        sa' := sa::Syntax::LetAst
        l := getLhs(sa')$SyntaxHelper
        r := rhs(sa')::Syntax
        cgv.l := r
        collectAccumulationFromStatement(sa, ctor)
        -- above two cases are for handling some weird parsing result (ZMOD)
      sa case IfAst =>
        thBranch := thenBranch(sa::Syntax::IfAst)$IfAst
        elBranch := elseBranch(sa::Syntax::IfAst)$IfAst
        if compound?(thBranch::Syntax) then
          collectAccumulationAtTopLevel(thBranch, ctor)
        if compound?(elBranch::Syntax) then
          collectAccumulationAtTopLevel(elBranch, ctor)
        count
      collectAccumulationFromStatement(sa, ctor)

    -- inferface to preprocessor
    extractReductionPatternFromFunctionDefinition(defa: DefinitionAst, ctor: Identifier, tpenv: VTB): Pair(LTB, List List Syntax) ==
      cleanUp()
      -- does clean up
      reductionVariableList := []
      lpTable := empty()
      rlpTable := empty()
      count := 0
      -- finish cleaning up
      rlpTable := empty()
      option := 1
      cgv    := copy tpenv
      collectAccumulationAtTopLevel(defa::Syntax::SpadAst, ctor)
      pair(copy rlpTable, copy reductionVariableList)

    -- inferface to preprocessor
    extractAffineControlLoopFromFunctionDefinition(defa: DefinitionAst, ctor: Identifier, tpenv: VTB): LTB ==
      cleanUp()
      -- does clean up
      reductionVariableList := []
      lpTable := empty()
      rlpTable := empty()
      count := 0
      -- finish cleaning up
      aclTable := empty()
      option := 2
      cgv    := copy tpenv
      collectAccumulationAtTopLevel(defa::Syntax::SpadAst, ctor)
      copy aclTable

    -- inferface to preprocessor
    extractAllLoopNests(defa: DefinitionAst, ctor: Identifier, tpenv: VTB): LTB ==
      cleanUp()
      -- does clean up
      reductionVariableList := []
      lpTable := empty()
      rlpTable := empty()
      count := 0
      -- finish cleaning up
      nlTable := empty()
      option := 3
      cgv    := copy tpenv
      collectAccumulationAtTopLevel(defa::Syntax::SpadAst, ctor)
      copy nlTable








