)abbrev package DFSFUN DoubleFloatSpecialFunctions
++ Author: Bruce W. Char, Stephen M. Watt
++ Date Created:  1990
++ Date Last Updated: June 25, 1991
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   This package provides special functions for double precision
++   real and complex floating point.

DoubleFloatSpecialFunctions(): Exports == Impl where
    NNI ==> NonNegativeInteger
    R   ==> DoubleFloat
    C   ==> Complex DoubleFloat

    Exports ==> with
        Gamma: R -> R
            ++ Gamma(x) is the Euler gamma function, \spad{Gamma(x)}, defined by
            ++   \spad{Gamma(x) = integrate(t^(x-1)*exp(-t), t=0..%infinity)}.
        Gamma: C -> C
            ++ Gamma(x) is the Euler gamma function, \spad{Gamma(x)}, defined by
            ++   \spad{Gamma(x) = integrate(t^(x-1)*exp(-t), t=0..%infinity)}.

        Beta: (R, R) -> R
            ++ Beta(x, y) is the Euler beta function, \spad{B(x,y)}, defined by
            ++   \spad{Beta(x,y) = integrate(t^(x-1)*(1-t)^(y-1), t=0..1)}.
            ++ This is related to \spad{Gamma(x)} by
            ++   \spad{Beta(x,y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.
        Beta: (C, C) -> C
            ++ Beta(x, y) is the Euler beta function, \spad{B(x,y)}, defined by
            ++   \spad{Beta(x,y) = integrate(t^(x-1)*(1-t)^(y-1), t=0..1)}.
            ++ This is related to \spad{Gamma(x)} by
            ++   \spad{Beta(x,y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.

        logGamma: R -> R
            ++ logGamma(x) is the natural log of \spad{Gamma(x)}.
            ++ This can often be computed even if \spad{Gamma(x)} cannot.
        logGamma: C -> C
            ++ logGamma(x) is the natural log of \spad{Gamma(x)}.
            ++ This can often be computed even if \spad{Gamma(x)} cannot.

        digamma: R -> R
            ++ digamma(x) is the function, \spad{psi(x)}, defined by
            ++   \spad{psi(x) = Gamma'(x)/Gamma(x)}.
        digamma: C -> C
            ++ digamma(x) is the function, \spad{psi(x)}, defined by
            ++   \spad{psi(x) = Gamma'(x)/Gamma(x)}.

        polygamma: (NNI, R) -> R
            ++ polygamma(n, x) is the n-th derivative of \spad{digamma(x)}.
        polygamma: (NNI, C) -> C
            ++ polygamma(n, x) is the n-th derivative of \spad{digamma(x)}.


        besselJ: (R,R) -> R
            ++ besselJ(v,x) is the Bessel function of the first kind,
            ++ \spad{J(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.
        besselJ: (C,C) -> C
            ++ besselJ(v,x) is the Bessel function of the first kind,
            ++ \spad{J(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.

        besselY: (R, R) -> R
            ++ besselY(v,x) is the Bessel function of the second kind,
            ++ \spad{Y(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.
            ++ Note: The default implmentation uses the relation
            ++   \spad{Y(v,x) = (J(v,x) cos(v*%pi) - J(-v,x))/sin(v*%pi)}
            ++ so is not valid for integer values of v.
        besselY: (C, C) -> C
            ++ besselY(v,x) is the Bessel function of the second kind,
            ++ \spad{Y(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.
            ++ Note: The default implmentation uses the relation
            ++   \spad{Y(v,x) = (J(v,x) cos(v*%pi) - J(-v,x))/sin(v*%pi)}
            ++ so is not valid for integer values of v.

        besselI: (R,R) -> R
            ++ besselI(v,x) is the modified Bessel function of the first kind,
            ++ \spad{I(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.
        besselI: (C,C) -> C
            ++ besselI(v,x) is the modified Bessel function of the first kind,
            ++ \spad{I(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.

        besselK: (R, R) -> R
            ++ besselK(v,x) is the modified Bessel function of the first kind,
            ++ \spad{K(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.
            ++ Note: The default implmentation uses the relation
            ++   \spad{K(v,x) = %pi/2*(I(-v,x) - I(v,x))/sin(v*%pi)}.
            ++ so is not valid for integer values of v.
        besselK: (C, C) -> C
            ++ besselK(v,x) is the modified Bessel function of the first kind,
            ++ \spad{K(v,x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.
            ++ Note: The default implmentation uses the relation
            ++   \spad{K(v,x) = %pi/2*(I(-v,x) - I(v,x))/sin(v*%pi)}
            ++ so is not valid for integer values of v.

        airyAi:   C -> C
            ++ airyAi(x) is the Airy function \spad{Ai(x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{Ai''(x) - x * Ai(x) = 0}.
        airyAi:   R -> R
            ++ airyAi(x) is the Airy function \spad{Ai(x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{Ai''(x) - x * Ai(x) = 0}.

        airyBi:   R -> R
            ++ airyBi(x) is the Airy function \spad{Bi(x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{Bi''(x) - x * Bi(x) = 0}.
        airyBi:   C -> C
            ++ airyBi(x) is the Airy function \spad{Bi(x)}.
            ++ This function satisfies the differential equation:
            ++   \spad{Bi''(x) - x * Bi(x) = 0}.

        hypergeometric0F1: (R, R) -> R
            ++ hypergeometric0F1(c,z) is the hypergeometric function
            ++ \spad{0F1(; c; z)}.
        hypergeometric0F1: (C, C) -> C
            ++ hypergeometric0F1(c,z) is the hypergeometric function
            ++ \spad{0F1(; c; z)}.


    Impl ==> add
        a, v, w, z: C
        n, x, y: R

        -- These are hooks to Bruce's boot code.
        Gamma z         == CGAMMA(z)$Lisp
        Gamma x         == RGAMMA(x)$Lisp

        polygamma(k,z)  == CPSI(k, z)$Lisp
        polygamma(k,x)  == RPSI(k, x)$Lisp

        logGamma z      == CLNGAMMA(z)$Lisp
        logGamma x      == RLNGAMMA(x)$Lisp

        besselJ(v,z)    == CBESSELJ(v,z)$Lisp
        besselJ(n,x)    == RBESSELJ(n,x)$Lisp

        besselI(v,z)    == CBESSELI(v,z)$Lisp
        besselI(n,x)    == RBESSELI(n,x)$Lisp

        hypergeometric0F1(a,z) == CHYPER0F1(a, z)$Lisp
        hypergeometric0F1(n,x) == retract hypergeometric0F1(n::C, x::C)


        -- All others are defined in terms of these.
        digamma x == polygamma(0, x)
        digamma z == polygamma(0, z)

        Beta(x,y) == Gamma(x)*Gamma(y)/Gamma(x+y)
        Beta(w,z) == Gamma(w)*Gamma(z)/Gamma(w+z)

        fuzz := (10::R)**(-7)

        import IntegerRetractions(R)
        import IntegerRetractions(C)

        besselY(n,x) ==
            if integer? n then n := n + fuzz
            vp := n * pi()$R
            (cos(vp) * besselJ(n,x) - besselJ(-n,x) )/sin(vp)
        besselY(v,z) ==
            if integer? v then v := v + fuzz::C
            vp := v * pi()$C
            (cos(vp) * besselJ(v,z) - besselJ(-v,z) )/sin(vp)

        besselK(n,x) ==
            if integer? n then n := n + fuzz
            p    := pi()$R
            vp   := n*p
            ahalf:= 1/(2::R)
            p * ahalf * ( besselI(-n,x) - besselI(n,x) )/sin(vp)
        besselK(v,z) ==
            if integer? v then v := v + fuzz::C
            p    := pi()$C
            vp   := v*p
            ahalf:= 1/(2::C)
            p * ahalf * ( besselI(-v,z) - besselI(v,z) )/sin(vp)

        airyAi x ==
            ahalf  := recip(2::R)::R
            athird := recip(3::R)::R
            eta := 2 * athird * (-x) ** (3*ahalf)
            (-x)**ahalf * athird * (besselJ(-athird,eta) + besselJ(athird,eta))
        airyAi z ==
            ahalf  := recip(2::C)::C
            athird := recip(3::C)::C
            eta := 2 * athird * (-z) ** (3*ahalf)
            (-z)**ahalf * athird * (besselJ(-athird,eta) + besselJ(athird,eta))

        airyBi x ==
            ahalf  := recip(2::R)::R
            athird := recip(3::R)::R
            eta := 2 * athird * (-x) ** (3*ahalf)
            (-x*athird)**ahalf * ( besselJ(-athird,eta) - besselJ(athird,eta) )

        airyBi z ==
            ahalf  := recip(2::C)::C
            athird := recip(3::C)::C
            eta := 2 * athird * (-z) ** (3*ahalf)
            (-z*athird)**ahalf * ( besselJ(-athird,eta) - besselJ(athird,eta) )

