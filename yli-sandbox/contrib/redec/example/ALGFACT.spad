--import UnivariatePolynomialCategory
import AlgebraicNumber
import Boolean
)abbrev package ALGFACT AlgFactor
++ Factorization of UP AN;
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in 
++ \spadtype{AlgebraicNumber}.
 
AlgFactor(UP): Exports == Implementation where
  UP: UnivariatePolynomialCategory AlgebraicNumber
 
  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Integer
  AN  ==> AlgebraicNumber
  K   ==> Kernel AN
  UPQ ==> SparseUnivariatePolynomial Q
  SUP ==> SparseUnivariatePolynomial AN
  FR  ==> Factored UP
 
  Exports ==> with
    factor: (UP, List AN) -> FR
      ++ factor(p, [a1,...,an]) returns a prime factorisation of p
      ++ over the field generated by its coefficients and a1,...,an.
    factor: UP            -> FR
      ++ factor(p) returns a prime factorisation of p
      ++ over the field generated by its coefficients.
    split : UP            -> FR
      ++ split(p) returns a prime factorisation of p
      ++ over its splitting field.
    doublyTransitive?: UP -> Boolean
      ++ doublyTransitive?(p) is true if p is irreducible over
      ++ over the field K generated by its coefficients, and
      ++ if \spad{p(X) / (X - a)} is irreducible over 
      ++ \spad{K(a)} where \spad{p(a) = 0}.
 
  Implementation ==> add
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                           K, Z, SparseMultivariatePolynomial(Z, K), AN)

    UPCF2 ==> UnivariatePolynomialCategoryFunctions2

    fact    : (UP,  List K) -> FR
    ifactor : (SUP, List K) -> Factored SUP
    extend  : (UP, Z) -> FR
    allk    : List AN -> List K
    downpoly: UP  -> UPQ
    liftpoly: UPQ -> UP
    irred?  : UP  -> Boolean
 
    allk l       == removeDuplicates concat [kernels x for x in l]
    liftpoly p   == map(#1::AN,  p)$UPCF2(Q, UPQ, AN, UP)
    downpoly p   == map(retract(#1)@Q, p)$UPCF2(AN, UP ,Q, UPQ)
    ifactor(p,l) == (fact(p pretend UP, l)) pretend Factored(SUP)
    factor p     == fact(p, allk coefficients p)
 
    factor(p, l) ==
      fact(p, allk removeDuplicates concat(l, coefficients p))
 
    split p ==
      fp := factor p
      unit(fp) *
            _*/[extend(fc.factor, fc.exponent) for fc in factors fp]
 
    extend(p, n) ==
--      one? degree p => primeFactor(p, n)
      (degree p = 1) => primeFactor(p, n)
      q := monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP
      primeFactor(q, n) * split((p exquo q)::UP) ** (n::N)
 
    doublyTransitive? p ==
      irred? p and irred?((p exquo
        (monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP))::UP)
 
    irred? p ==
      fp := factor p
--      one? numberOfFactors fp and one? nthExponent(fp, 1)
      (numberOfFactors fp = 1) and  (nthExponent(fp, 1) = 1)
 
    fact(p, l) ==
--      one? degree p => primeFactor(p, 1)
      (degree p = 1) => primeFactor(p, 1)
      empty? l =>
        dr := factor(downpoly p)$RationalFactorize(UPQ)
        (liftpoly unit dr) *
          _*/[primeFactor(liftpoly dc.factor,dc.exponent)
            for dc in factors dr]
      q   := minPoly(alpha := "max"/l)$AN
      newl  := remove(alpha = #1, l)
      --sae := SimpleAlgebraicExtension(AN, SUP, q)
      --ups := SparseUnivariatePolynomial sae

SparseUnivariatePolynomial(SimpleAlgebraicExtension(AN, SUP, q))


      fr  := factor(map(reduce univariate(#1, alpha, q),
                     p)$UPCF2(AN, UP, SimpleAlgebraicExtension(AN, SUP, q), SparseUnivariatePolynomial(SimpleAlgebraicExtension(AN, SUP, q))),
                      ifactor(#1, newl))$InnerAlgFactor(AN, SUP, SimpleAlgebraicExtension(AN, SUP, q), SparseUnivariatePolynomial(SimpleAlgebraicExtension(AN, SUP, q)))
      newalpha := alpha::AN
      map((lift(#1)$SimpleAlgebraicExtension(AN, SUP, q)) newalpha, unit fr)$UPCF2(SimpleAlgebraicExtension(AN, SUP, q), SparseUnivariatePolynomial(SimpleAlgebraicExtension(AN, SUP, q)), AN, UP) *
            _*/[primeFactor(map((lift(#1)$SimpleAlgebraicExtension(AN, SUP, q)) newalpha,
                      fc.factor)$UPCF2(SimpleAlgebraicExtension(AN, SUP, q), SparseUnivariatePolynomial(SimpleAlgebraicExtension(AN, SUP, q)), AN, UP),
                                 fc.exponent) for fc in factors fr]

