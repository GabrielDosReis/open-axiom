)abbrev category RPOLCAT RecursivePolynomialCategory
++ Author: Marc Moreno Maza
++ Date Created: 04/22/1994
++ Date Last Updated: 14/12/1998
++ Basic Functions: mvar, mdeg, init, head, tail, prem, lazyPrem
++ Related Constructors:
++ Also See: 
++ AMS Classifications:
++ Keywords: polynomial, multivariate, ordered variables set
++ References:
++ Description:
++ A category for general multi-variate polynomials with coefficients 
++ in a ring, variables in an ordered set, and exponents from an 
++ ordered abelian monoid, with a \axiomOp{sup} operation.
++ When not constant, such a polynomial is viewed as a univariate polynomial in its 
++ main variable w. r. t. to the total ordering on the elements in the ordered set, so that some
++ operations usually defined for univariate polynomials make sense here.

RecursivePolynomialCategory(R:Ring, E:OrderedAbelianMonoidSup, V:OrderedSet): Category == 
  PolynomialCategory(R, E, V) with
     mvar : $ -> V
         ++ \axiom{mvar(p)} returns an error if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns its main variable w. r. t. to the total ordering 
         ++ on the elements in \axiom{V}.
     mdeg  : $ -> NonNegativeInteger 
         ++ \axiom{mdeg(p)} returns an error if \axiom{p} is \axiom{0}, 
         ++ otherwise, if \axiom{p} belongs to \axiom{R} returns \axiom{0}, 
         ++ otherwise, returns the degree of \axiom{p} in its main variable.
     init : $ -> $
         ++ \axiom{init(p)} returns an error if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns its leading coefficient, where \axiom{p} is viewed 
         ++ as a univariate polynomial in its main variable.
     head  : $ -> $
         ++ \axiom{head(p)} returns \axiom{p} if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns its leading term (monomial in the AXIOM sense), 
         ++ where \axiom{p} is viewed as a univariate polynomial in its main variable.
     tail  : $ -> $
         ++ \axiom{tail(p)} returns its reductum, where \axiom{p} is viewed as a univariate
         ++ polynomial in its main variable.
     deepestTail : $ -> $
         ++ \axiom{deepestTail(p)} returns \axiom{0} if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns tail(p), if \axiom{tail(p)} belongs to  \axiom{R}
         ++ or \axiom{mvar(tail(p)) < mvar(p)}, otherwise returns \axiom{deepestTail(tail(p))}.
     iteratedInitials : $ -> List $ 
         ++ \axiom{iteratedInitials(p)} returns \axiom{[]} if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns the list of the iterated initials of \axiom{p}.
     deepestInitial : $ -> $ 
         ++ \axiom{deepestInitial(p)} returns an error if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns the last term of \axiom{iteratedInitials(p)}.
     leadingCoefficient : ($,V) -> $
         ++ \axiom{leadingCoefficient(p,v)} returns the leading coefficient of \axiom{p}, 
         ++ where \axiom{p} is viewed as A univariate polynomial in \axiom{v}.
     reductum  : ($,V) -> $
         ++ \axiom{reductum(p,v)} returns the reductum of \axiom{p}, where \axiom{p} is viewed as 
         ++ a univariate polynomial in \axiom{v}. 
     monic? : $ -> Boolean
         ++ \axiom{monic?(p)} returns false if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns true iff \axiom{p} is monic as a univariate polynomial 
         ++ in its main variable.
     quasiMonic? : $ -> Boolean
         ++ \axiom{quasiMonic?(p)} returns false if \axiom{p} belongs to \axiom{R}, 
         ++ otherwise returns true iff the initial of \axiom{p} lies in the base ring \axiom{R}.
     mainMonomial : $ -> $ 
         ++ \axiom{mainMonomial(p)} returns an error if \axiom{p} is \axiom{O}, 
         ++ otherwise, if \axiom{p} belongs to \axiom{R} returns \axiom{1},
         ++ otherwise, \axiom{mvar(p)} raised to the power \axiom{mdeg(p)}.
     leastMonomial : $ -> $ 
         ++ \axiom{leastMonomial(p)} returns an error if \axiom{p} is \axiom{O}, 
         ++ otherwise, if \axiom{p} belongs to \axiom{R} returns \axiom{1},
         ++ otherwise, the monomial of \axiom{p} with lowest degree, 
         ++ where \axiom{p} is viewed as a univariate polynomial in its main variable.
     mainCoefficients : $ -> List $ 
         ++ \axiom{mainCoefficients(p)} returns an error if \axiom{p} is \axiom{O}, 
         ++ otherwise, if \axiom{p} belongs to \axiom{R} returns [p], 
         ++ otherwise returns the list of the coefficients of \axiom{p}, 
         ++ where \axiom{p} is viewed as a univariate polynomial in its main variable.
     mainMonomials : $ -> List $ 
         ++ \axiom{mainMonomials(p)} returns an error if \axiom{p} is \axiom{O}, 
         ++ otherwise, if \axiom{p} belongs to \axiom{R} returns [1], 
         ++ otherwise returns the list of the monomials of \axiom{p}, 
         ++ where \axiom{p} is viewed as a univariate polynomial in its main variable.
     RittWuCompare : ($, $) -> Union(Boolean,"failed")
         ++ \axiom{RittWuCompare(a,b)} returns \axiom{"failed"} if \axiom{a} and \axiom{b} have same rank w.r.t. 
         ++ Ritt and Wu Wen Tsun ordering using the refinement of Lazard, 
         ++ otherwise returns \axiom{infRittWu?(a,b)}.
     infRittWu?  : ($, $) -> Boolean
         ++ \axiom{infRittWu?(a,b)} returns true if \axiom{a} is less than \axiom{b}
         ++ w.r.t. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.
     supRittWu? : ($, $) -> Boolean
         ++ \axiom{supRittWu?(a,b)} returns true if \axiom{a} is greater than \axiom{b}
         ++ w.r.t. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.
     reduced? : ($,$) -> Boolean
         ++ \axiom{reduced?(a,b)} returns true iff \axiom{degree(a,mvar(b)) < mdeg(b)}.
     reduced? : ($,List($)) -> Boolean
         ++ \axiom{reduced?(q,lp)} returns true iff \axiom{reduced?(q,p)} holds 
         ++ for every \axiom{p} in \axiom{lp}.
     headReduced? : ($,$) -> Boolean
         ++ \axiom{headReduced?(a,b)} returns true iff \axiom{degree(head(a),mvar(b)) < mdeg(b)}.
     headReduced? : ($,List($)) -> Boolean
         ++ \axiom{headReduced?(q,lp)} returns true iff \axiom{headReduced?(q,p)} holds 
         ++ for every \axiom{p} in \axiom{lp}.
     initiallyReduced? : ($,$) -> Boolean
         ++ \axiom{initiallyReduced?(a,b)} returns false iff there exists an iterated initial 
         ++ of \axiom{a} which is not reduced w.r.t \axiom{b}.
     initiallyReduced? :  ($,List($)) -> Boolean
         ++ \axiom{initiallyReduced?(q,lp)} returns true iff \axiom{initiallyReduced?(q,p)} holds
         ++ for every \axiom{p} in \axiom{lp}.
     normalized? : ($,$) -> Boolean
         ++ \axiom{normalized?(a,b)} returns true iff \axiom{a} and its iterated initials have
         ++ degree zero w.r.t. the main variable of \axiom{b}
     normalized? : ($,List($)) -> Boolean
         ++ \axiom{normalized?(q,lp)} returns true iff \axiom{normalized?(q,p)} holds 
         ++ for every \axiom{p} in \axiom{lp}.
     prem : ($, $) -> $
         ++ \axiom{prem(a,b)} computes the pseudo-remainder of \axiom{a} by \axiom{b}, 
         ++ both viewed as univariate polynomials in the main variable of \axiom{b}.
     pquo : ($, $) -> $
         ++ \axiom{pquo(a,b)} computes the pseudo-quotient of \axiom{a} by \axiom{b}, 
         ++ both viewed as univariate polynomials in the main variable of \axiom{b}.
     prem : ($, $, V) -> $
         ++ \axiom{prem(a,b,v)} computes the pseudo-remainder of \axiom{a} by \axiom{b}, 
         ++ both viewed as univariate polynomials in \axiom{v}.
     pquo : ($, $, V) -> $
         ++ \axiom{pquo(a,b,v)} computes the pseudo-quotient of \axiom{a} by \axiom{b}, 
         ++ both viewed as univariate polynomials in \axiom{v}.
     lazyPrem : ($, $) ->  $
         ++ \axiom{lazyPrem(a,b)} returns the polynomial \axiom{r} reduced w.r.t. \axiom{b} 
         ++ and such that \axiom{b} divides \axiom{init(b)^e a - r} where \axiom{e} 
         ++ is the number of steps of this pseudo-division.
     lazyPquo : ($, $) ->  $
         ++ \axiom{lazyPquo(a,b)} returns the polynomial \axiom{q} such that 
         ++ \axiom{lazyPseudoDivide(a,b)} returns \axiom{[c,g,q,r]}.
     lazyPrem : ($, $, V) -> $
         ++ \axiom{lazyPrem(a,b,v)} returns the polynomial \axiom{r} 
         ++ reduced w.r.t. \axiom{b} viewed as univariate polynomials in the variable 
         ++ \axiom{v} such that \axiom{b} divides \axiom{init(b)^e a - r}
         ++ where \axiom{e} is the number of steps of this pseudo-division.
     lazyPquo : ($, $, V) ->  $
         ++ \axiom{lazyPquo(a,b,v)} returns the polynomial \axiom{q} such that 
         ++ \axiom{lazyPseudoDivide(a,b,v)} returns \axiom{[c,g,q,r]}.
     lazyPremWithDefault : ($, $) ->  Record (coef : $, gap : NonNegativeInteger, remainder : $)
         ++ \axiom{lazyPremWithDefault(a,b)} returns \axiom{[c,g,r]}
         ++ such that \axiom{r = lazyPrem(a,b)} and \axiom{(c**g)*r = prem(a,b)}.
     lazyPremWithDefault : ($, $, V) ->  Record (coef : $, gap : NonNegativeInteger, remainder : $)
         ++ \axiom{lazyPremWithDefault(a,b,v)} returns \axiom{[c,g,r]} 
         ++ such that \axiom{r = lazyPrem(a,b,v)} and \axiom{(c**g)*r = prem(a,b,v)}.
     lazyPseudoDivide : ($,$) ->  Record(coef:$, gap: NonNegativeInteger,quotient:$, remainder:$)
         ++ \axiom{lazyPseudoDivide(a,b)} returns \axiom{[c,g,q,r]} 
         ++ such that \axiom{[c,g,r] = lazyPremWithDefault(a,b)} and
         ++ \axiom{q} is the pseudo-quotient computed in this lazy pseudo-division.
     lazyPseudoDivide : ($,$,V) ->  Record(coef:$, gap:NonNegativeInteger, quotient:$, remainder: $)
         ++ \axiom{lazyPseudoDivide(a,b,v)} returns \axiom{[c,g,q,r]} such that  
         ++ \axiom{r = lazyPrem(a,b,v)}, \axiom{(c**g)*r = prem(a,b,v)} and \axiom{q}
         ++ is the pseudo-quotient computed in this lazy pseudo-division.
     pseudoDivide : ($, $) -> Record (quotient : $, remainder : $)
         ++ \axiom{pseudoDivide(a,b)} computes \axiom{[pquo(a,b),prem(a,b)]}, both
         ++ polynomials viewed as univariate polynomials in the main variable of \axiom{b}, 
         ++ if \axiom{b} is not a constant polynomial.
     monicModulo : ($, $) -> $ 
         ++ \axiom{monicModulo(a,b)} computes \axiom{a mod b}, if \axiom{b} is 
         ++ monic as univariate polynomial in its main variable.
     lazyResidueClass : ($,$) -> Record(polnum:$, polden:$, power:NonNegativeInteger)
         ++ \axiom{lazyResidueClass(a,b)} returns \axiom{[p,q,n]} where \axiom{p / q**n} 
         ++ represents the residue class of \axiom{a} modulo \axiom{b} 
         ++ and \axiom{p} is reduced w.r.t. \axiom{b} and \axiom{q} is \axiom{init(b)}.
     headReduce: ($, $) ->  $
         ++ \axiom{headReduce(a,b)} returns a polynomial \axiom{r} such that 
         ++ \axiom{headReduced?(r,b)} holds and there exists an integer \axiom{e}
         ++ such that \axiom{init(b)^e a - r} is zero modulo \axiom{b}.
     initiallyReduce: ($, $) ->  $
         ++ \axiom{initiallyReduce(a,b)} returns a polynomial \axiom{r} such that 
         ++ \axiom{initiallyReduced?(r,b)} holds and there exists an integer \axiom{e}
         ++ such that \axiom{init(b)^e a - r} is zero modulo \axiom{b}.

     if (V has ConvertibleTo(Symbol))
     then 
       CoercibleTo(Polynomial R)
       ConvertibleTo(Polynomial R)
       if R has Algebra Fraction Integer
         then 
           retractIfCan : Polynomial Fraction Integer -> Union($,"failed")
               ++ \axiom{retractIfCan(p)} returns \axiom{p} as an element of the current domain
               ++ if all its variables belong to \axiom{V}.
           retract : Polynomial Fraction Integer -> $
               ++ \axiom{retract(p)} returns \axiom{p} as an element of the current domain
               ++ if \axiom{retractIfCan(p)} does not return "failed", otherwise an error 
               ++ is produced.
           convert : Polynomial Fraction Integer -> $
               ++ \axiom{convert(p)} returns the same as \axiom{retract(p)}.
           retractIfCan : Polynomial Integer -> Union($,"failed")
               ++ \axiom{retractIfCan(p)} returns \axiom{p} as an element of the current domain
               ++ if all its variables belong to \axiom{V}.
           retract : Polynomial Integer -> $
               ++ \axiom{retract(p)} returns \axiom{p} as an element of the current domain
               ++ if \axiom{retractIfCan(p)} does not return "failed", otherwise an error 
               ++ is produced.
           convert : Polynomial Integer -> $
               ++ \axiom{convert(p)} returns the same as \axiom{retract(p)}
           if not (R has QuotientFieldCategory(Integer))
             then
               retractIfCan : Polynomial R -> Union($,"failed")
                 ++ \axiom{retractIfCan(p)} returns \axiom{p} as an element of the current domain
                 ++ if all its variables belong to \axiom{V}.
               retract : Polynomial R -> $
                 ++ \axiom{retract(p)} returns \axiom{p} as an element of the current domain
                 ++ if \axiom{retractIfCan(p)} does not return "failed", otherwise an error 
                 ++ is produced.
       if (R has Algebra Integer) and not(R has Algebra Fraction Integer)
         then 
           retractIfCan : Polynomial Integer -> Union($,"failed")
               ++ \axiom{retractIfCan(p)} returns \axiom{p} as an element of the current domain
               ++ if all its variables belong to \axiom{V}.
           retract : Polynomial Integer -> $
               ++ \axiom{retract(p)} returns \axiom{p} as an element of the current domain
               ++ if \axiom{retractIfCan(p)} does not return "failed", otherwise an error 
               ++ is produced.
           convert : Polynomial Integer -> $
               ++ \axiom{convert(p)} returns the same as \axiom{retract(p)}.
           if not (R has IntegerNumberSystem)
             then
               retractIfCan : Polynomial R -> Union($,"failed")
                 ++ \axiom{retractIfCan(p)} returns \axiom{p} as an element of the current domain
                 ++ if all its variables belong to \axiom{V}.
               retract : Polynomial R -> $
                 ++ \axiom{retract(p)} returns \axiom{p} as an element of the current domain
                 ++ if \axiom{retractIfCan(p)} does not return "failed", otherwise an error 
                 ++ is produced.
       if not(R has Algebra Integer) and not(R has Algebra Fraction Integer)
         then 
           retractIfCan : Polynomial R -> Union($,"failed")
             ++ \axiom{retractIfCan(p)} returns \axiom{p} as an element of the current domain
             ++ if all its variables belong to \axiom{V}.
           retract : Polynomial R -> $
             ++ \axiom{retract(p)} returns \axiom{p} as an element of the current domain
             ++ if \axiom{retractIfCan(p)} does not return "failed", otherwise an error 
             ++ is produced.
       convert : Polynomial R -> $
         ++ \axiom{convert(p)} returns \axiom{p} as an element of the current domain if all 
         ++ its variables belong to \axiom{V}, otherwise an error is produced.

       if R has RetractableTo(Integer)
       then
         ConvertibleTo(String)

     if R has IntegralDomain
     then
       primPartElseUnitCanonical : $ -> $
           ++ \axiom{primPartElseUnitCanonical(p)} returns \axiom{primitivePart(p)}
           ++ if \axiom{R} is a gcd-domain, otherwise \axiom{unitCanonical(p)}.
       primPartElseUnitCanonical! : $ -> $
           ++ \axiom{primPartElseUnitCanonical!(p)} replaces  \axiom{p} 
           ++ by \axiom{primPartElseUnitCanonical(p)}.
       exactQuotient : ($,R) -> $
           ++ \axiom{exactQuotient(p,r)} computes the exact quotient of \axiom{p} 
           ++ by \axiom{r}, which is assumed to be a divisor of \axiom{p}. 
           ++ No error is returned if this exact quotient fails!
       exactQuotient! : ($,R) -> $
           ++ \axiom{exactQuotient!(p,r)} replaces \axiom{p} by \axiom{exactQuotient(p,r)}.
       exactQuotient : ($,$) -> $
           ++ \axiom{exactQuotient(a,b)} computes the exact quotient of \axiom{a} 
           ++ by \axiom{b}, which is assumed to be a divisor of \axiom{a}. 
           ++ No error is returned if this exact quotient fails!
       exactQuotient! : ($,$) -> $
           ++ \axiom{exactQuotient!(a,b)} replaces \axiom{a} by \axiom{exactQuotient(a,b)}
       subResultantGcd : ($, $) -> $ 
           ++ \axiom{subResultantGcd(a,b)} computes a gcd of \axiom{a} and \axiom{b} 
           ++ where \axiom{a} and \axiom{b} are assumed to have the same main variable \axiom{v}
           ++ and are viewed as univariate polynomials in \axiom{v} with coefficients
           ++ in the fraction field of the polynomial ring generated by their other variables 
           ++ over \axiom{R}.
       extendedSubResultantGcd : ($, $) -> Record (gcd : $, coef1 : $, coef2 : $)
           ++ \axiom{extendedSubResultantGcd(a,b)} returns \axiom{[ca,cb,r]} 
           ++ such that \axiom{r} is \axiom{subResultantGcd(a,b)} and we have
           ++ \axiom{ca * a + cb * cb = r} .
       halfExtendedSubResultantGcd1: ($, $) -> Record (gcd : $, coef1 : $)
           ++ \axiom{halfExtendedSubResultantGcd1(a,b)} returns \axiom{[g,ca]}
           ++ if \axiom{extendedSubResultantGcd(a,b)} returns \axiom{[g,ca,cb]}
           ++ otherwise produces an error.
       halfExtendedSubResultantGcd2: ($, $) -> Record (gcd : $, coef2 : $)
           ++ \axiom{halfExtendedSubResultantGcd2(a,b)} returns \axiom{[g,cb]}
           ++ if \axiom{extendedSubResultantGcd(a,b)} returns \axiom{[g,ca,cb]}
           ++ otherwise produces an error.
       resultant  : ($, $) -> $ 
           ++ \axiom{resultant(a,b)} computes the resultant of \axiom{a} and \axiom{b} 
           ++ where \axiom{a} and \axiom{b} are assumed to have the same main variable \axiom{v}
           ++ and are viewed as univariate polynomials in \axiom{v}.
       subResultantChain : ($, $) -> List $
           ++ \axiom{subResultantChain(a,b)}, where \axiom{a} and \axiom{b} are not 
           ++ contant polynomials with the same
           ++ main variable, returns the subresultant chain of \axiom{a} and \axiom{b}.
       lastSubResultant: ($, $) -> $
           ++ \axiom{lastSubResultant(a,b)} returns the last non-zero subresultant 
           ++ of \axiom{a} and \axiom{b} where \axiom{a} and \axiom{b} are assumed to have 
           ++ the same main variable \axiom{v} and are viewed as univariate polynomials in \axiom{v}.
       LazardQuotient: ($, $, NonNegativeInteger) -> $
           ++ \axiom{LazardQuotient(a,b,n)} returns \axiom{a**n exquo b**(n-1)}
           ++ assuming that this quotient does not fail.
       LazardQuotient2: ($, $, $, NonNegativeInteger) -> $
           ++ \axiom{LazardQuotient2(p,a,b,n)} returns 
           ++ \axiom{(a**(n-1) * p) exquo b**(n-1)}
           ++ assuming that this quotient does not fail.
       next_subResultant2: ($, $, $, $) -> $
           ++ \axiom{nextsubResultant2(p,q,z,s)} is the multivariate version
           ++ of the operation \axiomOpFrom{next_sousResultant2}{PseudoRemainderSequence} from
           ++ the \axiomType{PseudoRemainderSequence} constructor.

     if R has GcdDomain
     then
       gcd : (R,$) -> R
           ++ \axiom{gcd(r,p)} returns the gcd of \axiom{r} and the content of \axiom{p}.
       primitivePart! : $ -> $
           ++ \axiom{primitivePart!(p)} replaces \axiom{p}  by its primitive part.
       mainContent : $ -> $
           ++ \axiom{mainContent(p)} returns the content of \axiom{p} viewed as a univariate 
           ++ polynomial in its main variable and with coefficients in the 
           ++ polynomial ring generated by its other variables over \axiom{R}.
       mainPrimitivePart : $ -> $
           ++ \axiom{mainPrimitivePart(p)} returns the primitive part of \axiom{p} viewed as a
           ++ univariate polynomial in its main variable and with coefficients 
           ++ in the polynomial ring generated by its other variables over \axiom{R}.
       mainSquareFreePart : $ -> $
           ++ \axiom{mainSquareFreePart(p)} returns the square free part of \axiom{p} viewed as a 
           ++ univariate polynomial in its main variable and with coefficients 
           ++ in the polynomial ring generated by its other variables over \axiom{R}.

 add
     O ==> OutputForm
     NNI ==> NonNegativeInteger
     INT ==> Integer

     exactQuo : (R,R) -> R

     coerce(p:$):O ==
       ground? (p) => (ground(p))::O
--       if one?((ip := init(p)))
       if (((ip := init(p))) = 1)
         then
           if zero?((tp := tail(p)))
             then
--               if one?((dp := mdeg(p)))
               if (((dp := mdeg(p))) = 1)
                 then
                   return((mvar(p))::O)
                 else
                   return(((mvar(p))::O **$O (dp::O)))
             else
--               if one?((dp := mdeg(p)))
               if (((dp := mdeg(p))) = 1)
                 then
                   return((mvar(p))::O +$O (tp::O))
                 else
                   return(((mvar(p))::O **$O (dp::O)) +$O (tp::O))
          else
           if zero?((tp := tail(p)))
             then
--               if one?((dp := mdeg(p)))
               if (((dp := mdeg(p))) = 1)
                 then
                   return((ip::O) *$O  (mvar(p))::O)
                 else
                   return((ip::O) *$O ((mvar(p))::O **$O (dp::O)))
             else
--               if one?(mdeg(p))
               if ((mdeg(p)) = 1)
                 then
                   return(((ip::O) *$O  (mvar(p))::O) +$O (tp::O))
       ((ip)::O *$O ((mvar(p))::O **$O ((mdeg(p)::O))) +$O (tail(p)::O))

     mvar p ==
       ground?(p) => error"Error in mvar from RPOLCAT : #1 is constant."
       mainVariable(p)::V

     mdeg p == 
       ground?(p) => 0$NNI
       degree(p,mainVariable(p)::V)

     init p ==
       ground?(p) => error"Error in mvar from RPOLCAT : #1 is constant."
       v := mainVariable(p)::V
       coefficient(p,v,degree(p,v))

     leadingCoefficient (p,v) ==
       zero? (d := degree(p,v)) => p
       coefficient(p,v,d)

     head p ==
       ground? p => p
       v := mainVariable(p)::V
       d := degree(p,v)
       monomial(coefficient(p,v,d),v,d)

     reductum(p,v) ==
       zero? (d := degree(p,v)) => 0$$
       p - monomial(coefficient(p,v,d),v,d)

     tail p ==
       ground? p => 0$$
       p - head(p)

     deepestTail p ==
       ground? p => 0$$
       ground? tail(p) => tail(p)
       mvar(p) > mvar(tail(p)) => tail(p)
       deepestTail(tail(p))

     iteratedInitials p == 
       ground? p => []
       p := init(p)
       cons(p,iteratedInitials(p))

     localDeepestInitial (p : $) : $ == 
       ground? p => p
       localDeepestInitial init p

     deepestInitial p == 
       ground? p => error"Error in deepestInitial from RPOLCAT : #1 is constant."
       localDeepestInitial init p

     monic? p ==
       ground? p => false
       (recip(init(p))$$ case $)@Boolean

     quasiMonic?  p ==
       ground? p => false
       ground?(init(p))

     mainMonomial p == 
       zero? p => error"Error in mainMonomial from RPOLCAT : #1 is zero"
       ground? p => 1$$
       v := mainVariable(p)::V
       monomial(1$$,v,degree(p,v))

     leastMonomial p == 
       zero? p => error"Error in leastMonomial from RPOLCAT : #1 is zero"
       ground? p => 1$$
       v := mainVariable(p)::V
       monomial(1$$,v,minimumDegree(p,v))

     mainCoefficients p == 
       zero? p => error"Error in mainCoefficients from RPOLCAT : #1 is zero"
       ground? p => [p]
       v := mainVariable(p)::V
       coefficients(univariate(p,v)@SparseUnivariatePolynomial($))

     mainMonomials p == 
       zero? p => error"Error in mainMonomials from RPOLCAT : #1 is zero"
       ground? p => [1$$]
       v := mainVariable(p)::V
       lm := monomials(univariate(p,v)@SparseUnivariatePolynomial($))
       [monomial(1$$,v,degree(m)) for m in lm]

     RittWuCompare (a,b) ==
       (ground? b and  ground? a) => "failed"::Union(Boolean,"failed")
       ground? b => false::Union(Boolean,"failed")
       ground? a => true::Union(Boolean,"failed")
       mvar(a) < mvar(b) => true::Union(Boolean,"failed")
       mvar(a) > mvar(b) => false::Union(Boolean,"failed")
       mdeg(a) < mdeg(b) => true::Union(Boolean,"failed")
       mdeg(a) > mdeg(b) => false::Union(Boolean,"failed")
       lc := RittWuCompare(init(a),init(b))
       lc case Boolean => lc
       RittWuCompare(tail(a),tail(b))

     infRittWu? (a,b) ==
       lc : Union(Boolean,"failed") := RittWuCompare(a,b)
       lc case Boolean => lc::Boolean
       false
       
     supRittWu? (a,b) ==
       infRittWu? (b,a)

     prem (a:$, b:$)  : $ == 
       cP := lazyPremWithDefault (a,b)
       ((cP.coef) ** (cP.gap)) * cP.remainder

     pquo (a:$, b:$)  : $ == 
       cPS := lazyPseudoDivide (a,b)
       c := (cPS.coef) ** (cPS.gap)
       c * cPS.quotient

     prem (a:$, b:$, v:V) : $ ==
       cP := lazyPremWithDefault (a,b,v)
       ((cP.coef) ** (cP.gap)) * cP.remainder  

     pquo (a:$, b:$, v:V)  : $ == 
       cPS := lazyPseudoDivide (a,b,v)
       c := (cPS.coef) ** (cPS.gap)
       c * cPS.quotient     

     lazyPrem (a:$, b:$) : $ ==
       (not ground?(b)) and (monic?(b)) => monicModulo(a,b)
       (lazyPremWithDefault (a,b)).remainder
       
     lazyPquo (a:$, b:$) : $ ==
       (lazyPseudoDivide (a,b)).quotient

     lazyPrem (a:$, b:$, v:V) : $ ==
       zero? b =>  error"Error in lazyPrem : ($,$,V) -> $ from RPOLCAT : #2 is zero"
       ground?(b) => 0$$
       (v = mvar(b)) => lazyPrem(a,b)
       dbv : NNI := degree(b,v)
       zero? dbv => 0$$
       dav : NNI  := degree(a,v)
       zero? dav => a
       test : INT := dav::INT - dbv 
       lcbv : $ := leadingCoefficient(b,v)
       while not zero?(a) and not negative?(test) repeat
         lcav := leadingCoefficient(a,v)
         term := monomial(lcav,v,test::NNI)
         a := lcbv * a - term * b
         test := degree(a,v)::INT - dbv 
       a
         
     lazyPquo (a:$, b:$, v:V) : $ ==
       (lazyPseudoDivide (a,b,v)).quotient

     headReduce (a:$,b:$) == 
       ground? b => error"Error in headReduce : ($,$) -> Boolean from TSETCAT : #2 is constant"
       ground? a => a
       mvar(a) = mvar(b) => lazyPrem(a,b)
       while not reduced?((ha := head a),b) repeat
         lrc := lazyResidueClass(ha,b)
         if zero? tail(a)
           then
             a := lrc.polnum
           else
             a := lrc.polnum +  (lrc.polden)**(lrc.power) * tail(a)
       a

     initiallyReduce(a:$,b:$) ==
       ground? b => error"Error in initiallyReduce : ($,$) -> Boolean from TSETCAT : #2 is constant"
       ground? a => a
       v := mvar(b)
       mvar(a) = v => lazyPrem(a,b)
       ia := a
       ma := 1$$
       ta := 0$$
       while (not ground?(ia)) and (mvar(ia) >= mvar(b)) repeat
         if (mvar(ia) = mvar(b)) and (mdeg(ia) >= mdeg(b))
           then
             iamodb := lazyResidueClass(ia,b)
             ia := iamodb.polnum
             if not zero? ta
               then
                 ta :=  (iamodb.polden)**(iamodb.power) * ta
         if zero? ia 
           then 
             ia := ta
             ma := 1$$
             ta := 0$$
           else
             if not ground?(ia)
               then
                 ta := tail(ia) * ma + ta
                 ma := mainMonomial(ia) * ma
                 ia := init(ia)
       ia * ma + ta

     lazyPremWithDefault (a,b) == 
       ground?(b) => error"Error in lazyPremWithDefault from RPOLCAT : #2 is constant"
       ground?(a) => [1$$,0$NNI,a]
       xa := mvar a
       xb := mvar b
       xa < xb => [1$$,0$NNI,a]
       lcb : $ := init b 
       db : NNI := mdeg b
       test : INT := degree(a,xb)::INT - db
       delta : INT := max(test + 1$INT, 0$INT) 
       if xa = xb 
         then
           b := tail b
           while not zero?(a) and not negative?(test) repeat 
             term := monomial(init(a),xb,test::NNI)
             a := lcb * tail(a) - term * b 
             delta := delta - 1$INT 
             test := degree(a,xb)::INT - db
         else 
           while not zero?(a) and not negative?(test) repeat 
             term := monomial(leadingCoefficient(a,xb),xb,test::NNI)
             a := lcb * a - term * b
             delta := delta - 1$INT 
             test := degree(a,xb)::INT - db
       [lcb, (delta::NNI), a]

     lazyPremWithDefault (a,b,v) == 
       zero? b =>  error"Error in lazyPremWithDefault : ($,$,V) -> $ from RPOLCAT : #2 is zero"
       ground?(b) => [b,1$NNI,0$$]
       (v = mvar(b)) => lazyPremWithDefault(a,b)
       dbv : NNI := degree(b,v)
       zero? dbv => [b,1$NNI,0$$]
       dav : NNI  := degree(a,v)
       zero? dav => [1$$,0$NNI,a]
       test : INT := dav::INT - dbv 
       delta : INT := max(test + 1$INT, 0$INT) 
       lcbv : $ := leadingCoefficient(b,v)
       while not zero?(a) and not negative?(test) repeat
         lcav := leadingCoefficient(a,v)
         term := monomial(lcav,v,test::NNI)
         a := lcbv * a - term * b
         delta := delta - 1$INT 
         test := degree(a,v)::INT - dbv 
       [lcbv, (delta::NNI), a]

     pseudoDivide (a,b) == 
       cPS := lazyPseudoDivide (a,b)
       c := (cPS.coef) ** (cPS.gap)
       [c * cPS.quotient, c * cPS.remainder]

     lazyPseudoDivide (a,b) == 
       ground?(b) => error"Error in lazyPseudoDivide from RPOLCAT : #2 is constant"
       ground?(a) => [1$$,0$NNI,0$$,a]
       xa := mvar a 
       xb := mvar b
       xa < xb => [1$$,0$NNI,0$$, a]
       lcb : $ := init b 
       db : NNI := mdeg b
       q := 0$$
       test : INT := degree(a,xb)::INT - db
       delta : INT := max(test + 1$INT, 0$INT) 
       if xa = xb 
         then
           b := tail b
           while not zero?(a) and not negative?(test) repeat 
             term := monomial(init(a),xb,test::NNI)
             a := lcb * tail(a) - term * b 
             q := lcb * q + term
             delta := delta - 1$INT 
             test := degree(a,xb)::INT - db
         else 
           while not zero?(a) and not negative?(test) repeat 
             term := monomial(leadingCoefficient(a,xb),xb,test::NNI)
             a := lcb * a - term * b
             q := lcb * q + term
             delta := delta - 1$INT 
             test := degree(a,xb)::INT - db
       [lcb, (delta::NNI), q, a]

     lazyPseudoDivide (a,b,v) == 
       zero? b =>  error"Error in lazyPseudoDivide : ($,$,V) -> $ from RPOLCAT : #2 is zero"
       ground?(b) => [b,1$NNI,a,0$$]
       (v = mvar(b)) => lazyPseudoDivide(a,b)
       dbv : NNI := degree(b,v)
       zero? dbv => [b,1$NNI,a,0$$]
       dav : NNI  := degree(a,v)
       zero? dav => [1$$,0$NNI,0$$, a]
       test : INT := dav::INT - dbv 
       delta : INT := max(test + 1$INT, 0$INT) 
       lcbv : $ := leadingCoefficient(b,v)
       q := 0$$
       while not zero?(a) and not negative?(test) repeat
         lcav := leadingCoefficient(a,v)
         term := monomial(lcav,v,test::NNI)
         a := lcbv * a - term * b
         q := lcbv * q + term
         delta := delta - 1$INT 
         test := degree(a,v)::INT - dbv 
       [lcbv, (delta::NNI), q, a]

     monicModulo (a,b) == 
       ground?(b) => error"Error in monicModulo from RPOLCAT : #2 is constant"
       rec : Union($,"failed") 
       rec := recip((ib := init(b)))$$
       (rec case "failed")@Boolean => error"Error in monicModulo from RPOLCAT : #2 is not monic"
       ground? a => a
       ib * ((lazyPremWithDefault ((rec::$) * a,(rec::$) * b)).remainder)

     lazyResidueClass(a,b) ==
       zero? b => [a,1$$,0$NNI]
       ground? b => [0$$,1$$,0$NNI]
       ground? a => [a,1$$,0$NNI]
       xa := mvar a
       xb := mvar b
       xa < xb => [a,1$$,0$NNI]
       monic?(b) => [monicModulo(a,b),1$$,0$NNI]
       lcb : $ := init b 
       db : NNI := mdeg b
       test : INT := degree(a,xb)::INT - db
       pow : NNI := 0
       if xa = xb 
         then
           b := tail b
           while not zero?(a) and not negative?(test) repeat 
             term := monomial(init(a),xb,test::NNI)
             a := lcb * tail(a) - term * b 
             pow := pow + 1$NNI
             test := degree(a,xb)::INT - db
         else 
           while not zero?(a) and not negative?(test) repeat 
             term := monomial(leadingCoefficient(a,xb),xb,test::NNI)
             a := lcb * a - term * b
             pow := pow + 1$NNI
             test := degree(a,xb)::INT - db
       [a,lcb,pow]

     reduced? (a:$,b:$) : Boolean ==
       degree(a,mvar(b)) < mdeg(b)

     reduced? (p:$, lq : List($)) : Boolean ==
       ground? p => true
       while (not empty? lq) and (reduced?(p, first lq)) repeat
         lq := rest lq
       empty? lq

     headReduced? (a:$,b:$) : Boolean ==
       reduced?(head(a),b)

     headReduced? (p:$, lq : List($)) : Boolean ==
       reduced?(head(p),lq)

     initiallyReduced? (a:$,b:$) : Boolean ==
       ground? b => error"Error in initiallyReduced? : ($,$) -> Bool. from RPOLCAT : #2 is constant"
       ground?(a) => true
       mvar(a) < mvar(b) => true
       (mvar(a) = mvar(b)) => reduced?(a,b)
       initiallyReduced?(init(a),b)

     initiallyReduced? (p:$, lq : List($)) : Boolean ==
       ground? p => true
       while (not empty? lq) and (initiallyReduced?(p, first lq)) repeat
         lq := rest lq
       empty? lq

     normalized?(a:$,b:$) : Boolean ==
       ground? b => error"Error in  normalized? : ($,$) -> Boolean from TSETCAT : #2 is constant"
       ground? a => true
       mvar(a) < mvar(b) => true
       (mvar(a) = mvar(b)) => false
       normalized?(init(a),b)

     normalized? (p:$, lq : List($)) : Boolean ==
       while (not empty? lq) and (normalized?(p, first lq)) repeat
         lq := rest lq
       empty? lq       

     if R has IntegralDomain
     then

       if R has EuclideanDomain
         then
           exactQuo(r:R,s:R):R ==
             r quo$R s
         else
           exactQuo(r:R,s:R):R ==
             (r exquo$R s)::R

       exactQuotient (p:$,r:R) ==
         (p exquo$$ r)::$

       exactQuotient (a:$,b:$) ==
         ground? b => exactQuotient(a,ground(b))
         (a exquo$$ b)::$

       exactQuotient! (a:$,b:$) ==
         ground? b => exactQuotient!(a,ground(b))
         a := (a exquo$$ b)::$

       if (R has GcdDomain) and not(R has Field)
       then

         primPartElseUnitCanonical p ==
           primitivePart p

         primitivePart! p ==
           zero? p => p
--           if one?(cp := content(p))
           if ((cp := content(p)) = 1)
             then
               p := unitCanonical p
             else
               p := unitCanonical exactQuotient!(p,cp) 
           p

         primPartElseUnitCanonical! p ==
           primitivePart! p

       else
         primPartElseUnitCanonical p ==
           unitCanonical p

         primPartElseUnitCanonical! p ==
           p := unitCanonical p


     if R has GcdDomain
     then

       gcd(r:R,p:$):R ==
--         one? r => r
         (r = 1) => r
         zero? p => r
         ground? p => gcd(r,ground(p))$R
         gcd(gcd(r,init(p)),tail(p))

       mainContent p ==
         zero? p => p
         "gcd"/mainCoefficients(p)

       mainPrimitivePart p ==
         zero? p => p
         (unitNormal((p exquo$$ mainContent(p))::$)).canonical

       mainSquareFreePart p ==
         ground? p => p
         v := mainVariable(p)::V
         sfp : SparseUnivariatePolynomial($)
         sfp := squareFreePart(univariate(p,v)@SparseUnivariatePolynomial($))
         multivariate(sfp,v)

     if (V has ConvertibleTo(Symbol))
       then

         PR ==> Polynomial R
         PQ ==> Polynomial Fraction Integer
         PZ ==> Polynomial Integer
         IES ==> IndexedExponents(Symbol)
         Q ==> Fraction Integer
         Z ==> Integer

         convert(p:$) : PR ==
           ground? p => (ground(p)$$)::PR
           v : V := mvar(p)
           d : NNI := mdeg(p)
           convert(init(p))@PR *$PR ((convert(v)@Symbol)::PR)**d +$PR convert(tail(p))@PR

         coerce(p:$) : PR ==
           convert(p)@PR

         localRetract : PR -> $
         localRetractPQ : PQ -> $
         localRetractPZ : PZ -> $
         localRetractIfCan : PR -> Union($,"failed")
         localRetractIfCanPQ : PQ -> Union($,"failed")
         localRetractIfCanPZ : PZ -> Union($,"failed")

         if V has Finite
           then 

             sizeV : NNI := size()$V
             lv : List Symbol
             lv := [convert(index(i::PositiveInteger)$V)@Symbol for i in 1..sizeV]

             localRetract(p : PR) : $ ==
               ground? p => (ground(p)$PR)::$
               mvp : Symbol := (mainVariable(p)$PR)::Symbol
               d : NNI
               imvp : PositiveInteger := (position(mvp,lv)$(List Symbol))::PositiveInteger 
               vimvp : V := index(imvp)$V
               xvimvp,c : $ 
               newp := 0$$
               while (not zero? (d := degree(p,mvp))) repeat
                 c := localRetract(coefficient(p,mvp,d)$PR)
                 xvimvp := monomial(c,vimvp,d)$$
                 newp := newp +$$ xvimvp
                 p := p -$PR monomial(coefficient(p,mvp,d)$PR,mvp,d)$PR
               newp +$$ localRetract(p)

             if R has Algebra Fraction Integer
               then 
                 localRetractPQ(pq:PQ):$ ==
                   ground? pq => ((ground(pq)$PQ)::R)::$
                   mvp : Symbol := (mainVariable(pq)$PQ)::Symbol
                   d : NNI
                   imvp : PositiveInteger := (position(mvp,lv)$(List Symbol))::PositiveInteger 
                   vimvp : V := index(imvp)$V
                   xvimvp,c : $ 
                   newp := 0$$
                   while (not zero? (d := degree(pq,mvp))) repeat
                     c := localRetractPQ(coefficient(pq,mvp,d)$PQ)
                     xvimvp := monomial(c,vimvp,d)$$
                     newp := newp +$$ xvimvp
                     pq := pq -$PQ monomial(coefficient(pq,mvp,d)$PQ,mvp,d)$PQ
                   newp +$$ localRetractPQ(pq)

             if R has Algebra Integer
               then 
                 localRetractPZ(pz:PZ):$ ==
                   ground? pz => ((ground(pz)$PZ)::R)::$
                   mvp : Symbol := (mainVariable(pz)$PZ)::Symbol
                   d : NNI
                   imvp : PositiveInteger := (position(mvp,lv)$(List Symbol))::PositiveInteger 
                   vimvp : V := index(imvp)$V
                   xvimvp,c : $ 
                   newp := 0$$
                   while (not zero? (d := degree(pz,mvp))) repeat
                     c := localRetractPZ(coefficient(pz,mvp,d)$PZ)
                     xvimvp := monomial(c,vimvp,d)$$
                     newp := newp +$$ xvimvp
                     pz := pz -$PZ monomial(coefficient(pz,mvp,d)$PZ,mvp,d)$PZ
                   newp +$$ localRetractPZ(pz)

             retractable?(p:PR):Boolean ==
               lvp := variables(p)$PR
               while not empty? lvp and member?(first lvp,lv) repeat
                 lvp := rest lvp
               empty? lvp   
                     
             retractablePQ?(p:PQ):Boolean ==
               lvp := variables(p)$PQ
               while not empty? lvp and member?(first lvp,lv) repeat
                 lvp := rest lvp
               empty? lvp       
                 
             retractablePZ?(p:PZ):Boolean ==
               lvp := variables(p)$PZ
               while not empty? lvp and member?(first lvp,lv) repeat
                 lvp := rest lvp
               empty? lvp                        

             localRetractIfCan(p : PR): Union($,"failed") ==
               not retractable?(p) => "failed"::Union($,"failed")
               localRetract(p)::Union($,"failed")

             localRetractIfCanPQ(p : PQ): Union($,"failed") ==
               not retractablePQ?(p) => "failed"::Union($,"failed")
               localRetractPQ(p)::Union($,"failed")

             localRetractIfCanPZ(p : PZ): Union($,"failed") ==
               not retractablePZ?(p) => "failed"::Union($,"failed")
               localRetractPZ(p)::Union($,"failed")

         if R has Algebra Fraction Integer
           then 

             mpc2Z := MPolyCatFunctions2(Symbol,IES,IES,Z,R,PZ,PR)
             mpc2Q := MPolyCatFunctions2(Symbol,IES,IES,Q,R,PQ,PR)
             ZToR (z:Z):R == coerce(z)@R
             QToR (q:Q):R == coerce(q)@R
             PZToPR (pz:PZ):PR == map(ZToR,pz)$mpc2Z
             PQToPR (pq:PQ):PR == map(QToR,pq)$mpc2Q

             retract(pz:PZ) ==
               rif : Union($,"failed") := retractIfCan(pz)@Union($,"failed")
               (rif case "failed") => error"failed in retract: POLY Z -> $ from RPOLCAT"
               rif::$

             convert(pz:PZ) ==
               retract(pz)@$

             retract(pq:PQ) ==
               rif : Union($,"failed") := retractIfCan(pq)@Union($,"failed")
               (rif case "failed") => error"failed in retract: POLY Z -> $ from RPOLCAT"
               rif::$

             convert(pq:PQ) ==
               retract(pq)@$

             if not (R has QuotientFieldCategory(Integer))
               then
                 -- the only operation to implement is retractIfCan : PR -> Union($,"failed")
                 -- when V does not have Finite

                 if V has Finite
                   then
                     retractIfCan(pr:PR) ==
                       localRetractIfCan(pr)@Union($,"failed")

                     retractIfCan(pq:PQ) ==
                       localRetractIfCanPQ(pq)@Union($,"failed")
                   else
                     retractIfCan(pq:PQ) ==
                       pr : PR := PQToPR(pq)
                       retractIfCan(pr)@Union($,"failed")

                 retractIfCan(pz:PZ) ==
                   pr : PR := PZToPR(pz)
                   retractIfCan(pr)@Union($,"failed")

                 retract(pr:PR) ==
                   rif : Union($,"failed") := retractIfCan(pr)@Union($,"failed")
                   (rif case "failed") => error"failed in retract: POLY Z -> $ from RPOLCAT"
                   rif::$

                 convert(pr:PR) ==
                   retract(pr)@$

               else
                 -- the only operation to implement is retractIfCan : PQ -> Union($,"failed")
                 -- when V does not have Finite
                 mpc2ZQ := MPolyCatFunctions2(Symbol,IES,IES,Z,Q,PZ,PQ)
                 mpc2RQ := MPolyCatFunctions2(Symbol,IES,IES,R,Q,PR,PQ)
                 ZToQ(z:Z):Q == coerce(z)@Q
                 RToQ(r:R):Q == retract(r)@Q

                 PZToPQ (pz:PZ):PQ == map(ZToQ,pz)$mpc2ZQ
                 PRToPQ (pr:PR):PQ == map(RToQ,pr)$mpc2RQ

                 retractIfCan(pz:PZ) ==
                   pq : PQ := PZToPQ(pz)
                   retractIfCan(pq)@Union($,"failed")

                 if V has Finite
                   then
                     retractIfCan(pq:PQ) ==
                       localRetractIfCanPQ(pq)@Union($,"failed")

                     convert(pr:PR) ==
                       lrif : Union($,"failed") := localRetractIfCan(pr)@Union($,"failed")
                       (lrif case "failed") => error"failed in convert: PR->$ from RPOLCAT"
                       lrif::$
                   else
                     convert(pr:PR) ==
                       pq : PQ := PRToPQ(pr)
                       retract(pq)@$

         if (R has Algebra Integer) and not(R has Algebra Fraction Integer)
           then 

             mpc2Z := MPolyCatFunctions2(Symbol,IES,IES,Z,R,PZ,PR)
             ZToR (z:Z):R == coerce(z)@R
             PZToPR (pz:PZ):PR == map(ZToR,pz)$mpc2Z

             retract(pz:PZ) ==
               rif : Union($,"failed") := retractIfCan(pz)@Union($,"failed")
               (rif case "failed") => error"failed in retract: POLY Z -> $ from RPOLCAT"
               rif::$

             convert(pz:PZ) ==
               retract(pz)@$

             if not (R has IntegerNumberSystem)
               then
                 -- the only operation to implement is retractIfCan : PR -> Union($,"failed")
                 -- when V does not have Finite

                 if V has Finite
                   then
                     retractIfCan(pr:PR) ==
                       localRetractIfCan(pr)@Union($,"failed")

                     retractIfCan(pz:PZ) ==
                       localRetractIfCanPZ(pz)@Union($,"failed")
                   else
                     retractIfCan(pz:PZ) ==
                       pr : PR := PZToPR(pz)
                       retractIfCan(pr)@Union($,"failed")

                 retract(pr:PR) ==
                   rif : Union($,"failed") := retractIfCan(pr)@Union($,"failed")
                   (rif case "failed") => error"failed in retract: POLY Z -> $ from RPOLCAT"
                   rif::$

                 convert(pr:PR) ==
                   retract(pr)@$

               else
                 -- the only operation to implement is retractIfCan : PZ -> Union($,"failed")
                 -- when V does not have Finite

                 mpc2RZ := MPolyCatFunctions2(Symbol,IES,IES,R,Z,PR,PZ)
                 RToZ(r:R):Z == retract(r)@Z
                 PRToPZ (pr:PR):PZ == map(RToZ,pr)$mpc2RZ

                 if V has Finite
                   then
                     convert(pr:PR) ==
                       lrif : Union($,"failed") := localRetractIfCan(pr)@Union($,"failed")
                       (lrif case "failed") => error"failed in convert: PR->$ from RPOLCAT"
                       lrif::$
                     retractIfCan(pz:PZ) ==
                       localRetractIfCanPZ(pz)@Union($,"failed")
                   else
                     convert(pr:PR) ==
                       pz : PZ := PRToPZ(pr)
                       retract(pz)@$


         if not(R has Algebra Integer) and not(R has Algebra Fraction Integer)
           then 
             -- the only operation to implement is retractIfCan : PR -> Union($,"failed")

             if V has Finite
               then
                 retractIfCan(pr:PR) ==
                   localRetractIfCan(pr)@Union($,"failed")

             retract(pr:PR) ==
               rif : Union($,"failed") := retractIfCan(pr)@Union($,"failed")
               (rif case "failed") => error"failed in retract: POLY Z -> $ from RPOLCAT"
               rif::$

             convert(pr:PR) ==
               retract(pr)@$

         if (R has RetractableTo(INT))
           then

             convert(pol:$):String ==
               ground?(pol) => convert(retract(ground(pol))@INT)@String
               ipol : $ := init(pol)
               vpol : V := mvar(pol)
               dpol : NNI := mdeg(pol)
               tpol: $  := tail(pol)
               sipol,svpol,sdpol,stpol : String
--               if one? ipol
               if (ipol = 1)
                 then 
                   sipol := empty()$String
                 else
--                   if one?(-ipol)
                   if ((-ipol) = 1)
                     then 
                       sipol := "-"
                     else
                       sipol := convert(ipol)@String
                       if not monomial?(ipol)
                         then
                           sipol := concat(["(",sipol,")*"])$String
                         else 
                           sipol := concat(sipol,"*")$String
               svpol := string(convert(vpol)@Symbol)
--               if one? dpol
               if (dpol = 1)
                 then
                   sdpol :=  empty()$String
                 else
                   sdpol := concat("**",convert(convert(dpol)@INT)@String )$String 
               if zero? tpol
                 then
                   stpol :=  empty()$String
                 else
                   if ground?(tpol)
                     then
                       n := retract(ground(tpol))@INT
                       if n > 0
                         then
                           stpol :=  concat(" +",convert(n)@String)$String
                         else
                           stpol := convert(n)@String
                     else
                       stpol := convert(tpol)@String
                       if not member?((stpol.1)::String,["+","-"])$(List String)
                         then
                           stpol :=  concat(" + ",stpol)$String
               concat([sipol,svpol,sdpol,stpol])$String

