)abbrev domain EMR EuclideanModularRing
++ Description:
++ These domains are used for the factorization and gcds
++ of univariate polynomials over the integers in order to work modulo
++ different  primes.
++ See \spadtype{ModularRing}, \spadtype{ModularField}
EuclideanModularRing(S,R,Mod,reduction:(R,Mod) -> R,
                     merge:(Mod,Mod) -> Union(Mod,"failed"),
                      exactQuo : (R,R,Mod) -> Union(R,"failed")) : C == T
 where
  S    :  CommutativeRing
  R    :  UnivariatePolynomialCategory S
  Mod  :  AbelianMonoid

  C == EuclideanDomain with
                modulus :   %     -> Mod
                        ++ modulus(x) \undocumented
                coerce  :   %     -> R
                        ++ coerce(x) \undocumented
                reduce  : (R,Mod) -> %
                        ++ reduce(r,m) \undocumented
                exQuo   :  (%,%)  -> Union(%,"failed")
                        ++ exQuo(x,y) \undocumented
                recip   :    %    -> Union(%,"failed")
                        ++ recip(x) \undocumented
                inv     :    %    -> %
                        ++ inv(x) \undocumented
                elt     : (%, R)  -> R
                        ++ elt(x,r) or x.r \undocumented

  T == ModularRing(R,Mod,reduction,merge,exactQuo) add

    --representation
      Rep:= Record(val:R,modulo:Mod)
    --declarations
      x,y,z: %

      divide(x,y) ==
        t:=merge(x.modulo,y.modulo)
        t case "failed" => error "incompatible moduli"
        xm:=t::Mod
        yv:=y.val
        invlcy:R
--        if one? leadingCoefficient yv then invlcy:=1
        if (leadingCoefficient yv = 1) then invlcy:=1
        else
          invlcy:=(inv reduce((leadingCoefficient yv)::R,xm)).val
          yv:=reduction(invlcy*yv,xm)
        r:=monicDivide(x.val,yv)
        [reduce(invlcy*r.quotient,xm),reduce(r.remainder,xm)]

      if R has fmecg:(R,NonNegativeInteger,S,R)->R
         then x rem y  ==
           t:=merge(x.modulo,y.modulo)
           t case "failed" => error "incompatible moduli"
           xm:=t::Mod
           yv:=y.val
           invlcy:R
--           if not one? leadingCoefficient yv then
           if not (leadingCoefficient yv = 1) then
             invlcy:=((inv reduce((leadingCoefficient yv)::R,xm)).val)@R
             yv := reduction( (invlcy*yv)@R,xm)@R
           dy:=degree yv
           xv:=x.val
           while (d:=degree xv - dy)>=0 repeat
                 xv:= (reduction(fmecg(xv,d::NonNegativeInteger,leadingCoefficient xv,yv)::R,xm))@R
                 xv = 0 => return [xv,xm]$Rep
           [xv,xm]$Rep
         else x rem y  == 
           t:=merge(x.modulo,y.modulo)
           t case "failed" => error "incompatible moduli"
           xm:=t::Mod
           yv:=y.val
           invlcy:R
--           if not one? leadingCoefficient yv then
           if not (leadingCoefficient yv = 1) then
             invlcy:=(inv reduce((leadingCoefficient yv)::R,xm)).val
             yv:=reduction( (invlcy*yv)@R,xm)@R
           r:=monicDivide(x.val,yv)
           reduce(r.remainder,xm)

      euclideanSize x == degree x.val

      unitCanonical x ==
        zero? x => x
        degree(x.val) = 0 => 1
--        one? leadingCoefficient(x.val) => x
        (leadingCoefficient(x.val) = 1) => x
        invlcx:%:=inv reduce((leadingCoefficient(x.val))::R,x.modulo)
        invlcx * x

      unitNormal x ==
--        zero?(x) or one?(leadingCoefficient(x.val)) => [1, x, 1]
        zero?(x) or ((leadingCoefficient(x.val)) = 1) => [1, x, 1]
        lcx := reduce((leadingCoefficient(x.val))::R,x.modulo)
        invlcx:=inv lcx
        degree(x.val) = 0 => [lcx, 1, invlcx]
        [lcx, invlcx * x, invlcx]

      elt(x : %,s : R) : R == reduction(elt(x.val,s),x.modulo)

