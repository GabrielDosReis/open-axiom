import Boolean
import Symbol
import ConstructorCall
import List
import SExpression
)abbrev domain ELABEXPR ElaboratedExpression
++ Author: Gabriel Dos Reis
++ Date Created: January 19, 2008
++ Date Last Updated: January 20, 2008
++ Description: This domains an expresion as elaborated by the interpreter.
++ See Also: 
ElaboratedExpression(): Public == Private where
  Public ==> CoercibleTo OutputForm with
    type: % -> ConstructorCall
      ++ type(e) returns the type of the expression as computed by
      ++ the interpreter.
    constant?: % -> Boolean
      ++ constant?(e) returns true if `e' is a constant.
    getConstant: % -> Union(SExpression,"failed")
      ++ getConstant(e) retrieves the constant value of `e'e.
    variable?: % -> Boolean
      ++ variable?(e) returns true if `e' is a variable.
    getIdentifier: % -> Union(Symbol,"failed")
      ++ getIdentifier(e) retrieves the name of the variable `e'.
    callForm?: % -> Boolean
      ++ callForm?(e) is true when `e' is a call expression.
    getOperator: % -> Union(Symbol, "failed")
      ++ getOperator(e) retrieves the operator being invoked in `e',
      ++ when `e' is an expression.  
    getOperands: % -> Union(List %, "failed")
      ++ getOperands(e) returns the list of operands in `e', assuming it
      ++ is a call form.

  Private ==> add
    isAtomic(x: %): Boolean ==
      ATOM(x)$Lisp @ Boolean

    type x ==
      getMode(x)$Lisp @ ConstructorCall

    callForm? x ==
      CONSP(x)$Lisp @ Boolean

    getOperator x ==
      op: SExpression := getUnnameIfCan(x)$Lisp
      null? op => "failed"
      op pretend Symbol

    constant? x ==
      isAtomic x and 
        EQ(getUnnameIfCan(x)$Lisp, _$immediateDataSymbol$Lisp)$Lisp : Boolean

    getConstant x ==
      constant? x => getValue(x)$Lisp @ SExpression
      "failed"

    variable? x ==
      isAtomic x and not constant? x
   
    getIdentifier x ==
      variable? x => symbol (getUnname(x)$Lisp@SExpression)
      "failed"
