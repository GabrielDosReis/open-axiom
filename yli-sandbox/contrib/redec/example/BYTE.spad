import NonNegativeInteger
import OutputForm
)abbrev domain BYTE Byte
++ Author: Gabriel Dos Reis
++ Date Created: April 19, 2008
++ Date Last Updated: October 5, 2008
++ Basic Operations: byte, bitand, bitor, bitxor
++ Related Constructor: NonNegativeInteger
++ Description:
++   Byte is the datatype of 8-bit sized unsigned integer values.
Byte(): Public == Private where
  Public == Join(OrderedSet, CoercibleTo NonNegativeInteger,
              HomotopicTo Character) with
    byte: NonNegativeInteger -> %
      ++ byte(x) injects the unsigned integer value `v' into
      ++ the Byte algebra.  `v' must be non-negative and less than 256.
    coerce: NonNegativeInteger -> %
      ++ coerce(x) has the same effect as byte(x).
    bitand: (%,%) -> %
      ++ bitand(x,y) returns the bitwise `and' of `x' and `y'.
    bitior: (%,%) -> %
      ++ bitor(x,y) returns the bitwise `inclusive or' of `x' and `y'.
    sample: () -> %
      ++ sample() returns a sample datum of type Byte.
  Private == add
    byte(x: NonNegativeInteger): % ==
      not (x < 256$Lisp) => 
        userError "integer value cannot be represented by a byte"
      x : %
    sample() = 0$Lisp
    hash x == SXHASH(x)$Lisp

    coerce(x: NonNegativeInteger): % == byte x
    coerce(x: %): NonNegativeInteger == x : NonNegativeInteger

    coerce(c: Character) == ord(c)::%
    coerce(x: %): Character == char(x::NonNegativeInteger)

    coerce(x: %): OutputForm ==
      x::NonNegativeInteger::OutputForm
    
    x = y == byteEqual(x,y)$Lisp
    x < y ==  byteLessThan(x,y)$Lisp

    bitand(x,y) == bitand(x,y)$Lisp
    bitior(x,y) == bitior(x,y)$Lisp
