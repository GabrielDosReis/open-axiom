)abbrev domain GMODPOL GeneralModulePolynomial
++ Description:
++ This package \undocumented
GeneralModulePolynomial(vl, R, IS, E, ff, P): public  ==  private where
  vl: List(Symbol)
  R: CommutativeRing
  IS: OrderedSet
  NNI ==> NonNegativeInteger
  E: DirectProductCategory(#vl, NNI)
  MM ==> Record(index:IS, exponent:E)
  ff: (MM, MM) -> Boolean
  OV  ==> OrderedVariableList(vl)
  P: PolynomialCategory(R, E, OV)
  ModMonom ==> ModuleMonomial(IS, E, ff)


  public  ==  Join(Module(P), Module(R))  with
        leadingCoefficient: $ -> R
                ++ leadingCoefficient(x) \undocumented
        leadingMonomial: $ -> ModMonom
                ++ leadingMonomial(x) \undocumented
        leadingExponent: $ -> E
                ++ leadingExponent(x) \undocumented
        leadingIndex: $ -> IS
                ++ leadingIndex(x) \undocumented
        reductum: $ -> $
                ++ reductum(x) \undocumented
        monomial: (R, ModMonom) -> $
                ++ monomial(r,x) \undocumented
        unitVector: IS -> $
                ++ unitVector(x) \undocumented
        build: (R, IS, E) -> $
                ++ build(r,i,e) \undocumented
        multMonom: (R, E, $) -> $
                ++ multMonom(r,e,x) \undocumented
        "*": (P,$) -> $
                ++ p*x \undocumented


  private  ==  FreeModule(R, ModMonom)  add
        Rep:= FreeModule(R, ModMonom)
        leadingMonomial(p:$):ModMonom == leadingSupport(p)$Rep
        leadingExponent(p:$):E == exponent(leadingMonomial p)
        leadingIndex(p:$):IS == index(leadingMonomial p)
        unitVector(i:IS):$ == monomial(1,[i, 0$E]$ModMonom)


 -----------------------------------------------------------------------------

        build(c:R, i:IS, e:E):$  ==  monomial(c, construct(i, e))

 -----------------------------------------------------------------------------

     ----   WARNING: assumes c ~= 0

        multMonom(c:R, e:E, mp:$):$  ==
            zero? mp => mp
            monomial(c * leadingCoefficient mp, [leadingIndex mp,
                     e + leadingExponent mp]) + multMonom(c, e, reductum mp)

 -----------------------------------------------------------------------------


        ((p:P) * (mp:$)):$  ==
            zero? p => 0
            multMonom(leadingCoefficient p, degree p, mp) +
               reductum(p) * mp

