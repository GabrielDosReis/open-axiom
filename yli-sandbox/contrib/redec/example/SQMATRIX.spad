)abbrev domain SQMATRIX SquareMatrix
++ Author: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Date Last Updated: July 1990
++ Basic Operations:
++ Related Domains: IndexedMatrix, Matrix, RectangularMatrix
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{SquareMatrix} is a matrix domain of square matrices, where the
++   number of rows (= number of columns) is a parameter of the type.
SquareMatrix(ndim,R): Exports == Implementation where
  ndim : NonNegativeInteger
  R    : Ring
  Row ==> DirectProduct(ndim,R)
  Col ==> DirectProduct(ndim,R)
  MATLIN ==> MatrixLinearAlgebraFunctions(R,Row,Col,$)
 
  Exports ==> Join(SquareMatrixCategory(ndim,R,Row,Col),_
                   CoercibleTo Matrix R) with

    new: R -> %
      ++ \spad{new(c)} constructs a new \spadtype{SquareMatrix}
      ++ object of dimension  \spad{ndim} with initial entries equal
      ++ to \spad{c}. 
    transpose: $ -> $
      ++ \spad{transpose(m)} returns the transpose of the matrix m.
    squareMatrix: Matrix R -> $
      ++ \spad{squareMatrix(m)} converts a matrix of type \spadtype{Matrix}
      ++ to a matrix of type \spadtype{SquareMatrix}.
--  symdecomp : $ -> Record(sym:$,antisym:$)
--    ++ \spad{symdecomp(m)} decomposes the matrix m as a sum of a symmetric
--    ++ matrix \spad{m1} and an antisymmetric matrix \spad{m2}. The object
--    ++ returned is the Record \spad{[m1,m2]}
--  if R has commutative("*") then
--    minorsVect: -> Vector(Union(R,"uncomputed")) --range: 1..2**n-1
--      ++ \spad{minorsVect(m)} returns a vector of the minors of the matrix m
    if R has commutative("*") then central
      ++ the elements of the Ring R, viewed as diagonal matrices, commute
      ++ with all matrices and, indeed, are the only matrices which commute
      ++ with all matrices.
    if R has commutative("*") and R has unitsKnown then unitsKnown
      ++ the invertible matrices are simply the matrices whose determinants
      ++ are units in the Ring R.
    if R has ConvertibleTo InputForm then ConvertibleTo InputForm
 
  Implementation ==> Matrix R add
    Rep == Matrix R
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex
    mini ==> minIndex
    maxi ==> maxIndex
 
    ZERO := scalarMatrix(0$R)
    0    == ZERO
    ONE  := scalarMatrix(1$R)
    1    == ONE

    characteristic() == characteristic()$R

    new c == per new(ndim,ndim,c)$Rep
 
    matrix(l: List List R) ==
      -- error check: this is a top level function
      #l ~= ndim => error "matrix: wrong number of rows"
      for ll in l repeat
        #ll ~= ndim => error "matrix: wrong number of columns"
      ans := new(ndim,ndim,0)$Rep
      for i in minr(ans)..maxr(ans) for ll in l repeat
        for j in minc(ans)..maxc(ans) for r in ll repeat
          qsetelt!(ans,i,j,r)
      per ans
 
    row(x,i)    == directProduct row(rep x,i)
    column(x,j) == directProduct column(rep x,j)
    coerce(x:$):OutputForm == rep(x)::OutputForm
 
    scalarMatrix r == per scalarMatrix(ndim,r)$Matrix(R)
 
    diagonalMatrix l ==
      #l ~= ndim =>
        error "diagonalMatrix: wrong number of entries in list"
      per diagonalMatrix(l)$Matrix(R)
 
    coerce(x: %): Matrix(R) == copy rep x
 
    squareMatrix x ==
      (nrows(x) ~= ndim) or (ncols(x) ~= ndim) =>
        error "squareMatrix: matrix of bad dimensions"
      per copy x
 
    x:% * v:Col ==
      directProduct(rep(x) * (v :: Vector(R)))
 
    v:Row * x:$ ==
      directProduct((v :: Vector(R)) * rep(x))
 
    x:$ ** n:NonNegativeInteger ==
      per(rep(x) ** n)
 
    if R has commutative("*") then
 
      determinant x == determinant rep x
      minordet x    == minordet rep x
 
    if R has EuclideanDomain then
 
      rowEchelon x == per rowEchelon rep x
 
    if R has IntegralDomain then
 
      rank x    == rank rep x
      nullity x == nullity rep x
      nullSpace x ==
        [directProduct c for c in nullSpace rep x]
 
    if R has Field then
 
      dimension(): CardinalNumber == (m * n) :: CardinalNumber
 
      inverse x ==
        (u := inverse rep x) case "failed" => "failed"
        per(u :: Matrix(R))
 
      x:$ ** n:Integer ==
        per(rep(x) ** n)
 
      recip x == inverse x
 
    if R has ConvertibleTo InputForm then
      convert(x:$):InputForm ==
         convert [convert("squareMatrix"::Symbol)@InputForm,
                  convert(rep x)@InputForm]$List(InputForm)


