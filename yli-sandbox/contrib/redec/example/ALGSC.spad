)abbrev domain ALGSC AlgebraGivenByStructuralConstants
++ Authors: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 22 January 1992
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: algebra, structural constants
++ Reference:
++  R.D. Schafer: An Introduction to Nonassociative Algebras
++  Academic Press, New York, 1966
++ Description:
++  AlgebraGivenByStructuralConstants implements finite rank algebras
++  over a commutative ring, given by the structural constants \spad{gamma}
++  with respect to a fixed  basis \spad{[a1,..,an]}, where
++  \spad{gamma} is an \spad{n}-vector of n by n matrices
++  \spad{[(gammaijk) for k in 1..rank()]} defined by
++  \spad{ai * aj = gammaij1 * a1 + ... + gammaijn * an}.
++  The symbols for the fixed basis
++  have to be given as a list of symbols.
AlgebraGivenByStructuralConstants(R:Field, n : PositiveInteger,_
  ls : List Symbol, gamma: Vector Matrix R ): public == private where

  V  ==> Vector
  M  ==> Matrix
  I  ==> Integer
  NNI  ==> NonNegativeInteger
  REC  ==> Record(particular: Union(V R,"failed"),basis: List V R)
  LSMP ==> LinearSystemMatrixPackage(R,V R,V R, M R)

  --public ==> FramedNonAssociativeAlgebra(R) with
  public ==> Join(FramedNonAssociativeAlgebra(R), _
    LeftModule(SquareMatrix(n,R)) ) with

    coerce : Vector R -> %
      ++ coerce(v) converts a vector to a member of the algebra
      ++ by forming a linear combination with the basis element.
      ++ Note: the vector is assumed to have length equal to the
      ++ dimension of the algebra.

  private ==> DirectProduct(n,R) add

    Rep := DirectProduct(n,R)

    x,y : %
    dp : DirectProduct(n,R)
    v : V R


    recip(x) == recip(x)$FiniteRankNonAssociativeAlgebra_&(%,R)

    (m:SquareMatrix(n,R))*(x:%) == apply((m :: Matrix R),x)
    coerce v == directProduct(v) :: %

    structuralConstants() == gamma

    coordinates(x) == vector(entries(x :: Rep)$Rep)$Vector(R)

    coordinates(x,b) ==
      --not (maxIndex b = n) =>
      --  error("coordinates: your 'basis' has not the right length")
      m : NonNegativeInteger := (maxIndex b) :: NonNegativeInteger
      transitionMatrix   : Matrix R := new(n,m,0$R)$Matrix(R)
      for i in 1..m repeat
        setColumn_!(transitionMatrix,i,coordinates(b.i))
      res : REC := solve(transitionMatrix,coordinates(x))$LSMP
      if (not every?(zero?$R,first res.basis)) then
        error("coordinates: warning your 'basis' is linearly dependent")
      (res.particular  case "failed") =>
        error("coordinates: first argument is not in linear span of second argument")
      (res.particular) :: (Vector R)

    basis() == [unitVector(i::PositiveInteger)::% for i in 1..n]

    someBasis() == basis()$%

    rank() == n

    elt(x,i) == elt(x:Rep,i)$Rep

    coerce(x:%):OutputForm ==
      zero?(x::Rep)$Rep => (0$R) :: OutputForm
      le : List OutputForm := nil
      for i in 1..n repeat
        coef : R := elt(x::Rep,i)
        not zero?(coef)$R =>
--          one?(coef)$R =>
          ((coef) = 1)$R =>
            -- sy : OutputForm := elt(ls,i)$(List Symbol) :: OutputForm
            le := cons(elt(ls,i)$(List Symbol) :: OutputForm, le)
          le := cons(coef :: OutputForm *  elt(ls,i)$(List Symbol)_
              :: OutputForm, le)
      reduce("+",le)

    x * y ==
      v : Vector R :=  new(n,0$R)
      for k in 1..n repeat
        h : R := 0
        for i in 1..n repeat
          for j in 1..n repeat
            h := h  +$R elt(x,i) *$R elt(y,j) *$R elt(gamma.k,i,j )
        v.k := h
      per(directProduct(v)$DirectProduct(n, R))


    alternative?() ==
      for i in 1..n repeat
        -- expression for check of left alternative is symmetric in i and j:
        -- expression for check of right alternative is symmetric in j and k:
        for j in 1..i-1 repeat
          for k in j..n repeat
            -- right check
            for r in 1..n repeat
              res := 0$R
              for l in 1..n repeat
                res := res - _
                  (elt(gamma.l,j,k)+elt(gamma.l,k,j))*elt(gamma.r,i,l)+_
                  (elt(gamma.l,i,j)*elt(gamma.r,l,k) + elt(gamma.l,i,k)*_
                  elt(gamma.r,l,j) )
              not zero? res =>
                messagePrint("algebra is not right alternative")$OutputForm
                return false
        for j in i..n repeat
          for k in 1..j-1 repeat
            -- left check
            for r in 1..n repeat
              res := 0$R
              for l in 1..n repeat
                res := res + _
                  (elt(gamma.l,i,j)+elt(gamma.l,j,i))*elt(gamma.r,l,k)-_
                  (elt(gamma.l,j,k)*elt(gamma.r,i,l) + elt(gamma.l,i,k)*_
                   elt(gamma.r,j,l) )
              not (zero? res) =>
                messagePrint("algebra is not left alternative")$OutputForm
                return false

          for k in j..n repeat
            -- left check
            for r in 1..n repeat
              res := 0$R
              for l in 1..n repeat
                res := res + _
                  (elt(gamma.l,i,j)+elt(gamma.l,j,i))*elt(gamma.r,l,k)-_
                  (elt(gamma.l,j,k)*elt(gamma.r,i,l) + elt(gamma.l,i,k)*_
                   elt(gamma.r,j,l) )
              not (zero? res) =>
                messagePrint("algebra is not left alternative")$OutputForm
                return false
            -- right check
            for r in 1..n repeat
              res := 0$R
              for l in 1..n repeat
                res := res - _
                  (elt(gamma.l,j,k)+elt(gamma.l,k,j))*elt(gamma.r,i,l)+_
                  (elt(gamma.l,i,j)*elt(gamma.r,l,k) + elt(gamma.l,i,k)*_
                  elt(gamma.r,l,j) )
              not (zero? res) =>
                messagePrint("algebra is not right alternative")$OutputForm
                return false

      messagePrint("algebra satisfies 2*associator(a,b,b) = 0 = 2*associator(a,a,b) = 0")$OutputForm
      true

    -- should be in the category, but is not exported
--    conditionsForIdempotents b  ==
--      n := rank()
--      --gamma : Vector Matrix R := structuralConstants b
--      listOfNumbers : List String :=  [STRINGIMAGE(q)$Lisp for q in 1..n]
--      symbolsForCoef : Vector Symbol :=
--        [concat("%", concat("x", i))::Symbol  for i in listOfNumbers]
--      conditions : List Polynomial R := []
 --     for k in 1..n repeat
 --       xk := symbolsForCoef.k
 --       p : Polynomial R :=  monomial( - 1$Polynomial(R), [xk], [1] )
 --       for i in 1..n repeat
 --         for j in 1..n repeat
 --           xi := symbolsForCoef.i
 --           xj := symbolsForCoef.j
 --           p := p + monomial(_
 --             elt((gamma.k),i,j) :: Polynomial(R), [xi,xj], [1,1])
 --       conditions := cons(p,conditions)
 --     conditions

    associative?() ==
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for r in 1..n repeat
           res := 0$R
           for l in 1..n repeat
             res := res + elt(gamma.l,i,j)*elt(gamma.r,l,k)-_
                          elt(gamma.l,j,k)*elt(gamma.r,i,l)
           not (zero? res) =>
            messagePrint("algebra is not associative")$OutputForm
            return false
      messagePrint("algebra is associative")$OutputForm
      true


    antiAssociative?() ==
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for r in 1..n repeat
           res := 0$R
           for l in 1..n repeat
             res := res + elt(gamma.l,i,j)*elt(gamma.r,l,k)+_
                          elt(gamma.l,j,k)*elt(gamma.r,i,l)
           not (zero? res) =>
            messagePrint("algebra is not anti-associative")$OutputForm
            return false
      messagePrint("algebra is anti-associative")$OutputForm
      true

    commutative?() ==
      for i in 1..n repeat
       for j in (i+1)..n repeat
        for k in 1..n repeat
           not ( elt(gamma.k,i,j)=elt(gamma.k,j,i) ) =>
            messagePrint("algebra is not commutative")$OutputForm
            return false
      messagePrint("algebra is commutative")$OutputForm
      true

    antiCommutative?() ==
      for i in 1..n repeat
       for j in i..n repeat
        for k in 1..n repeat
          not zero? (i=j => elt(gamma.k,i,i); elt(gamma.k,i,j)+elt(gamma.k,j,i) ) =>
            messagePrint("algebra is not anti-commutative")$OutputForm
            return false
      messagePrint("algebra is anti-commutative")$OutputForm
      true

    leftAlternative?() ==
      for i in 1..n repeat
       -- expression is symmetric in i and j:
       for j in i..n repeat
        for k in 1..n repeat
         for r in 1..n repeat
           res := 0$R
           for l in 1..n repeat
             res := res + (elt(gamma.l,i,j)+elt(gamma.l,j,i))*elt(gamma.r,l,k)-_
               (elt(gamma.l,j,k)*elt(gamma.r,i,l) + elt(gamma.l,i,k)*elt(gamma.r,j,l) )
           not (zero? res) =>
            messagePrint("algebra is not left alternative")$OutputForm
            return false
      messagePrint("algebra is left alternative")$OutputForm
      true


    rightAlternative?() ==
      for i in 1..n repeat
       for j in 1..n repeat
       -- expression is symmetric in j and k:
        for k in j..n repeat
         for r in 1..n repeat
           res := 0$R
           for l in 1..n repeat
             res := res - (elt(gamma.l,j,k)+elt(gamma.l,k,j))*elt(gamma.r,i,l)+_
               (elt(gamma.l,i,j)*elt(gamma.r,l,k) + elt(gamma.l,i,k)*elt(gamma.r,l,j) )
           not (zero? res) =>
            messagePrint("algebra is not right alternative")$OutputForm
            return false
      messagePrint("algebra is right alternative")$OutputForm
      true


    flexible?() ==
      for i in 1..n repeat
       for j in 1..n repeat
       -- expression is symmetric in i and k:
        for k in i..n repeat
         for r in 1..n repeat
           res := 0$R
           for l in 1..n repeat
             res := res + elt(gamma.l,i,j)*elt(gamma.r,l,k)-_
                          elt(gamma.l,j,k)*elt(gamma.r,i,l)+_
                          elt(gamma.l,k,j)*elt(gamma.r,l,i)-_
                          elt(gamma.l,j,i)*elt(gamma.r,k,l)
           not (zero? res) =>
            messagePrint("algebra is not flexible")$OutputForm
            return false
      messagePrint("algebra is flexible")$OutputForm
      true

    lieAdmissible?() ==
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for r in 1..n repeat
           res := 0$R
           for l in 1..n repeat
             res := res_
              + (elt(gamma.l,i,j)-elt(gamma.l,j,i))*(elt(gamma.r,l,k)-elt(gamma.r,k,l)) _
              + (elt(gamma.l,j,k)-elt(gamma.l,k,j))*(elt(gamma.r,l,i)-elt(gamma.r,i,l)) _
              + (elt(gamma.l,k,i)-elt(gamma.l,i,k))*(elt(gamma.r,l,j)-elt(gamma.r,j,l))
           not (zero? res) =>
            messagePrint("algebra is not Lie admissible")$OutputForm
            return false
      messagePrint("algebra is Lie admissible")$OutputForm
      true

    jordanAdmissible?()  ==
      recip(2 * 1$R) case "failed" =>
        messagePrint("this algebra is not Jordan admissible, as 2 is not invertible in the ground ring")$OutputForm
        false
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for w in 1..n repeat
          for t in 1..n repeat
           res := 0$R
           for l in 1..n repeat
            for r in 1..n repeat
             res := res_
              + (elt(gamma.l,i,j)+elt(gamma.l,j,i))_
                * (elt(gamma.r,w,k)+elt(gamma.r,k,w))_
                * (elt(gamma.t,l,r)+elt(gamma.t,r,l))_
              - (elt(gamma.r,w,k)+elt(gamma.r,k,w))_
                * (elt(gamma.l,j,r)+elt(gamma.l,r,j))_
                * (elt(gamma.t,i,l)+elt(gamma.t,l,i))_
              + (elt(gamma.l,w,j)+elt(gamma.l,j,w))_
                * (elt(gamma.r,k,i)+elt(gamma.r,i,k))_
                * (elt(gamma.t,l,r)+elt(gamma.t,r,l))_
              - (elt(gamma.r,k,i)+elt(gamma.r,k,i))_
                * (elt(gamma.l,j,r)+elt(gamma.l,r,j))_
                * (elt(gamma.t,w,l)+elt(gamma.t,l,w))_
              + (elt(gamma.l,k,j)+elt(gamma.l,j,k))_
                * (elt(gamma.r,i,w)+elt(gamma.r,w,i))_
                * (elt(gamma.t,l,r)+elt(gamma.t,r,l))_
              - (elt(gamma.r,i,w)+elt(gamma.r,w,i))_
                * (elt(gamma.l,j,r)+elt(gamma.l,r,j))_
                * (elt(gamma.t,k,l)+elt(gamma.t,l,k))
           not (zero? res) =>
             messagePrint("algebra is not Jordan admissible")$OutputForm
             return false
      messagePrint("algebra is Jordan admissible")$OutputForm
      true

    jordanAlgebra?()  ==
      recip(2 * 1$R) case "failed" =>
        messagePrint("this is not a Jordan algebra, as 2 is not invertible in the ground ring")$OutputForm
        false
      not commutative?() =>
        messagePrint("this is not a Jordan algebra")$OutputForm
        false
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for l in 1..n repeat
           for t in 1..n repeat
             res := 0$R
             for r in 1..n repeat
               for s in 1..n repeat
                 res := res +  _
                   elt(gamma.r,i,j)*elt(gamma.s,l,k)*elt(gamma.t,r,s) - _
                   elt(gamma.r,l,k)*elt(gamma.s,j,r)*elt(gamma.t,i,s) + _
                   elt(gamma.r,l,j)*elt(gamma.s,k,k)*elt(gamma.t,r,s) - _
                   elt(gamma.r,k,i)*elt(gamma.s,j,r)*elt(gamma.t,l,s) + _
                   elt(gamma.r,k,j)*elt(gamma.s,i,k)*elt(gamma.t,r,s) - _
                   elt(gamma.r,i,l)*elt(gamma.s,j,r)*elt(gamma.t,k,s)
                 not zero? res =>
                   messagePrint("this is not a Jordan algebra")$OutputForm
                   return false
      messagePrint("this is a Jordan algebra")$OutputForm
      true


    jacobiIdentity?()  ==
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for r in 1..n repeat
           res := 0$R
           for s in 1..n repeat
                 res := res +  elt(gamma.r,i,j)*elt(gamma.s,j,k) +_
                               elt(gamma.r,j,k)*elt(gamma.s,k,i) +_
                               elt(gamma.r,k,i)*elt(gamma.s,i,j)
           not zero? res =>
                 messagePrint("Jacobi identity does not hold")$OutputForm
                 return false
      messagePrint("Jacobi identity holds")$OutputForm
      true

