)abbrev domain FNLA FreeNilpotentLie
++ Author: Larry Lambe
++ Date Created: July 1988
++ Date Last Updated: March 13 1991
++ Related Constructors: OrderedSetInts, Commutator
++ AMS Classification: Primary 17B05, 17B30; Secondary 17A50
++ Keywords: free Lie algebra, Hall basis, basic commutators
++ Related Constructors:  HallBasis, FreeMod, Commutator, OrdSetInts
++ Description: Generate the Free Lie Algebra over a ring R with identity;
++ A P. Hall basis is generated by a package call to HallBasis.

FreeNilpotentLie(n:NNI,class:NNI,R: CommutativeRing): Export == Implement where
   B   ==> Boolean
   Com ==> Commutator
   HB  ==> HallBasis
   I   ==> Integer
   NNI ==> NonNegativeInteger
   O   ==> OutputForm
   OSI ==> OrdSetInts
   FM  ==> FreeModule(R,OSI)
   VI  ==> Vector Integer
   VLI ==> Vector List Integer
   lC  ==> leadingCoefficient
   lS  ==> leadingSupport

   Export ==> NonAssociativeAlgebra(R) with
     dimension : () -> NNI
       ++ dimension() is the rank of this Lie algebra
     deepExpand    : %   -> O
        ++ deepExpand(x) \undocumented{}
     shallowExpand    : %   -> O
        ++ shallowExpand(x) \undocumented{}
     generator : NNI -> %
       ++ generator(i) is the ith Hall Basis element

   Implement ==> FM add
     Rep := FM
     f,g : %

     coms:VLI
     coms := generate(n,class)$HB

     dimension == #coms

     have : (I,I) -> %
       -- have(left,right) is a lookup function for basic commutators
       -- already generated; if the nth basic commutator is
       -- [left,wt,right], then have(left,right) = n
     have(i,j) ==
        wt:I := coms(i).2 + coms(j).2
        wt > class => 0
        lo:I := 1
        hi:I := dimension
        while hi-lo > 1 repeat
          mid:I := (hi+lo) quo 2
          if coms(mid).2 < wt then lo := mid else hi := mid
        while coms(hi).1 < i repeat hi := hi + 1
        while coms(hi).3 < j repeat hi := hi + 1
        monomial(1,hi::OSI)$FM

     generator(i) ==
       i > dimension => 0$Rep
       monomial(1,i::OSI)$FM

     putIn : I -> %
     putIn(i) ==
       monomial(1$R,i::OSI)$FM

     brkt : (I,%) -> %
     brkt(k,f) ==
       f = 0 => 0
       dg:I := value lS f
       reductum(f) = 0 =>
         k = dg  => 0
         k > dg  => -lC(f)*brkt(dg, putIn(k))
         inHallBasis?(n,k,dg,coms(dg).1) => lC(f)*have(k, dg)
         lC(f)*( brkt(coms(dg).1, _
          brkt(k,putIn coms(dg).3)) - brkt(coms(dg).3, _
           brkt(k,putIn coms(dg).1) ))
       brkt(k,monomial(lC f,lS f)$FM)+brkt(k,reductum f)

     f*g ==
       reductum(f) = 0 =>
         lC(f)*brkt(value(lS f),g)
       monomial(lC f,lS f)$FM*g + reductum(f)*g

     Fac : I -> Com
       -- an auxilliary function used for output of Free Lie algebra
       -- elements (see expand)
     Fac(m) ==
       coms(m).1 = 0 => mkcomm(m)$Com
       mkcomm(Fac coms(m).1, Fac coms(m).3)

     shallowE : (R,OSI) -> O
     shallowE(r,s) ==
       k := value s
       r = 1 =>
         k <= n => s::O
         mkcomm(mkcomm(coms(k).1)$Com,mkcomm(coms(k).3)$Com)$Com::O
       k <= n => r::O * s::O
       r::O * mkcomm(mkcomm(coms(k).1)$Com,mkcomm(coms(k).3)$Com)$Com::O

     shallowExpand(f) ==
       f = 0           => 0::O
       reductum(f) = 0 => shallowE(lC f,lS f)
       shallowE(lC f,lS f) + shallowExpand(reductum f)

     deepExpand(f) ==
       f = 0          => 0::O
       reductum(f) = 0 =>
         lC(f)=1 => Fac(value(lS f))::O
         lC(f)::O * Fac(value(lS f))::O
       lC(f)=1 => Fac(value(lS f))::O + deepExpand(reductum f)
       lC(f)::O * Fac(value(lS f))::O + deepExpand(reductum f)

