)abbrev domain DFLOAT DoubleFloat
++ Author: Michael Monagan
++ Date Created:
++   January 1988
++ Change History:
++ Basic Operations: exp1, hash, log2, log10, rationalApproximation, / , **
++ Related Constructors:
++ Keywords: small float
++ Description:  \spadtype{DoubleFloat} is intended to make accessible
++ hardware floating point arithmetic in \Language{}, either native double
++ precision, or IEEE. On most machines, there will be hardware support for
++ the arithmetic operations:
++ \spadfunFrom{+}{DoubleFloat}, \spadfunFrom{*}{DoubleFloat},
++ \spadfunFrom{/}{DoubleFloat} and possibly also the
++ \spadfunFrom{sqrt}{DoubleFloat} operation.
++ The operations \spadfunFrom{exp}{DoubleFloat},
++ \spadfunFrom{log}{DoubleFloat}, \spadfunFrom{sin}{DoubleFloat},
++ \spadfunFrom{cos}{DoubleFloat},
++ \spadfunFrom{atan}{DoubleFloat} are normally coded in
++ software based on minimax polynomial/rational approximations.
++ Note that under Lisp/VM, \spadfunFrom{atan}{DoubleFloat}
++ is not available at this time.
++ Some general comments about the accuracy of the operations:
++ the operations \spadfunFrom{+}{DoubleFloat},
++ \spadfunFrom{*}{DoubleFloat}, \spadfunFrom{/}{DoubleFloat} and
++ \spadfunFrom{sqrt}{DoubleFloat} are expected to be fully accurate.
++ The operations \spadfunFrom{exp}{DoubleFloat},
++ \spadfunFrom{log}{DoubleFloat}, \spadfunFrom{sin}{DoubleFloat},
++ \spadfunFrom{cos}{DoubleFloat} and
++ \spadfunFrom{atan}{DoubleFloat} are not expected to be
++ fully accurate.  In particular, \spadfunFrom{sin}{DoubleFloat}
++ and \spadfunFrom{cos}{DoubleFloat}
++ will lose all precision for large arguments.
++
++ The \spadtype{Float} domain provides an alternative to the \spad{DoubleFloat} domain.
++ It provides an arbitrary precision model of floating point arithmetic.
++ This means that accuracy problems like those above are eliminated
++ by increasing the working precision where necessary.  \spadtype{Float}
++ provides some special functions such as \spadfunFrom{erf}{DoubleFloat},
++ the error function
++ in addition to the elementary functions.  The disadvantage of
++ \spadtype{Float} is that it is much more expensive than small floats when the latter can be used.
-- I've put some timing comparisons in the notes for the Float
-- domain about the difference in speed between the two domains.
DoubleFloat(): Join(FloatingPointSystem, DifferentialRing, OpenMath,
   TranscendentalFunctionCategory, ConvertibleTo InputForm) with
      _/   : (%, Integer) -> %
        ++ x / i computes the division from x by an integer i.
      _*_* : (%,%) -> %
        ++ x ** y returns the yth power of x (equal to \spad{exp(y log x)}).
      exp1 : () -> %
        ++ exp1() returns the natural log base \spad{2.718281828...}.
      log2 :  % -> %
        ++ log2(x) computes the logarithm with base 2 for x.
      log10: % -> %
        ++ log10(x) computes the logarithm with base 10 for x.
      atan : (%,%) -> %
        ++ atan(x,y) computes the arc tangent from x with phase y.
      Gamma: % -> %
        ++ Gamma(x) is the Euler Gamma function.
      Beta : (%,%) -> %
        ++ Beta(x,y) is \spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.
      rationalApproximation: (%, NonNegativeInteger) -> Fraction Integer
        ++ rationalApproximation(f, n) computes a rational approximation
        ++ r to f with relative error \spad{< 10**(-n)}.
      rationalApproximation: (%, NonNegativeInteger, NonNegativeInteger) -> Fraction Integer
         ++ rationalApproximation(f, n, b) computes a rational
         ++ approximation r to f with relative error \spad{< b**(-n)}
         ++ (that is, \spad{|(r-f)/f| < b**(-n)}).

 == add
   MER ==> Record(MANTISSA:Integer,EXPONENT:Integer)

   manexp: % -> MER

   OMwrite(x: %): String ==
     s: String := ""
     sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
     dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
     OMputObject(dev)
     OMputFloat(dev, convert x)
     OMputEndObject(dev)
     OMclose(dev)
     s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
     s

   OMwrite(x: %, wholeObj: Boolean): String ==
     s: String := ""
     sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
     dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
     if wholeObj then
       OMputObject(dev)
     OMputFloat(dev, convert x)
     if wholeObj then
       OMputEndObject(dev)
     OMclose(dev)
     s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
     s

   OMwrite(dev: OpenMathDevice, x: %): Void ==
     OMputObject(dev)
     OMputFloat(dev, convert x)
     OMputEndObject(dev)

   OMwrite(dev: OpenMathDevice, x: %, wholeObj: Boolean): Void ==
     if wholeObj then
       OMputObject(dev)
     OMputFloat(dev, convert x)
     if wholeObj then
       OMputEndObject(dev)

   checkComplex(x:%):% == C_-TO_-R(x)$Lisp
   -- In AKCL we used to have to make the arguments to ASIN ACOS ACOSH ATANH
   -- complex to get the correct behaviour.
   --makeComplex(x: %):% == COMPLEX(x, 0$%)$Lisp

   base()           == FLOAT_-RADIX(0$%)$Lisp
   mantissa x       == manexp(x).MANTISSA
   exponent x       == manexp(x).EXPONENT
   precision()      == FLOAT_-DIGITS(0$%)$Lisp
   bits()           ==
     base() = 2 => precision()
     base() = 16 => 4*precision()
     wholePart(precision()*log2(base()::%))::PositiveInteger
   max()            == _$DoubleFloatMaximum$Lisp
   min()            == _$DoubleFloatMinimum$Lisp
   order(a) == precision() + exponent a - 1
   0                == FLOAT(0$Lisp,_$DoubleFloatMaximum$Lisp)$Lisp
   1                == FLOAT(1$Lisp,_$DoubleFloatMaximum$Lisp)$Lisp
   -- rational approximation to e accurate to 23 digits
   exp1()           == FLOAT(534625820200,_$DoubleFloatMaximum$Lisp)$Lisp / FLOAT(196677847971,_$DoubleFloatMaximum$Lisp)$Lisp
   pi()             == PI$Lisp
   coerce(x:%):OutputForm == outputForm x
   convert(x:%):InputForm == convert(x pretend DoubleFloat)$InputForm
   x < y            == (x<y)$Lisp
   - x              == (-x)$Lisp
   x + y            == (x+y)$Lisp
   x:% - y:%        == (x-y)$Lisp
   x:% * y:%        == (x*y)$Lisp
   i:Integer * x:%  == (i*x)$Lisp
   max(x,y)         == MAX(x,y)$Lisp
   min(x,y)         == MIN(x,y)$Lisp
   x = y            == (x=y)$Lisp
   x:% / i:Integer  == (x/i)$Lisp
   sqrt x           == checkComplex SQRT(x)$Lisp
   log10 x          == checkComplex log(x)$Lisp
   x:% ** i:Integer == EXPT(x,i)$Lisp
   x:% ** y:%       == checkComplex EXPT(x,y)$Lisp
   coerce(i:Integer):% == FLOAT(i,_$DoubleFloatMaximum$Lisp)$Lisp
   exp x            == EXP(x)$Lisp
   log x            == checkComplex LN(x)$Lisp
   log2 x           == checkComplex LOG2(x)$Lisp
   sin x            == SIN(x)$Lisp
   cos x            == COS(x)$Lisp
   tan x            == TAN(x)$Lisp
   cot x            == COT(x)$Lisp
   sec x            == SEC(x)$Lisp
   csc x            == CSC(x)$Lisp
   asin x           == checkComplex ASIN(x)$Lisp -- can be complex
   acos x           == checkComplex ACOS(x)$Lisp -- can be complex
   atan x           == ATAN(x)$Lisp
   acsc x           == checkComplex ACSC(x)$Lisp
   acot x           == ACOT(x)$Lisp
   asec x           == checkComplex ASEC(x)$Lisp
   sinh x           == SINH(x)$Lisp
   cosh x           == COSH(x)$Lisp
   tanh x           == TANH(x)$Lisp
   csch x           == CSCH(x)$Lisp
   coth x           == COTH(x)$Lisp
   sech x           == SECH(x)$Lisp
   asinh x          == ASINH(x)$Lisp
   acosh x          == checkComplex ACOSH(x)$Lisp -- can be complex
   atanh x          == checkComplex ATANH(x)$Lisp -- can be complex
   acsch x          == ACSCH(x)$Lisp
   acoth x          == checkComplex ACOTH(x)$Lisp
   asech x          == checkComplex ASECH(x)$Lisp
   x:% / y:%        == (x/y)$Lisp
   negative? x      == MINUSP(x)$Lisp
   zero? x          == ZEROP(x)$Lisp
   hash x           == HASHEQ(x)$Lisp
   recip(x)         == (zero? x => "failed"; 1 / x)
   differentiate x  == 0

   SFSFUN           ==> DoubleFloatSpecialFunctions()
   sfx              ==> x pretend DoubleFloat
   sfy              ==> y pretend DoubleFloat
   Gamma x          == Gamma(sfx)$SFSFUN pretend %
   Beta(x,y)        == Beta(sfx,sfy)$SFSFUN pretend %

   wholePart x            == FIX(x)$Lisp
   float(ma,ex,b)   == ma*(b::%)**ex
   convert(x:%):DoubleFloat == x pretend DoubleFloat
   convert(x:%):Float == convert(x pretend DoubleFloat)$Float
   rationalApproximation(x, d) == rationalApproximation(x, d, 10)

   atan(x,y) ==
      x = 0 =>
         y > 0 => pi()/2
         y < 0 => -pi()/2
         0
      -- Only count on first quadrant being on principal branch.
      theta := atan abs(y/x)
      if x < 0 then theta := pi() - theta
      if y < 0 then theta := - theta
      theta

   retract(x:%):Fraction(Integer) ==
     rationalApproximation(x, (precision() - 1)::NonNegativeInteger, base())

   retractIfCan(x:%):Union(Fraction Integer, "failed") ==
     rationalApproximation(x, (precision() - 1)::NonNegativeInteger, base())

   retract(x:%):Integer ==
     x = ((n := wholePart x)::%) => n
     error "Not an integer"

   retractIfCan(x:%):Union(Integer, "failed") ==
     x = ((n := wholePart x)::%) => n
     "failed"

   sign(x) == retract FLOAT_-SIGN(x,1)$Lisp
   abs x   == FLOAT_-SIGN(1,x)$Lisp


   
   manexp(x) ==
      zero? x => [0,0]
      s := sign x; x := abs x
      if x > max()$% then return [s*mantissa(max())+1,exponent max()]
      me:Record(man:%,exp:Integer) := MANEXP(x)$Lisp 
      two53:= base()**precision()
      [s*wholePart(two53 * me.man ),me.exp-precision()]

-- rationalApproximation(y,d,b) ==
--    this is the quotient remainder algorithm (requires wholePart operation)
--    x := y
--    if b < 2 then error "base must be > 1"
--    tol := (b::%)**d
--    p0,p1,q0,q1 : Integer
--    p0 := 0; p1 := 1; q0 := 1; q1 := 0
--    repeat
--       a := wholePart x
--       x := fractionPart x
--       p2 := p0+a*p1
--       q2 := q0+a*q1
--       if x = 0 or tol*abs(q2*y-(p2::%)) < abs(q2*y) then
--          return (p2/q2)
--       (p0,p1) := (p1,p2)
--       (q0,q1) := (q1,q2)
--       x := 1/x

   rationalApproximation(f,d,b) ==
      -- this algorithm expresses f as n / d where d = BASE ** k
      -- then all arithmetic operations are done over the integers
      (nu, ex) := manexp f
      BASE := base()
      ex >= 0 => (nu * BASE ** (ex::NonNegativeInteger))::Fraction(Integer)
      de :Integer := BASE**((-ex)::NonNegativeInteger)
      b < 2 => error "base must be > 1"
      tol := b**d
      s := nu; t := de
      p0:Integer := 0; p1:Integer := 1; q0:Integer := 1; q1:Integer := 0
      repeat
         (q,r) := divide(s, t)
         p2 := q*p1+p0
         q2 := q*q1+q0
         r = 0 or tol*abs(nu*q2-de*p2) < de*abs(p2) => return(p2/q2)
         (p0,p1) := (p1,p2)
         (q0,q1) := (q1,q2)
         (s,t) := (t,r)

   x:% ** r:Fraction Integer ==
      zero? x =>
         zero? r => error "0**0 is undefined"
         negative? r => error "division by 0"
         0
--      zero? r or one? x => 1
      zero? r or (x = 1) => 1
--      one?  r => x
      (r = 1) => x
      n := numer r
      d := denom r
      negative? x =>
         odd? d =>
            odd? n => return -((-x)**r)
            return ((-x)**r)
         error "negative root"
      d = 2 => sqrt(x) ** n
      x ** (n::% / d::%)

