)abbrev domain FRMOD FramedModule
++ Author: Manuel Bronstein
++ Date Created: 27 Jan 1989
++ Date Last Updated: 24 Jul 1990
++ Keywords: ideal, algebra, module.
++ Examples: )r FRIDEAL INPUT
++ Description: Module representation of fractional ideals.
FramedModule(R, F, UP, A, ibasis): Exports == Implementation where
  R     : EuclideanDomain
  F     : QuotientFieldCategory R
  UP    : UnivariatePolynomialCategory F
  A     : FramedAlgebra(F, UP)
  ibasis: Vector A

  VR  ==> Vector R
  VF  ==> Vector F
  VA  ==> Vector A
  M   ==> Matrix F

  Exports ==> Monoid with
    basis : %  -> VA
      ++ basis((f1,...,fn)) = the vector \spad{[f1,...,fn]}.
    norm  : %  -> F
      ++ norm(f) returns the norm of the module f.
    module: VA -> %
      ++ module([f1,...,fn]) = the module generated by \spad{(f1,...,fn)}
      ++ over R.
    if A has RetractableTo F then
      module: FractionalIdeal(R, F, UP, A) -> %
        ++ module(I) returns I viewed has a module over R.

  Implementation ==> add
    import MatrixCommonDenominator(R, F)
    import ModularHermitianRowReduction(R)

    Rep  := VA

    iflag?:Reference(Boolean) := ref true
    wflag?:Reference(Boolean) := ref true
    imat := new(#ibasis, #ibasis, 0$F)$M
    wmat := new(#ibasis, #ibasis, 0$F)$M

    rowdiv      : (VR, R)  -> VF
    vectProd    : (VA, VA) -> VA
    wmatrix     : VA -> M
    W2A         : VF -> A
    intmat      : () -> M
    invintmat   : () -> M
    getintmat   : () -> Boolean
    getinvintmat: () -> Boolean

    1                      == ibasis
    module(v:VA)           == v
    basis m                == m pretend VA
    rowdiv(r, f)           == [r.i / f for i in minIndex r..maxIndex r]
    coerce(m:%):OutputForm == coerce(basis m)$VA
    W2A v                  == represents(v * intmat())
    wmatrix v              == coordinates(v) * invintmat()

    getinvintmat() ==
      m := inverse(intmat())::M
      for i in minRowIndex m .. maxRowIndex m repeat
        for j in minColIndex m .. maxColIndex m repeat
          imat(i, j) := qelt(m, i, j)
      false

    getintmat() ==
      m := coordinates ibasis
      for i in minRowIndex m .. maxRowIndex m repeat
        for j in minColIndex m .. maxColIndex m repeat
          wmat(i, j) := qelt(m, i, j)
      false

    invintmat() ==
      if iflag?() then iflag?() := getinvintmat()
      imat

    intmat() ==
      if wflag?() then wflag?() := getintmat()
      wmat

    vectProd(v1, v2) ==
      k := minIndex(v := new(#v1 * #v2, 0)$VA)
      for i in minIndex v1 .. maxIndex v1 repeat
        for j in minIndex v2 .. maxIndex v2 repeat
          qsetelt_!(v, k, qelt(v1, i) * qelt(v2, j))
          k := k + 1
      v pretend VA

    norm m ==
      #(basis m) ~= #ibasis => error "Module not of rank n"
      determinant(coordinates(basis m) * invintmat())

    m1 * m2 ==
      m := rowEch((cd := splitDenominator wmatrix(
                                     vectProd(basis m1, basis m2))).num)
      module [u for i in minRowIndex m .. maxRowIndex m |
                           (u := W2A rowdiv(row(m, i), cd.den)) ~= 0]$VA

    if A has RetractableTo F then
      module(i:FractionalIdeal(R, F, UP, A)) ==
        module(basis i) * module(ibasis)

