)co operatorcats.spad

)abbrev package CHKASSMP CheckAssumption
++ Author: Yue Li
++ Date Created: November 23, 2009
++ Date Last Updated: April 4, 2010
++ Description: This package provides library function extracts
++ the knowledge from user assumptions, and store them in an 
++ internal format which can be understood by the reduction detector
CheckAssumption(): Public == Private where
  macro OPFUNR == Record(funname: Identifier, signature: Signature)
  macro OPCATS == Record(ctorname: Identifier, ctorpars: List Identifier,_
                  partypes: List Syntax, decls: List OPFUNR, hascats: List Syntax)     
  macro OPREC == Record(funname: Identifier, origin: Syntax,_
                  signature: Signature, tenv: Table(Syntax, Syntax)) 
  macro OPASMP == Record(catname: Identifier, parlist: List Syntax,_
                  funpars: List OPREC, assumptionbody: Syntax, forall?: Boolean)
  Public == with
    collectAssociativeOperator: List OPREC 
      ++ collect all the associative operator assumed via user assumption
      ++ store their information in a database, those information 
      ++ is function name, signature, as well as values associated to it, 
      ++ e.g., neutral element, and so on.
  Private == add
    import SyntaxHelper
    import TypeChecker

    -- global list for storing constructor data of 
    -- each operator category
    operatorCategoryList   : List OPCATS := []

    -- global list for storing internal representation 
    -- of each user assumption
    operatorAssumptionList : List OPASMP := []

    -- global list storing the information of all the
    -- operators which are attached with associativity via assumption
    associativeOperatorList: List OPREC  := []

    -- type environment used for typechecking an assumption
    typeEnvironment: Table(Syntax, Syntax) := empty()

    -- extract all the declarations in the export of 
    -- an operator category definition
    extractDeclarationList(ctor: Identifier): List OPFUNR ==
      result : List OPFUNR := []
      c := retract(findConstructor(ctor)$Constructor)$(Maybe Constructor)
      for f in operations c repeat
        fn := name f
        for fd in members f repeat
          sig := signature fd
          r : OPFUNR := [fn, sig]
          result := concat(result, r)
      result

    -- collect all the category extensions listed in
    -- a join ast
    collectJoins(joins: Syntax): List Syntax ==
      result : List Syntax := []
      compound? joins =>
        (op := getOperator(joins)) case Identifier and op = 'Join::Identifier =>
          for cat in getOperands joins repeat
            not(cat::SpadAst case CategoryAst) => result := concat(result, cat)
          result
        not(joins::SpadAst case CategoryAst) => 
          result := concat(result, joins)
      []


    -- traverses operator category hierarchy,
    -- collecting the constructor data of each category
    preprocOperatorCategories(): Void == 
      operatorCategoryList := []
      cats := parse("operatorcats.spad")$SpadParser
      for cat in cats repeat
        cat' := cat::DefinitionAst
        cname := name head cat'
        cpars := parameters head cat'
        csig := source signature cat'
        joins := (body cat')::Syntax
        r: OPCATS := [cname, cpars, csig,_
                      extractDeclarationList cname, collectJoins joins]
        operatorCategoryList := concat(operatorCategoryList, r)

    -- obtain all the parameters of the category used in 
    -- an assumption head
    getParametersFromAssumption(a: WhereAst): List Syntax ==
      callform := first getOperands((mainExpression a)::Syntax)
      getOperands callform

    -- extract the operator category name from an user assumption syntax
    getOperatorCategoryNameFromAssumption(a: WhereAst): Identifier ==
      callform := first getOperands((mainExpression a)::Syntax)
      (opr := getOperator callform)  case Identifier => opr::Identifier
      userError "unexpected type of constructor name"

    -- given a category name, obtain the record storing 
    -- the constructor data of that category collected by our preprocessor
    retrieveCategoryRecord(ctorName: Identifier): OPCATS ==
      for r in operatorCategoryList repeat
        r.ctorname = ctorName => return r
      userError "can not find the category record!"

    -- given a constructor name, figure out the constructor kind
    -- using compiler's database
    getCtorKind(c: Identifier): ConstructorKind == 
      ctor := retract(findConstructor(c)$Constructor)$(Maybe Constructor)
      kind(ctor)$Constructor

    -- checks whether a syntax is a type variable
    isTypeT?(c: Syntax): Boolean ==  
      not compound? c and key?(c, typeEnvironment)

    -- check whether some domain has another category
    -- note that, this function is subject to change
    -- it can not handle the case where a category is parameterized with
    -- type variables 
    checkDomainHasCategory(dom: Syntax, cat: Syntax): Boolean ==
      expression := buildSyntax('has::Syntax::Identifier,_
                                 [dom, cat])::InputForm
      retractIfCan(_
       (interpret(expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    -- check whether some category has another category
    -- note that, this function is subject to change
    -- it can not handle the case where a domain is parameterized with
    -- type variables 
    checkCategoryHasCategory(catl: Syntax, catr: Syntax): Boolean ==
      expression := buildSyntax('has::Syntax::Identifier,_
                                 [catl, catr])::InputForm
      retractIfCan((interpret(_
        expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    -- instantiate a signature of an operator parameter with 
    -- the actual types or type variables    
    instantiateSignature(val: Syntax, var: Identifier,_
                    ptypes: List Syntax, index: Integer): List Syntax ==
      ptypesCopy := copy ptypes
      for i in index..#ptypes repeat
        ptypesCopy.i := replace(var::Syntax, ptypes.i, val)$SyntaxHelper
      ptypesCopy

    -- checks whether some operator is annotated with its domain
    isAnnotatedOperator?(op: Syntax): Pair(Boolean, List Syntax) ==
      compound? op =>
        opr := getOperator op 
        opr case Identifier and opr::Identifier = 'elt::Identifier => 
          pair(true, getOperands op)
        pair(false, [])
      pair(false, [])

    -- does type checking for operator parameter of an assumption
    -- where the operator's domain is annotated 
    checkAnnotatedOperatorParameter(tpanot: Syntax, fn: Identifier,_
                                    sig: Syntax): Pair(Boolean, Signature) ==
      sig' := mappingAstToSignature(sig::SpadAst::MappingAst)$SyntaxHelper
      AnnotFunResolForAssumption(tpanot, source sig',_
                                 target sig', fn, typeEnvironment)$TypeChecker

    -- does type checking for operator parameter of an assumption
    -- where the operator's domain is not annotated 
    checkUnannotatedOperatorParameter(fn: Identifier,_
                                      sig: Syntax): Pair(Boolean, Signature) ==
      sig' := mappingAstToSignature(sig::SpadAst::MappingAst)$SyntaxHelper
      for dom in concat(source sig', target sig') repeat
        first(t := AnnotFunResolForAssumption(dom, source sig',_
          target sig', fn, typeEnvironment)$TypeChecker) => return t
      pair(false, signature([makeUnknown()], makeUnknown())) 
 
    -- does type checking for operator parameter of an assumption
    -- where the operator's domain can be either annotated or not
    checkOperatorParameter(op: Syntax, tp: Syntax): Pair(Boolean, Signature) ==
      first(t := isAnnotatedOperator?(op)) => 
        checkAnnotatedOperatorParameter(first second t,_
                                       (second second t)::Identifier, tp)
      checkUnannotatedOperatorParameter(op::Identifier, tp)

    -- creates a record for storing the knowledge of the operator
    -- being attached with algebraic properties
    createFunctionRecord(f: Syntax, s: Signature): OPREC ==
      first(t := isAnnotatedOperator? f) => 
        [(second second t)::Identifier, first second t, s, copy typeEnvironment]
      [f::Identifier, makeUnknown(), s, copy typeEnvironment]

    -- checks whether a category uses type variables 
    -- in its parameters
    containTypeVar?(cat: Syntax): Boolean ==
      not compound? cat => isTypeT? cat
      for opr in getOperands cat repeat
        containTypeVar? opr  => return true
      false 

    -- does typechecking for the category used in assumption
    -- against the type requirements extracted from the 
    -- operator category definition body
    checkConstructorCallForm(pars: List Syntax,_
                        ctorName: Identifier): Pair(List Syntax, List OPREC) ==
      operatorRecord := retrieveCategoryRecord(ctorName)
      ctorPars : List Identifier := operatorRecord.ctorpars
      ctorParTypes : List Syntax := operatorRecord.partypes
      ctorParTypesCopy : List Syntax := copy ctorParTypes
      funRecords: List OPREC := []
      ctorparameters: List Syntax := []
      for i in 1..#ctorParTypesCopy repeat
        tp := ctorParTypesCopy.i
        tp::SpadAst case MappingAst =>
          sig := mappingAstToSignature(tp::SpadAst::MappingAst)$SyntaxHelper
          first(t := checkOperatorParameter(pars.i, tp)) => 
            rec := createFunctionRecord(pars.i, sig)
            funRecords := concat(funRecords, rec)
            -- to be modified later
            ctorparameters := concat(ctorparameters, (rec.funname)::Syntax)
          userError "the operator parameter can not be resolved!"
        (isCategory? tp) =>
          isDomain?(pars.i) => 
            not containTypeVar?(pars.i) =>
              checkDomainHasCategory(pars.i, tp) =>
                -- do instantiation using pars.i, ctorPars.i, ctorParTypesCopy 
                ctorParTypesCopy := instantiateSignature(pars.i, ctorPars.i, ctorParTypesCopy, i)
                ctorparameters := concat(ctorparameters, pars.i)
              print(pars.i::OutputForm)
              print(tp::OutputForm)
              userError "domain does not have the expected category"
            -- currently we can not do type checking for forall(T) AssocOp(List T, concat), i.e. checking List T has SetCategory
            ctorParTypesCopy := instantiateSignature(pars.i, ctorPars.i, ctorParTypesCopy, i)
            ctorparameters := concat(ctorparameters, pars.i)            
          isTypeT?(pars.i) =>
            k := pars.i
            tpOfT := typeEnvironment.k
            isCategory? tpOfT =>
              checkCategoryHasCategory(tpOfT, tp) =>
                -- do instantiation using pars.i, ctorPars.i, ctorParTypesCopy 
                ctorParTypesCopy := instantiateSignature(pars.i, ctorPars.i, ctorParTypesCopy, i)
                ctorparameters := concat(ctorparameters, pars.i)
              print(tpOfT::OutputForm)
              print(tp::OutputForm)
              userError "category does not have the expected category"
            userError "the type of T does not have kind category"
          print((pars.i)::OutputForm)
          userError "the input type does not have kind domain"
        userError "the expected type is neither a mapping or category"
      pair(copy ctorparameters, copy funRecords)
    
    -- checks whether an assumption is a generic or basic assumption
    containForall?(a: WhereAst): Pair(Boolean, List Syntax) ==
      mainexp := (mainExpression a)::Syntax
      (forall := getOperator mainexp) case Syntax =>
        forall' := forall::Syntax
        assume  := first getOperands mainexp
        (fa := getOperator forall') case Identifier and_
        fa = 'forall::Identifier =>
          pair(true, [forall', assume])
        pair(false, [])
      pair(false, [])

    -- extract type information from the forall construct
    -- of some generic assumption
    updateForallTypeEnvironment(forall: Syntax): Void ==
      typeEnvironment := empty()
      for s in getOperands forall repeat
        s::SpadAst case ColonAst =>
          s' := s::SpadAst::ColonAst
          id := (lhs s')::Syntax
          tp := (rhs s')::Syntax
          typeEnvironment.id := tp

    -- does typechecking for a generic assumption
    -- after which, the knowledge of the operator being assumed
    -- is stored in a global database
    checkForallAssumption(a: WhereAst, h: List Syntax): Void ==
      forall := first h
      assume := second h
      updateForallTypeEnvironment(forall)
      pars := getOperands first getOperands assume
      aname := (getOperator first getOperands assume)::Identifier
      r := checkConstructorCallForm(pars, aname)
      rec : OPASMP := [aname, first r, second r,_
                      (qualifier(a)$WhereAst)::Syntax, true]
      operatorAssumptionList := concat(operatorAssumptionList, rec)

    -- does typechecking on the parameters given to a category
    -- used in a basic assumption. The type requirements are extracted
    -- from the category definition defined in opcategory.spad
    checkAssumption(a: WhereAst): Void ==
      first(t := containForall? a) => 
        checkForallAssumption(a, second t)
      typeEnvironment := empty()
      pars := getParametersFromAssumption(a)
      aname := getOperatorCategoryNameFromAssumption(a)
      r := checkConstructorCallForm(pars, aname)
      rec : OPASMP := [aname, first r, second r,_
                      (qualifier(a)$WhereAst)::Syntax, false]
      operatorAssumptionList := concat(operatorAssumptionList, rec)

    -- typechecks each assumption, after which knowledge from 
    -- each assumption is extracted and stored in a global 
    -- database
    preprocessAssumptions(): Void == 
      preprocOperatorCategories()
      operatorAssumptionList := []
      assumps := parse("usrassumptions.spad")$SpadParser
      for a in assumps repeat
        a' := a::WhereAst
        checkAssumption(a')

    -- build a AssociativeOperatorCategory with symbolic constants
    -- as its parameters
    buildAssociativeOperatorCategoryCall(fname: Identifier,_
                                         rtn: Syntax): Syntax ==  
      buildSyntax('AssociativeOperator::Identifier, [rtn, fname::Syntax])

    -- given a category, we instantiate all its constructor data with
    -- the actual parameters of the category, this helps us to 
    -- determine the category extensions of some category at compile
    -- time
    instantiateCategoryRecord(callform: Syntax): List Syntax ==
      cname := getOperator(callform)::Identifier
      pars := getOperands callform
      catrec :=_
        first [copy r for r in operatorCategoryList | r.ctorname = cname]
      constructorParameter := catrec.ctorpars
      hascatlist := catrec.hascats
      hascatlist' : List Syntax := copy hascatlist
      for i in 1..#pars repeat
        for j in 1..#hascatlist' repeat
          hascatlist'.j := replace((constructorParameter.i)::Syntax,_
                                    hascatlist'.j, pars.i)$SyntaxHelper
      hascatlist'

    -- collect all the categories that some category extends       
    collectAncestors(callform: Syntax): List Syntax ==
      result : List Syntax := []
      callform = buildSyntax('Type::Identifier, []) => 
        result := concat(result, callform)
      r' := instantiateCategoryRecord callform
      result := concat(result, r')
      for anc in r' repeat
        result := concat(result, collectAncestors anc)
      removeDuplicates result
    
    -- checks whether some algebraic oeprator category has
    -- AssociativeOperator category, the operator parameter 
    -- of the category can be generic operator, e.g., op: (T, T) -> T
    -- where T has AbelianMonoid
    hasAssociativeOperatorCategoryT?(callform: Syntax, op: OPREC): Boolean ==
      searchTarget :=_
        buildAssociativeOperatorCategoryCall(op.funname, target(op.signature))
      callform = searchTarget => true
      ancestors := collectAncestors callform
      member?(searchTarget, ancestors)

    -- checks whether some algebraic oeprator category has 
    -- AssociativeOperator category, this function is subject to change
    -- because it only supports category whose parameter is a specific 
    -- operator
    hasAssociativeOperatorCategory?(callform: Syntax, op: OPREC): Boolean ==
      right := buildAssociativeOperatorCategoryCall(op.funname, target(op.signature))
      left  := callform
      expression := buildSyntax('has::Syntax::Identifier, [left, right])::InputForm
      retractIfCan((interpret(expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    -- collect all the associative operators assumed by user
    collectAssociativeOperator() ==
      preprocessAssumptions()
      associativeOperatorList := []
      for r in operatorAssumptionList repeat
        callform : Syntax := buildSyntax(r.catname, r.parlist)
        for op in r.funpars repeat
          if r.forall? then
            hasAssociativeOperatorCategoryT?(callform, op) => 
              associativeOperatorList := concat(associativeOperatorList, op)
          else
            hasAssociativeOperatorCategory?(callform, op) => 
              associativeOperatorList := concat(associativeOperatorList, op)
      associativeOperatorList
