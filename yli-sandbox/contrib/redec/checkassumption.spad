)co operatorcats.spad


import SYNHELP
import TYPCHK

)abbrev package CHKASSMP CheckAssumption
++ Author: Yue Li
++ Date Created: November 23, 2009
++ Date Last Updated: November 23, 2009
++ Description: This package provides preprocessing functions for semantic analysis
++              of a package/domain/category
CheckAssumption(): Public == Private where
  macro OPFUNR == Record(funname: Identifier, signature: Signature)
  macro OPCATS == Record(ctorname: Identifier, ctorpars: List Identifier, partypes: List Syntax, decls: List OPFUNR, hascats: List Syntax)     
  macro OPREC == Record(funname: Identifier, origin: Syntax, signature: Signature, tenv: Table(Syntax, Syntax)) 
  macro OPASMP == Record(catname: Identifier, parlist: List Syntax, funpars: List OPREC, assumptionbody: Syntax, forall?: Boolean)

  Public == with
    preprocOperatorCategories: Boolean
    viewOperatorCategory: List OPCATS
    preprocAssumptions: Boolean 
    viewAssumptionList: List OPASMP
    collectAssociativeOperator: List OPREC
 
    ++ export for redupkg
    isDomain?: Syntax -> Boolean
    isCategory?: Syntax -> Boolean


  Private == add
    L_opcats : List OPCATS := []
    L_opasmp : List OPASMP := []
    L_assocop: List OPREC  := []
    T_typeenv: Table(Syntax, Syntax) := empty()

    cleanUp(): Boolean == 
      L_opcats := []
      true

    extractDeclList(ctor: Identifier): List OPFUNR ==
      result : List OPFUNR := []
      c := retract(findConstructor(ctor)$Constructor)$(Maybe Constructor)
      L_overload := operations c
      for f in L_overload repeat
        fn := name f
        for fd in members f repeat
          sig := signature fd
          r : OPFUNR := [fn, sig]
          result := concat(result, r)
      result

    collectJoins(joins: Syntax): List Syntax ==
      result : List Syntax := []
      compound? joins =>
        (op := getOperator(joins)) case Identifier and op = 'Join::Identifier =>
          for cat in getOperands joins repeat
            not(cat::SpadAst case CategoryAst) => result := concat(result, cat)
          result
        not(joins::SpadAst case CategoryAst) => 
          result := concat(result, joins)
      []

    preprocOperatorCategories() == 
      L_opcats := []
      cats := parse("operatorcats.spad")$SpadParser
      for cat in cats repeat
        cat' := cat::DefinitionAst
        cname := name head cat'
        cpars := parameters head cat'
        csig := source signature cat'
        joins := (body cat')::Syntax
        r: OPCATS := [cname, cpars, csig, extractDeclList cname, collectJoins joins]
        L_opcats := concat(L_opcats, r)
      true

    viewOperatorCategory() ==  L_opcats

    getParametersFromAssumption(a: WhereAst): List Syntax ==
      callform := first getOperands((mainExpression a)::Syntax)
      getOperands callform

    getOPCatNameFromAssumption(a: WhereAst): Identifier ==
      callform := first getOperands((mainExpression a)::Syntax)
      (opr := getOperator callform)  case Identifier => opr::Identifier
      userError "unexpected type of constructor name"

    retrieveCatRecord(ctorName: Identifier): OPCATS ==
      --print(L_opcats::OutputForm)
      --print(ctorName::OutputForm)
      for r in L_opcats repeat
        r.ctorname = ctorName => return r
      userError "can not find the category record!"

    getCtorKind(c: Identifier): ConstructorKind == 
      kind(retract(findConstructor(c)$Constructor)$(Maybe Constructor))$Constructor

    isTypeT?(c: Syntax): Boolean ==  not compound? c and key?(c, T_typeenv)

    isDomain?(c: Syntax): Boolean ==      
      compound? c and (opr := getOperator c) case Identifier => 
        not(getCtorKind(opr::Identifier) = category$ConstructorKind) and_
        not(getCtorKind(opr::Identifier) = package$ConstructorKind)
      false

    isCategory?(c: Syntax): Boolean ==
      compound? c and (opr := getOperator c) case Identifier => 
        getCtorKind(opr::Identifier) = category$ConstructorKind
      false

    checkDomHasCat(dom: Syntax, cat: Syntax): Boolean ==
      expression := buildSyntax('has::Syntax::Identifier, [dom, cat])::InputForm
      retractIfCan((interpret(expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    checkCatHasCat(catl: Syntax, catr: Syntax): Boolean ==
      expression := buildSyntax('has::Syntax::Identifier, [catl, catr])::InputForm
      retractIfCan((interpret(expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    instantiateSignature(val: Syntax, var: Identifier, ptypes: List Syntax, index: Integer): List Syntax ==
      ptypesCopy := copy ptypes
      for i in index..#ptypes repeat
        ptypesCopy.i := replace(var::Syntax, ptypes.i, val)$SyntaxHelper
      ptypesCopy

    isAnnotatedOperator?(op: Syntax): Pair(Boolean, List Syntax) ==
      compound? op =>
        opr := getOperator op 
        opr case Identifier and opr::Identifier = 'elt::Identifier => 
          pair(true, getOperands op)
        pair(false, [])
      pair(false, [])
    
    checkAnnotatedOperatorParameter(tpanot: Syntax, fn: Identifier, sig: Syntax): Pair(Boolean, Signature) ==
      sig' := mappingAstToSignature(sig::SpadAst::MappingAst)$SyntaxHelper
      AnnotFunResolForAssumption(tpanot, source sig', target sig', fn, T_typeenv)$TypeChecker    

    makeUnknown: Syntax                == '_?::Identifier::Syntax

    checkUnannotatedOperatorParameter(fn: Identifier, sig: Syntax): Pair(Boolean, Signature) ==
      sig' := mappingAstToSignature(sig::SpadAst::MappingAst)$SyntaxHelper
      for dom in concat(source sig', target sig') repeat
        first(t := AnnotFunResolForAssumption(dom, source sig', target sig', fn, T_typeenv)$TypeChecker) => return t
      pair(false, signature([makeUnknown()], makeUnknown())) 

    checkOperatorParameter(op: Syntax, tp: Syntax): Pair(Boolean, Signature) ==
      first(t := isAnnotatedOperator?(op)) => 
        checkAnnotatedOperatorParameter(first second t, (second second t)::Identifier, tp)
      checkUnannotatedOperatorParameter(op::Identifier, tp)

    createFunctionRecord(f: Syntax, s: Signature): OPREC ==
      first(t := isAnnotatedOperator? f) => [(second second t)::Identifier, first second t, s, copy T_typeenv]
      [f::Identifier, makeUnknown(), s, copy T_typeenv]

    containTpVar?(cat: Syntax): Boolean ==
      not compound? cat => isTypeT? cat
      for opr in getOperands cat repeat
        containTpVar? opr  => return true
      false 

    checkCtorCallForm(pars: List Syntax, ctorName: Identifier): Pair(List Syntax, List OPREC) ==
      op_rec := retrieveCatRecord(ctorName)
      ctorPars : List Identifier := op_rec.ctorpars
      ctorParTypes : List Syntax := op_rec.partypes
      ctorParTypesCopy : List Syntax := copy ctorParTypes
      funRecords: List OPREC := []
      ctorparameters: List Syntax := []

      for i in 1..#ctorParTypesCopy repeat
        tp := ctorParTypesCopy.i
        tp::SpadAst case MappingAst =>
          sig := mappingAstToSignature(tp::SpadAst::MappingAst)$SyntaxHelper
          first(t := checkOperatorParameter(pars.i, tp)) => 

            rec := createFunctionRecord(pars.i, sig)
            funRecords := concat(funRecords, rec)
            -- to be modified later
            ctorparameters := concat(ctorparameters, (rec.funname)::Syntax)
          userError "the operator parameter can not be resolved!"

        (isCategory? tp) =>
          isDomain?(pars.i) => 
            not containTpVar?(pars.i) =>
              checkDomHasCat(pars.i, tp) =>
                -- do instantiation using pars.i, ctorPars.i, ctorParTypesCopy 
                ctorParTypesCopy := instantiateSignature(pars.i, ctorPars.i, ctorParTypesCopy, i)
                ctorparameters := concat(ctorparameters, pars.i)
              print(pars.i::OutputForm)
              print(tp::OutputForm)
              userError "domain does not have the expected category"
            -- currently we can not do type checking for forall(T) AssocOp(List T, concat), i.e. checking List T has SetCategory
            ctorParTypesCopy := instantiateSignature(pars.i, ctorPars.i, ctorParTypesCopy, i)
            ctorparameters := concat(ctorparameters, pars.i)            
          isTypeT?(pars.i) =>
            k := pars.i
            tpOfT := T_typeenv.k
            isCategory? tpOfT =>
              checkCatHasCat(tpOfT, tp) =>
                -- do instantiation using pars.i, ctorPars.i, ctorParTypesCopy 
                ctorParTypesCopy := instantiateSignature(pars.i, ctorPars.i, ctorParTypesCopy, i)
                ctorparameters := concat(ctorparameters, pars.i)
              print(tpOfT::OutputForm)
              print(tp::OutputForm)
              userError "category does not have the expected category"
            userError "the type of T does not have kind category"

          print((pars.i)::OutputForm)
          userError "the input type does not have kind domain"
        userError "the expected type is neither a mapping or category"
      pair(copy ctorparameters, copy funRecords)
    
    containForall?(a: WhereAst): Pair(Boolean, List Syntax) ==
      mainexp := (mainExpression a)::Syntax
      (forall := getOperator mainexp) case Syntax =>
        forall' := forall::Syntax
        assume  := first getOperands mainexp
        (fa := getOperator forall') case Identifier and fa = 'forall::Identifier =>
          pair(true, [forall', assume])
        pair(false, [])
      pair(false, [])

    updateForallTypeEnv(forall: Syntax): Boolean ==
      T_typeenv := empty()
      for s in getOperands forall repeat
        s::SpadAst case ColonAst =>
          s' := s::SpadAst::ColonAst
          id := (lhs s')::Syntax
          tp := (rhs s')::Syntax
          T_typeenv.id := tp
      true


    checkForallAssumption(a: WhereAst, h: List Syntax): Boolean ==
      forall := first h
      assume := second h
      updateForallTypeEnv(forall)
      pars := getOperands first getOperands assume
      aname := (getOperator first getOperands assume)::Identifier
      r := checkCtorCallForm(pars, aname)
      rec : OPASMP := [aname, first r, second r, (qualifier(a)$WhereAst)::Syntax, true]
      L_opasmp := concat(L_opasmp, rec)
      true

    checkAssumption(a: WhereAst): Boolean ==
      first(t := containForall? a) => checkForallAssumption(a, second t)
      T_typeenv := empty()
      pars := getParametersFromAssumption(a)
      aname := getOPCatNameFromAssumption(a)
      r := checkCtorCallForm(pars, aname)
      rec : OPASMP := [aname, first r, second r, (qualifier(a)$WhereAst)::Syntax, false]
      L_opasmp := concat(L_opasmp, rec)
      true

    preprocAssumptions() == 
      preprocOperatorCategories()
      L_opasmp := []
      assumps := parse("usrassumptions.spad")$SpadParser
      for a in assumps repeat
        a' := a::WhereAst
        checkAssumption(a')
      true

    buildAssocCallForm(fname: Identifier, rtn: Syntax): Syntax ==  
      buildSyntax('AssociativeOperator::Identifier, [rtn, fname::Syntax])

    instantiateCatRec(callform: Syntax): List Syntax ==
      cname := getOperator(callform)::Identifier
      pars := getOperands callform
      catrec := first [copy r for r in L_opcats | r.ctorname = cname]
      pars_catrec := catrec.ctorpars
      hascatlist := catrec.hascats
      hascatlist' : List Syntax := copy hascatlist
      for i in 1..#pars repeat
        for j in 1..#hascatlist' repeat
          hascatlist'.j := replace((pars_catrec.i)::Syntax, hascatlist'.j, pars.i)$SyntaxHelper
      hascatlist'
       
    collectAncestors(callform: Syntax): List Syntax ==
      result : List Syntax := []
      callform = buildSyntax('Type::Identifier, []) => result := concat(result, callform)
      r' := instantiateCatRec callform
      result := concat(result, r')
      for anc in r' repeat
        result := concat(result, collectAncestors anc)
      removeDuplicates result
    
    hasAssocOpCatT?(callform: Syntax, op: OPREC): Boolean ==
      searchTarget := buildAssocCallForm(op.funname, target(op.signature))
      callform = searchTarget => true
      ancestors := collectAncestors callform
      member?(searchTarget, ancestors)

    hasAssocOpCat?(callform: Syntax, op: OPREC): Boolean ==
      right := buildAssocCallForm(op.funname, target(op.signature))
      left  := callform
      expression := buildSyntax('has::Syntax::Identifier, [left, right])::InputForm
      retractIfCan((interpret(expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    viewAssumptionList() == L_opasmp

    collectAssociativeOperator() ==
      preprocAssumptions()
      L_assocop := []
      for r in L_opasmp repeat
        callform : Syntax := buildSyntax(r.catname, r.parlist)
        for op in r.funpars repeat
          if r.forall? then
            hasAssocOpCatT?(callform, op) => L_assocop := concat(L_assocop, op)
          else
            hasAssocOpCat?(callform, op) => L_assocop := concat(L_assocop, op)
      L_assocop
      


















