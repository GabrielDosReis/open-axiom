
)abbrev package SYNHELP SyntaxHelper
++ Authors: Yue Li
++ Date Created: November 23, 2009
++ Date Last Updated: April 3, 2010
++ Description: This package provides helper functions for
++ manipulating syntax and ast
SyntaxHelper(): Public == Private where
  Public == with
    getLhs: LetAst -> Syntax
      ++ returns the variable being assigned (the left hand side)
    unlist: Syntax -> List Syntax
      ++ unwraps a compound syntax form into a syntax list containing 
      ++ its operator, and operands
    within?: (Syntax, Syntax) -> Boolean
      ++ checks whether a syntax is a subexpression of another syntax
    listWithin?: (List Syntax, Syntax) -> Boolean
      ++ checks whether each syntax in a syntax list is a subexpression
      ++ of another syntax
    replace: (Syntax, Syntax, Syntax) -> Syntax
      ++ replace(a, b, c)
      ++ replaces all the appearances of a in b with c
    replace: (Syntax, DomainTemplate) -> Syntax
      ++ replace number slots with the elements stored in a domain template 
      ++ those elements are indexed by the numbers in the number slots
    replaceLetRhs: (Syntax, LetAst, Syntax) -> LetAst
      ++ replaceLetRhs(a, b, c)
      ++ replaces all occurrances of a in the rhs(b) with c
    toString: Syntax -> String
      ++ convert a syntax to string for pretty printing purpose
    listColonAst: ColonAst -> List Syntax
      ++ checks whether the left hand side of a ColonAst is a list of variables
      ++ e.g., x, y, z : Integer, if true, return the list of elements.
    hasThenBranch?: IfAst -> Boolean
      ++ checks whether an if statement has then branch
    hasElseBranch?: IfAst -> Boolean
      ++ checks whether an if statement has else branch
    mappingAstToSignature: MappingAst -> Signature
      ++ converts a mapping ast to signature
    isBinaryExpression?: Syntax -> Boolean
      ++ checks whether an expression whose operator is binary
    isJoin?: Syntax -> Boolean
      ++ checks whether a syntax is the one of identifier Join
    isAdd?: Syntax -> Boolean
      ++ checks whether a syntax is the one of identifier Add
    isProgn?: Syntax -> Boolean
      ++ checks whether a syntax is the one of identifier PROGN
    isNil?: Syntax -> Boolean
      ++ checks whether a syntax is the one of identifier nil
    isType?: Syntax -> Boolean
      ++ checks whether a syntax is the one of identifier Type
    isRecord?: Syntax -> Boolean
      ++ checks whether a syntax is the one of identifier Record
    isInteger?: Syntax -> Boolean
      ++ checks whether a syntax is the one of identifier Integer
    isMatrix?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Matrix
    isList?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier List
    isTable?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Table
    isVector?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Vector       
    isTuple?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Tuple
    isUnion?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Union      
    isVoid?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Void
    isExit?: Syntax -> Boolean 
       ++ checks whether a syntax is the one of identifier Exit
    isAny?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Any
    isTrue?: Syntax -> Boolean 
       ++ checks whether a syntax is the one of identifier True       
    isFalse?: Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier False
    isLisp? : Syntax -> Boolean
       ++ checks whether a syntax is the one of identifier Lisp
    isSingleIntegerType?: Syntax -> Boolean
       ++ checks whether a syntax is the one of type SingleInteger
    isNonNegativeIntegerType?: Syntax -> Boolean
       ++ checks whether a syntax is the one of type NonNegativeInteger
    isPositiveIntegerType?: Syntax -> Boolean
       ++ checks whether a syntax is the one of type PositiveInteger
    isIntegerType?: Syntax -> Boolean
       ++ checks whether a syntax is the one of type Integer
    isDoubleFloatType?: Syntax -> Boolean
       ++ checks whether a syntax is the one of type DoubleFloat
    stepAst?: SpadAst -> Boolean
       ++ checks whether a Spad ast is an step ast
    untilAst?: SpadAst -> Boolean
       ++ checks whether a Spad ast is an until ast
    toDomainConstructor: Constructor -> DomainConstructor
      ++ convert a domain constructor with type Constructor 
      ++ to type DomainConstructor
    makeNumberSlot: Integer -> Syntax
      ++ make the syntax of a number slot, e.g., #1
    makeLocalNumberSlot: Integer -> Syntax
      ++ make a compound syntax for a local number slot, e.g., 
      ++ (local #1)
    makeDoubleDollar: () -> Syntax
      ++ creates an uncompound syntax for identifier $$
    makeSetCategory: () -> Syntax
      ++ creates an uncompound syntax for identifier SetCategory
    makeType: () -> Syntax
      ++ creates an uncompound syntax for identifier Type
    makePercentage: () -> Syntax
      ++ creates an uncompound syntax for identifier %
    makeCase: () -> Syntax
      ++ creates an uncompound syntax for identifier Case
    makeTrue: () -> Syntax
      ++ creates an uncompound syntax for identifier True
    makeNil:  () -> Syntax
      ++ creates an uncompound syntax for identifier Nil
    makeJoin: () -> Syntax
      ++ creates an uncompound syntax for identifier Join
    makeUnknown: () -> Syntax
      ++ creates an uncompound syntax for identifier ?
    makeFalse: () -> Syntax
      ++ creates an uncompound syntax for identifier False
    makeOne: () -> Syntax
      ++ creates an uncompound syntax for identifier One
    makeZero: () -> Syntax
      ++ creates an uncompound syntax for identifier Zero
    makeVoid: () -> Syntax
      ++ creates an uncompound syntax for identifier Void
    makeSTEP: () -> Syntax
      ++ creates an uncompound syntax for identifier STEP
    makeMatrix: () -> Syntax 
      ++ creates an uncompound syntax for identifier Matrix
    makeList: () -> Syntax
      ++ creates an uncompound syntax for identifier List
    makeTable: () -> Syntax
      ++ creates an uncompound syntax for identifier Table
    makeVector: () -> Syntax
      ++ creates an uncompound syntax for identifier Vector
    makeSingleInteger: () -> Syntax
      ++ creates an uncompound syntax for identifier SingleInteger
    makeSingleIntegerType: () -> Syntax
      ++ creates a compound syntax for type SingleInteger
    makeNonNegativeInteger: () -> Syntax
      ++ creates an uncompound syntax for identifier NonNegativeInteger
    makeNonNegativeIntegerType: () -> Syntax
      ++ creates a compound syntax for type NonNegativeInteger
    makePositiveInteger: () -> Syntax
      ++ creates an uncompound syntax for identifier PositiveInteger
    makePositiveIntegerType: () -> Syntax
      ++ creates a compound syntax for type PositiveInteger
    makeInteger: () -> Syntax
      ++ creates an uncompound syntax for identifier Integer
    makeIntegerType: () -> Syntax
      ++ creates a compound syntax for type Integer
    makeBoolean: () -> Syntax
      ++ creates an uncompound syntax for identifier Boolean
    makeSymbol: () -> Syntax
      ++ creates an uncompound syntax for identifier Symbol
    makeDoubleFloat: () -> Syntax
      ++ creates an uncompound syntax for identifier DoubleFloat
    makeDoubleFloatType: () -> Syntax
      ++ creates a compound syntax for type DoubleFloat      
    makeString: () -> Syntax
      ++ creates an uncompound syntax for identifier String
    makeIdentifier: () -> Syntax
      ++ creates an uncompound syntax for identifier Identifier
    makeElt: () -> Syntax
      ++ creates an uncompound syntax for identifier elt
    makeCoerce: () -> Syntax
      ++ creates an uncompound syntax for identifier coerce
    makeExit: () -> Syntax
      ++ creates an uncompound syntax for identifier Exit
    makeError: () -> Syntax
      ++ creates an uncompound syntax for identifier error
    makeAny: () -> Syntax
      ++ creates an uncompound syntax for identifier Any
    makeLisp: () -> Syntax
      ++ creates an uncompound syntax for identifier Lisp
    makeConstruct: () -> Syntax
      ++ creates an uncompound syntax for identifier construct
    makeVariable: () -> Syntax
      ++ creates an uncompound syntax for identifier Variable
    makeREDUCE: () -> Syntax
      ++ creates an uncompound syntax for identifier REDUCE
    makeCOLLECT: () -> Syntax
      ++ creates an uncompound syntax for identifier COLLECT
    makeTuple: () -> Syntax
      ++ creates an uncompound syntax for identifier Tuple
    makeUnion: () -> Syntax
      ++ creates an uncompound syntax for identifier Union
    makeUNTIL: () -> Syntax
      ++ creates an uncompound syntax for identifier UNTIL
    makeQelt: () -> Syntax
      ++ creates an uncompound syntax for identifier qelt
    makeRep: () -> Syntax
      ++ creates an uncompound syntax for identifier Rep
    makeLISTOF: () -> Syntax
      ++ creates an uncompound syntax for identifier LISTOF 
    getOperatorName: Syntax -> Identifier
      ++ obtain the operator name of some compound syntax
    isDomain?: Syntax -> Boolean                                                                     
      ++ checks whether a syntax is the one of some domain name
    isCategory?: Syntax -> Boolean                                                                 
      ++ checks whether a syntax is the one of some category name                                  
  Private == add
    import Syntax

    isBinaryExpression?(e: Syntax): Boolean ==
      compound?(e) and #getOperands(e) = 2

    getOperatorName(op: Syntax): Identifier ==
      compound? op =>
        opr := getOperator op
        opr case Identifier and opr::Identifier = 'elt::Identifier =>
          (second getOperands op)::Identifier
        opr case Identifier and opr::Identifier = '_@::Identifier =>
          getOperatorName(first getOperands op)
        opr case Identifier and member?(char "#", entries(toString op)) =>
          opr::Identifier
        print(op::Syntax::OutputForm)
        userError "unexpected operator syntax"
      op case String => (op::String::Symbol) pretend Identifier
      op::Identifier

    toDomainConstructor c == c pretend DomainConstructor

    makeNumberSlot(i: Integer): Syntax ==
      x := concat("#", convert(i)@String)::Symbol
      (x pretend Identifier)::Syntax

    makeLocalNumberSlot(i: Integer): Syntax == 
      l : Identifier := 'local::Identifier
      buildSyntax(l, [makeNumberSlot(i)])

    makeDoubleDollar(): Syntax ==
      x := "$$"::Symbol
      (x pretend Identifier)::Syntax

    getLhs b ==
      l := lhs b
      r := rhs b
      compound?(l::Syntax) and l case ColonAst =>
        k := lhs(l::Syntax::ColonAst)::Syntax
      l::Syntax      

    within?(e: Syntax, set: Syntax): Boolean ==
      e = set => true
      compound? set =>
        for u in unlist set repeat
          within?(e, u) => return true
        false
      false

    listWithin?(vs: List Syntax, s: Syntax): Boolean ==
      for v in vs repeat
        within?(v, s) => return true
      false

    unlist(x: Syntax): List Syntax ==
      compound? x =>
        op := getOperator x
        r : Syntax := convert(convert([])$SExpression)
        if op case Integer then r := op::Integer::Syntax
        if op case DoubleFloat then r := op::DoubleFloat::Syntax
        if op case Identifier then r := op::Identifier::Syntax
        if op case String then r := op::String::Syntax
        if op case Syntax then r := op::Syntax
        ops := getOperands x
        concat(r, ops)
      [x]

    toString x ==
      compound? x =>
        uls : List Syntax := unlist x
        bparts : List String := [toString opd for opd in rest uls]
        body : String := ""
        for bdx in 1..#bparts repeat
          bpart := bparts.bdx
          if bdx < #bparts then
            body := concat([body, bpart, ", "])
          else
            body := concat([body, bpart])
        concat([toString first uls, "(", body, ")"])
      x case Integer => string(x::Integer)
      x case DoubleFloat => 
        userError "DoubleFloat conversion to string is not supported."
      x case String => x::String
      x case Identifier => string(x::Identifier::Symbol)

    replace(needle, haystack, brick) ==
      needle = haystack => brick
      compound? haystack =>
        haystacks : List Syntax := []
        for straw in unlist haystack repeat
          haystacks := concat(haystacks, replace(needle, straw, brick))
        buildSyntax(first haystacks, rest haystacks)
      haystack

    replace(haystack, domtemplate) ==
      haystack case Integer => 
        ind := haystack::Integer::NonNegativeInteger
        s := domtemplate.ind
        replace(s, domtemplate)
      compound? haystack =>
        haystacks : List Syntax := []
        for straw in unlist haystack repeat
          haystacks := concat(haystacks, replace(straw, domtemplate))
        buildSyntax(first haystacks, rest haystacks)
      haystack

    replaceLetRhs(a, b, c) ==
      s := b::Syntax
      op := (getOperator s)::Identifier
      l := first getOperands s
      r := second getOperands s
      r := replace(a, r, c)
      s := buildSyntax(op, [l, r])
      s::SpadAst::LetAst

    makeLISTOF: Syntax                == 'LISTOF::Identifier::Syntax

    listColonAst c ==
      left := lhs(c)::Syntax
      compound? left and_ 
      (opr := getOperator(left)) case Identifier and_
      opr::Identifier = makeLISTOF()::Identifier => getOperands left
      [left]

    makeUnknown: Syntax             == '_?::Identifier::Syntax

    makeJoin: Syntax                == 'Join::Identifier::Syntax

    makeAdd: Syntax                 == 'add::Identifier::Syntax

    makeProgn: Syntax               == 'PROGN::Identifier::Syntax

    makeNil: Syntax                 == 'nil::Identifier::Syntax

    makeType: Syntax                == 'Type::Identifier::Syntax

    makeRecord: Syntax              == 'Record::Identifier::Syntax

    makeSetCategory: Syntax         == 'SetCategory::Identifier::Syntax

    makePercentage: Syntax          == '%::Identifier::Syntax

    makeCase: Syntax                == 'case::Identifier::Syntax

    makeTrue: Syntax                == 'true::Identifier::Syntax

    makeFalse: Syntax                  == 'false::Identifier::Syntax

    makeOne:  Syntax                   == 'One::Identifier::Syntax

    makeZero: Syntax                   == 'Zero::Identifier::Syntax

    makeVoid: Syntax                   == 'Void::Identifier::Syntax

    makeSTEP: Syntax                   == 'STEP::Identifier::Syntax

    makeMatrix: Syntax                 == 'Matrix::Identifier::Syntax

    makeList: Syntax                   == 'List::Identifier::Syntax

    makeTable: Syntax                  == 'Table::Identifier::Syntax

    makeVector: Syntax                 == 'Vector::Identifier::Syntax

    makeSingleInteger: Syntax          == 'SingleInteger::Identifier::Syntax

    makeSingleIntegerType: Syntax      == buildSyntax(makeSingleInteger(), [])

    makeNonNegativeInteger: Syntax     == 'NonNegativeInteger::Identifier::Syntax

    makeNonNegativeIntegerType: Syntax == buildSyntax(makeNonNegativeInteger(), [])

    makePositiveInteger: Syntax        == 'PositiveInteger::Identifier::Syntax

    makePositiveIntegerType: Syntax    == buildSyntax(makePositiveInteger(), [])

    makeInteger: Syntax                == 'Integer::Identifier::Syntax

    makeIntegerType: Syntax            == buildSyntax(makeInteger(), [])

    makeBoolean: Syntax                == 'Boolean::Identifier::Syntax

    makeSymbol: Syntax                 == 'Symbol::Identifier::Syntax

    makeDoubleFloat: Syntax            == 'DoubleFloat::Identifier::Syntax

    makeDoubleFloatType: Syntax        == buildSyntax(makeDoubleFloat(), [])

    makeString: Syntax                 == 'String::Identifier::Syntax

    makeIdentifier: Syntax             == 'Identifier::Identifier::Syntax

    makeElt: Syntax                    == 'elt::Identifier::Syntax

    makeCoerce: Syntax                 == 'coerce::Identifier::Syntax

    makeExit: Syntax                   == 'Exit::Identifier::Syntax

    makeError: Syntax                  == 'error::Identifier::Syntax

    makeAny: Syntax                    == 'Any::Identifier::Syntax

    makeLisp: Syntax                   == 'Lisp::Identifier::Syntax

    makeConstruct: Syntax              == 'construct::Identifier::Syntax

    makeVariable: Syntax               == 'Variable::Identifier::Syntax

    makeREDUCE: Syntax                 == 'REDUCE::Identifier::Syntax

    makeCOLLECT: Syntax                == 'COLLECT::Identifier::Syntax

    makeTuple: Syntax                  == 'Tuple::Identifier::Syntax

    makeUnion: Syntax                  == 'Union::Identifier::Syntax

    makeUNTIL: Syntax                  == 'UNTIL::Identifier::Syntax

    makeQelt: Syntax                   == 'qelt::Identifier::Syntax

    makeRep: Syntax                    == 'Rep::Identifier::Syntax




    isJoin?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => (op::Identifier) = makeJoin() 
        false
      false

    isAdd?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => (op::Identifier) = makeAdd() 
        false
      false

    isProgn?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => (op::Identifier) = makeProgn() 
        false
      false

    isNil?(t: Syntax): Boolean ==
      not compound? t => t = makeNil()
      false

    isType?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => 
          (op::Identifier) = makeType()
        false
      false

    isRecord?(t: Syntax): Boolean ==
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeRecord()
      false

    isInteger?(t: Syntax): Boolean == 
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeInteger()
      false

    isMatrix?(t: Syntax): Boolean == 
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeMatrix()
      false

    isList?(t: Syntax): Boolean == 
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeList()
      false

    isTable?(t: Syntax): Boolean == 
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeTable()
      false

    isVector?(t: Syntax): Boolean == 
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeVector()
      false

    isTuple?(t: Syntax): Boolean == 
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeTuple()
      false

    isUnion?(t: Syntax): Boolean == 
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeUnion()
      false

    isVoid?(t: Syntax): Boolean == 
      (compound? t) and (t = buildSyntax(makeVoid(), []))

    isExit?(t: Syntax): Boolean == 
      (compound? t) and (t = buildSyntax(makeExit(), []))

    isAny?(t: Syntax): Boolean == 
      (compound? t) and (t = buildSyntax(makeAny(), []))

    isTrue?(s: Syntax): Boolean == s = makeTrue()

    isFalse?(s: Syntax): Boolean == s = makeFalse()

    isLisp?(s: Syntax): Boolean == s = makeLisp()

    isSingleIntegerType?(s: Syntax): Boolean == s = makeSingleIntegerType()

    isNonNegativeIntegerType?(s: Syntax): Boolean == 
      s = makeNonNegativeIntegerType()

    isPositiveIntegerType?(s: Syntax): Boolean == s = makePositiveIntegerType()

    isIntegerType?(s: Syntax): Boolean == s = makeIntegerType()

    isDoubleFloatType?(s: Syntax): Boolean == s = makeDoubleFloatType()

    stepAst?(i: SpadAst): Boolean ==
      compound?(i':=i::Syntax) => 
        (op := getOperator i') case Identifier => (op::Identifier) = makeSTEP()
        false
      false
      
    untilAst?(i: SpadAst): Boolean ==
      compound?(i' := i::Syntax) =>
        (op := getOperator i') case Identifier => (op::Identifier) = makeUNTIL()
        false
      false

    hasElseBranch?(f: IfAst): Boolean == 
      not((elseBranch(f)::Syntax) = '%noBranch::Identifier::Syntax) 

    hasThenBranch?(f: IfAst): Boolean == 
      not((thenBranch(f)::Syntax) = '%noBranch::Identifier::Syntax) 

    mappingAstToSignature(m: MappingAst): Signature ==
      src : List Syntax := []
      tar := (target m)::Syntax
      for s in source m repeat
        src := concat(src, s::Syntax)
      signature(src, tar)

    getCtorKind(c: Identifier): ConstructorKind == 
      kind(retract(findConstructor(_
           c)$Constructor)$(Maybe Constructor))$Constructor

    isDomain?(c: Syntax): Boolean ==      
      compound? c and (opr := getOperator c) case Identifier => 
        not(getCtorKind(opr::Identifier) = category$ConstructorKind) and_
        not(getCtorKind(opr::Identifier) = package$ConstructorKind)
      false

    isCategory?(c: Syntax): Boolean ==
      compound? c and (opr := getOperator c) case Identifier => 
        getCtorKind(opr::Identifier) = category$ConstructorKind
      false
