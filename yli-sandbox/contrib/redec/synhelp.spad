)abbrev package SYNHELP SyntaxHelper
++ Authors: Yue Li
++ Date Created: November 23, 2009
++ Date Last Updated: March 20, 2010
++ Description: This package provides helper functions for
++ Syntax and AST manipulations
SyntaxHelper(): Public == Private where
  Public == with
    getLhs: LetAst -> Syntax
      ++ returns the variable being assigned (the left hand side)
    unlist: Syntax -> List Syntax
    within?: (Syntax, Syntax) -> Boolean
    listWithin?: (List Syntax, Syntax) -> Boolean
    replace: (Syntax, Syntax, Syntax) -> Syntax
      ++ replace(a, b, c)
      ++ replace all occurrances of a in b with c
    replace: (Syntax, DomainTemplate) -> Syntax
      ++ replace number slots (not including local number slots) with 
      ++ elements stored in domain template.
    replaceLetRhs: (Syntax, LetAst, Syntax) -> LetAst
      ++ replaceLetRhs(a, b, c)
      ++ replaces all occurrances of a in the rhs(b) with c
    toString: Syntax -> String
      ++ convert a syntax to string for pretty printing purpose
    listColonAst: ColonAst -> List Syntax
      ++ isListOf?(c)
      ++ checks whether the left hand side of a ColonAst is a list such as x, y, z : Integer
      ++ if so, return the list of elements.
    hasThenBranch?: IfAst -> Boolean
      ++ checks whether an if ast has then branch
    hasElseBranch?: IfAst -> Boolean
      ++ checks whether an if ast has else branch
    isBinaryExpression?: Syntax -> Boolean
      ++ checks whether an expression which uses a binary operator
    isJoin?: Syntax -> Boolean
    isAdd?: Syntax -> Boolean
    isProgn?: Syntax -> Boolean
    isNil?: Syntax -> Boolean
    isType?: Syntax -> Boolean
    mappingAstToSignature: MappingAst -> Signature
      ++ converts a mapping ast to signature
    isDomain?: Syntax -> Boolean
    isCategory?: Syntax -> Boolean
    isRecord?: Syntax -> Boolean
    toDomainConstructor: Constructor -> DomainConstructor
      ++ convert a domain constructor with type Constructor to type DomainConstructor
    makeNumberSlot: Integer -> Syntax
    makeLocalNumberSlot: Integer -> Syntax
    makeDoubleDollar: () -> Syntax
    makeSetCategory: () -> Syntax
    makeType: () -> Syntax
    makePercentage: () -> Syntax
      ++ creates an uncompound syntax for identifier %
    makeCase: () -> Syntax
      ++ creates an uncompound syntax for identifier Case
    makeTrue: () -> Syntax
      ++ creates an uncompound syntax for identifier True
    makeNil:  () -> Syntax
      ++ creates an uncompound syntax for identifier Nil
    makeJoin: () -> Syntax
      ++ creates an uncompound syntax for identifier Join
    makeUnknown: () -> Syntax
      ++ creates an uncompound syntax for identifier ?

    getOperatorName: Syntax -> Identifier
      ++ obtain the name of the operator used in a function application form
  Private == add
    import Syntax

    isBinaryExpression?(e: Syntax): Boolean ==
      compound?(e) and #getOperands(e) = 2

    getOperatorName(op: Syntax): Identifier ==
      compound? op =>
        opr := getOperator op
        opr case Identifier and opr::Identifier = 'elt::Identifier =>
          (second getOperands op)::Identifier
        opr case Identifier and opr::Identifier = '_@::Identifier =>
          getOperatorName(first getOperands op)
        opr case Identifier and member?(char "#", entries(toString op)) =>
          opr::Identifier
        print(op::Syntax::OutputForm)
        userError "unexpected operator syntax"
      op case String => (op::String::Symbol) pretend Identifier
      op::Identifier

    toDomainConstructor c == c pretend DomainConstructor

    makeNumberSlot(i: Integer): Syntax ==
      x := concat("#", convert(i)@String)::Symbol
      (x pretend Identifier)::Syntax

    makeLocalNumberSlot(i: Integer): Syntax == 
      l : Identifier := 'local::Identifier
      buildSyntax(l, [makeNumberSlot(i)])

    makeDoubleDollar(): Syntax ==
      x := "$$"::Symbol
      (x pretend Identifier)::Syntax

    getLhs b ==
      l := lhs b
      r := rhs b
      compound?(l::Syntax) and l case ColonAst =>
        k := lhs(l::Syntax::ColonAst)::Syntax
      l::Syntax      

    within?(e: Syntax, set: Syntax): Boolean ==
      e = set => true
      compound? set =>
        for u in unlist set repeat
          within?(e, u) => return true
        false
      false

    listWithin?(vs: List Syntax, s: Syntax): Boolean ==
      for v in vs repeat
        within?(v, s) => return true
      false

    unlist(x: Syntax): List Syntax ==
      compound? x =>
        op := getOperator x
        r : Syntax := convert(convert([])$SExpression)
        if op case Integer then r := op::Integer::Syntax
        if op case DoubleFloat then r := op::DoubleFloat::Syntax
        if op case Identifier then r := op::Identifier::Syntax
        if op case String then r := op::String::Syntax
        if op case Syntax then r := op::Syntax
        ops := getOperands x
        concat(r, ops)
      [x]

    toString x ==
      compound? x =>
        uls : List Syntax := unlist x
        bparts : List String := [toString opd for opd in rest uls]
        body : String := ""
        for bdx in 1..#bparts repeat
          bpart := bparts.bdx
          if bdx < #bparts then
            body := concat([body, bpart, ", "])
          else
            body := concat([body, bpart])
        concat([toString first uls, "(", body, ")"])
      x case Integer => string(x::Integer)
      x case DoubleFloat => userError "DoubleFloat conversion to string is not supported."
      x case String => x::String
      x case Identifier => string(x::Identifier::Symbol)

    replace(needle, haystack, brick) ==
      needle = haystack => brick
      compound? haystack =>
        haystacks : List Syntax := []
        for straw in unlist haystack repeat
          haystacks := concat(haystacks, replace(needle, straw, brick))
        buildSyntax(first haystacks, rest haystacks)
      haystack

    replace(haystack, domtemplate) ==
      haystack case Integer => 
        ind := haystack::Integer::NonNegativeInteger
        s := domtemplate.ind
        replace(s, domtemplate)
      compound? haystack =>
        haystacks : List Syntax := []
        for straw in unlist haystack repeat
          haystacks := concat(haystacks, replace(straw, domtemplate))
        buildSyntax(first haystacks, rest haystacks)
      haystack

    replaceLetRhs(a, b, c) ==
      s := b::Syntax
      op := (getOperator s)::Identifier
      l := first getOperands s
      r := second getOperands s
      r := replace(a, r, c)
      s := buildSyntax(op, [l, r])
      s::SpadAst::LetAst

    makeLISTOF: Syntax                == 'LISTOF::Identifier::Syntax

    listColonAst c ==
      left := lhs(c)::Syntax
      compound? left and_ 
      (opr := getOperator(left)) case Identifier and_
      opr::Identifier = makeLISTOF()::Identifier => getOperands left
      [left]

    makeUnknown: Syntax             == '_?::Identifier::Syntax

    makeJoin: Syntax                == 'Join::Identifier::Syntax

    makeAdd: Syntax                 == 'add::Identifier::Syntax

    makeProgn: Syntax               == 'PROGN::Identifier::Syntax

    makeNil: Syntax                 == 'nil::Identifier::Syntax

    makeType: Syntax                == 'Type::Identifier::Syntax

    makeRecord: Syntax              == 'Record::Identifier::Syntax

    makeSetCategory: Syntax         == 'SetCategory::Identifier::Syntax

    makePercentage: Syntax          == '%::Identifier::Syntax

    makeCase: Syntax                == 'case::Identifier::Syntax

    makeTrue: Syntax                == 'true::Identifier::Syntax

    isJoin?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => (op::Identifier) = makeJoin() 
        false
      false

    isAdd?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => (op::Identifier) = makeAdd() 
        false
      false

    isProgn?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => (op::Identifier) = makeProgn() 
        false
      false

    isNil?(t: Syntax): Boolean ==
      not compound? t => t = makeNil()
      false

    isType?(t: Syntax): Boolean ==
      compound? t =>
        (op := getOperator(t)) case Identifier => (op::Identifier) = makeType()
        false
      false

    isRecord?(t: Syntax): Boolean ==
      compound? t and (x' := getOperator(t)) case Identifier =>
        (x'::Identifier::Syntax) = makeRecord()
      false

    hasElseBranch?(f: IfAst): Boolean == not((elseBranch(f)::Syntax) = '%noBranch::Identifier::Syntax) 

    hasThenBranch?(f: IfAst): Boolean == not((thenBranch(f)::Syntax) = '%noBranch::Identifier::Syntax) 

    mappingAstToSignature(m: MappingAst): Signature ==
      src : List Syntax := []
      tar := (target m)::Syntax
      for s in source m repeat
        src := concat(src, s::Syntax)
      signature(src, tar)


    getCtorKind(c: Identifier): ConstructorKind == 
      kind(retract(findConstructor(c)$Constructor)$(Maybe Constructor))$Constructor

    isDomain?(c: Syntax): Boolean ==      
      compound? c and (opr := getOperator c) case Identifier => 
        not(getCtorKind(opr::Identifier) = category$ConstructorKind) and_
        not(getCtorKind(opr::Identifier) = package$ConstructorKind)
      false

    isCategory?(c: Syntax): Boolean ==
      compound? c and (opr := getOperator c) case Identifier => 
        getCtorKind(opr::Identifier) = category$ConstructorKind
      false
