import SYNHELP

)abbrev package REDANL ReduceAnalysis 
++ Author: Yue Li
++ Date Created: October 27, 2009
++ Date Last Updated: March 20, 2010
++ Description: This package provides functions for extracting reduce function
++ call and reduce forms from function definitions
ReduceAnalysis(): Public == Private where
  Public == with
    extractReduceFormsFromFunctionDefinition: (DefinitionAst, Identifier) -> List Syntax
  Private == add
    analyzeStatement: (SpadAst, Identifier)       -> Integer
    analyzeFunctionDefinition:     (DefinitionAst, Identifier) -> Integer
    count : Integer := 0
    makeReduce:  Syntax                   == 'reduce::Identifier::Syntax
    makeREDUCE:  Syntax                   == 'REDUCE::Identifier::Syntax
    reduceList: List Syntax := []

    -- extracting reduce syntax form from expression
    collectFromExpression(e: Syntax): List Syntax ==
      result: List Syntax := []
      compound? e =>
        if (id:=getOperator e) case Identifier then
          id'  := id::Identifier
          ary  := #(getOperands  e) 
          (id' = makeReduce()::Identifier) and_
          (ary = 2 or ary = 3 or ary = 4) => result := concat(result, e)
          id' = makeREDUCE()::Identifier => result := concat(result, e)
        for u in (unlist e)$SyntaxHelper repeat 
          result := concat(result, collectFromExpression u)
        result
      result

    -- collect the loop ast from a statement
    analyzeStatement(dBody: SpadAst, ctor: Identifier): Integer ==
      if not compound?(dBody::Syntax) then return count
      dBody case SignatureAst =>   count
      dBody case MacroAst =>      count
      dBody case DefinitionAst => 
        analyzeFunctionDefinition(dBody::Syntax::DefinitionAst, ctor)
      dBody case SequenceAst =>
        stmtLst:= body(dBody::Syntax::SequenceAst)
        for stmt in stmtLst repeat
          analyzeStatement(stmt, ctor)
        count
      dBody case IfAst => 
        thBranch :=  thenBranch(dBody::Syntax::IfAst)
        elBranch := elseBranch(dBody::Syntax::IfAst)
        analyzeStatement(thBranch, ctor)
        analyzeStatement(elBranch, ctor)
      dBody case ReturnAst =>
        rtn := expression(dBody::Syntax::ReturnAst)
        analyzeStatement(rtn, ctor)
      dBody case RepeatAst =>
        lpbd := body(dBody::Syntax::RepeatAst)
        analyzeStatement(lpbd, ctor)
      dBody case CoerceAst =>
        coerExp := expression(dBody::Syntax::CoerceAst)
        analyzeStatement(coerExp, ctor)
      dBody case ExitAst =>
        dbexp := expression(dBody::Syntax::ExitAst)
        analyzeStatement(dbexp, ctor)
      dBody case LetAst =>
        right := rhs(dBody::Syntax::LetAst)
        analyzeStatement(right, ctor)
      dBody case WhileAst => count  
      dBody case ColonAst => count
      dBody case ConstructAst => count
      dBody case CollectAst => count
      dBody case CaseAst => count
      dBody case RestrictAst => 
        e := expression(dBody::Syntax::RestrictAst)
        analyzeStatement(e, ctor)
      reduceList := concat(reduceList, collectFromExpression(dBody::Syntax))
      -- we currently don't handle $ annotated reduce or "/" form
      count

    -- collects loop from one function definition
    analyzeFunctionDefinition(defa: DefinitionAst, ctor: Identifier): Integer ==
      hd := head(defa)$DefinitionAst
      functionName := name hd
      sig := signature(defa)$DefinitionAst
      dBody := body(defa)$DefinitionAst
      analyzeStatement(dBody, ctor)
      count

    extractReduceFormsFromFunctionDefinition(d, ctor) ==
      reduceList := []
      analyzeFunctionDefinition(d, ctor)
      copy reduceList













