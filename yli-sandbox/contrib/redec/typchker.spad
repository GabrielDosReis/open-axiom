
)abbrev package TYPCHK TypeChecker
++ Author: Yue Li
++ Date Created: November 7, 2009
++ Date Last Updated: April 6, 2009
++ Description:  
++ This package provides typechecking functions for a subset of Spad language.
TypeChecker(): Public == Private where
  macro FRES == Pair(Boolean, Signature)
  macro TENV == Table(Syntax, Syntax)
  macro VTB  == Table(Syntax, Syntax)
  macro DAST == DefinitionAst
  macro SAST == SequenceAst
  macro LAST == LetAst
  macro IAST == IfAst
  macro RAST == RepeatAst
  macro EAST == ExitAst  
  macro XREC   == Record(funname: Identifier, signature: Signature,_
                         usedin: Syntax, tenv: VTB)
  macro YREC   == Record(loopcandidate: RAST, signaturelist: L XREC)
  macro FREC   == Record(funname: Identifier,_
                         signature: Signature, arity: Integer)
  macro DREC   == Record(funname: Identifier, signature: Signature,_
                  body: DefinitionAst, typeenv: TENV, accumulations: List YREC)
  macro REDU   == Record(reduceexp: Syntax, reduceop: Syntax,_
                         signature: Signature, tenv: VTB)
  macro RREC   == Record(ctorname: Identifier, funname: Identifier,_
                         signature: Signature, reductions: List REDU)
  macro REDF   == Record(reduceform: Syntax, reduceop: Identifier,_
                         signature: Signature, tenv: VTB)
  macro L      == List
  Public == with
    typeCheckFunctionDefinition: DAST -> Syntax
      ++ typeCheckFunctionDefinition(d)
      ++ does type checking for a definition ast
      ++ if the function definition typechecks, the function returns
      ++ the signature of this function
    verifyAccumulationWithType: (DREC, Identifier, L Syntax, L FREC,_
          L FREC, L ImportAst, VTB, L RAST, L L Syntax) -> Pair(TENV, List YREC)
      ++ typechecks the function definition stored in the record passed
      ++ in. It returns the updated record storing typechecked accumulation
      ++ loops, and the signatures of reduction operators used in those loops
    verifyReduceCallAndFormWithType: (DREC, Identifier, L Syntax, L FREC,_
               L FREC, L ImportAst, VTB, L Syntax) -> Pair(List REDU, List REDF)
      ++ typechecks the function definition stored in the record 
      ++ passed in and returns the updated record storing typechecked reduction 
      ++ function calls and reduce forms extracted in the syntactical pattern
      ++ matching phase
    checkGlobalVariableAssignment: (LetAst, TENV, Identifier, L Syntax,_
                        L FREC, L FREC, L ImportAst) -> Syntax
      ++ exported for redupkg.spad
      ++ checks the type of a gloal variable assignment
      ++ in the capsule of a constructor definition
    resolveAnnotatedFunction: (Syntax, List Syntax, Syntax, Identifier, TENV)_
                                 -> Pair(Boolean, Signature)
      ++ Resolves the signature of an operator that is annotated with its domain
  Private == add
    import Syntax
    import SyntaxHelper

    -- forward declarations for boostrapping compilation
    checkIterators: List SpadAst -> Boolean
      ++ does typechecking for each iterator in the list of iterators of a loop
    checkStatement: (SpadAst, Syntax) -> Syntax
      ++ does typechecking for a statement

    -- global variable storing the return type of the current 
    -- function whose definition is being typechecked
    functionReturnType: Syntax := makeUnknown()

    -- type environment for one function definition
    typeEnv: TENV := empty()

    -- global table storing the fresh variables introduced during the 
    -- type inference and their actual values which are assigned when doing 
    -- unifications
    freshVariableMapping: TENV := empty()

    -- global variable for storing the current constructor definition name
    constructorName:       Identifier      := gensym()

    -- global variable for storing the current constructor parameters
    constructorParameters: List Syntax     := []

    -- global database for storing the information of all the local functions
    -- which are not exported by the current type
    localUnexportedSignatureDatabase : L FREC       := []

    -- global database for storing the information of all the functions
    -- which are exported by the current type
    localExportedSignatureDatabase : L FREC         := [] 

    -- list for storing import statement
    importList : List ImportAst                     := []    

    -- global table for storing the mapping between all the macros and their 
    -- actual names used by the current compiler 
    constructorMacros : VTB := empty()

    -- a global list for storing all the potential accumulation loops
    -- these loops are verified via type based semantic pattern matching
    loopCandidates: L RAST                          := []

    -- a global list for storing accumulation variables used in the current
    -- accumulation loop
    accumulationVariableList: L L Syntax            := []

    -- global variable for indexing the current accumulation variable
    -- whose accumulation statement is being typechecked
    accVarListIndex : Integer := 1

    -- global list for storing all the syntax of potential reduce calls and 
    -- potential reduce forms which are passed in from the syntax pattern 
    -- matching phase in redupkg.spad
    reduceCandidates: L Syntax := []

    -- a flag which controls whether the accumulation loop verifier should start
    -- collecting all the signatures of the operators used in the current 
    -- loop
    startCollectSignature? : Boolean := false

    -- global list for storing the signatures of all the operators appeared
    -- inside the accumulation loop currently being verified
    functionSignaturesOfThisLoop : List XREC        := []

    -- global list for storing the typechecked accumulation loops with
    -- the signature of their accumulation operators
    accumulationCandidatesWithSignatures: List YREC := []

    -- global list for storing the typechecked reduce calls with
    -- the signature of their reduction operators
    reduceCandidatesWithSignatures: List REDU       := []

    -- global list for storing the typechecked reduce forms with
    -- the signature of their reduction operators
    reduceFormCandidatesWithSignatures: List REDF := []

    -- global variable for storing the origin domain/category of the
    -- function being resolved
    functionOrigin: Syntax := makeUnknown()

    -- introduce a fresh variable 
    -- this function is used during typechecking
    freshVariable(): Syntax == 
      alpha := (gensym()$Identifier)::Syntax
      freshVariableMapping.alpha := makeUnknown()
      alpha

    -- does macro expansion for a syntax
    macroExpansionForSyntax(s: Syntax): Syntax ==
      s' := s
      for m in keys constructorMacros repeat
        mac := constructorMacros.m
        sub := m
        --if compound? mac then
        --  sub := buildSyntax(m, [])
        s' := replace(sub, s', mac)$SyntaxHelper
      s'

    -- returns the internal representation type of the current domain definition
    extractRep(): Syntax ==
      for k in keys constructorMacros repeat
        k = makeRep() => return (macroExpansionForSyntax(constructorMacros.k))
      makeUnknown()

    -- build a constructor call form with the current constructor name
    -- and the parameters used in the constructor definition
    constructorCallForm(): Syntax == 
      buildSyntax(constructorName, constructorParameters)

    -- checks whether a type syntax is the internal representation type of
    -- declared in the capsule of the current domain definition
    isInternalRepresentationType?(t: Syntax): Boolean == 
      t = makeUnknown() => false
      t = extractRep()

    -- checks whether a type syntax is the current constructor itself
    isMyself?(t: Syntax): Boolean == t = constructorCallForm()

    -- checks whether a variable is a fresh type variable introduced during
    -- type inference
    isFreshTypeVariable?(s: Syntax): Boolean == key?(s, freshVariableMapping)

    -- checks whether a uncompound syntax is a type variable
    isTypeVariable?(tp: Syntax): Boolean == 
      not compound?(tp) and_
      (tp case Identifier) and_
      not isFreshTypeVariable?(tp)

    -- checks whether an operator of a function application is a unary operator
    isUnaryOperator?(s: SpadAst): Boolean ==
      s' := s::Syntax
      compound?(s') and #getOperands(s') = 1

    -- checks whether an operator of a function application is a binary operator
    isBinaryOperator?(s: SpadAst): Boolean ==
      s' := s::Syntax
      compound?(s') and #getOperands(s') = 2

    -- checks whether the syntax is an access form which queries some element
    -- of a container
    isAccessForm?(s: SpadAst): Boolean ==
      -- unary: record, vector, list, Table
      -- binary: matrix m(1, 2)
      (isUnaryOperator?(s) or isBinaryOperator?(s)) => 
        (op := getOperator(s::Syntax)) case Identifier =>
          key?((k := op::Identifier::Syntax), typeEnv) =>  
            not compound?(typeEnv.k) or_
            not ((typeEnv.k)::SpadAst case MappingAst)              
            -- type variable
            -- typeAst but not MappingAst, this should be allowed later (maybe)
          false
        op case Syntax and compound?(op::Syntax)
      false

    -- checks whether a compound syntax is an annotated function application
    isAnnotatedExpression?(e: SpadAst): Pair(Boolean, List Syntax) ==
      (op := getOperator(e::Syntax)) case Syntax =>
        compound?(op::Syntax) and_
        (innerOp := getOperator(op::Syntax)) case Identifier =>
          (innerOp::Identifier::Syntax) = makeElt() => pair(true, getOperands op)
          pair(false, [])
        pair(false, [])
      -- to handle the very buggy 0() function
      --print("come to the correct case"::OutputForm)
      (op' := getOperator(e::Syntax)) case Identifier =>
        opr := getOperands(e::Syntax)
        ((op'::Identifier::Syntax) = makeElt()) and compound?(opr.2) =>
          (innerOp := getOperator(opr.2)) case Identifier => 
            pair(true, [opr.1, innerOp::Identifier::Syntax])
          pair(false, [])
        pair(false, [])
      pair(false, [])

    -- given an container type, e.g., List, Array, etc, figure out 
    -- the type of the element of the container
    getContainerElementType(t: Syntax): Syntax == first getOperands t

    -- obtain the type of the keys of a table from the table's type
    getTableKeyType(t: Syntax): Syntax == first getOperands t

    -- obtain the type of elements stored in a table from the table's type
    getTableContentType(t: Syntax): Syntax == second getOperands t
      
    -- checks the subtyping relationships between integer types
    ((actual: Syntax) < (expect: Syntax)): Boolean ==
      isNonNegativeIntegerType?(actual) and isIntegerType?(expect) => true
      isPositiveIntegerType?(actual) and isIntegerType?(expect) => true
      isPositiveIntegerType?(actual) and isNonNegativeIntegerType?(expect) => true
      isIntegerType?(actual)         and isDoubleFloatType?(expect) => true      
      isPositiveIntegerType?(actual)  and isDoubleFloatType?(expect) => true
      isNonNegativeIntegerType?(actual)  and isDoubleFloatType?(expect) => true
      isSingleIntegerType?(actual) and isDoubleFloatType?(expect) => true
      isSingleIntegerType?(actual) and isIntegerType?(expect) => true
      isSingleIntegerType?(actual) and isNonNegativeIntegerType?(expect) => true
      false

    -- checks the supertyping relationships between integer types
    ((actual: Syntax) > (expect: Syntax)): Boolean ==
      isNonNegativeIntegerType?(expect) and isIntegerType?(actual) => true
      isPositiveIntegerType?(expect) and isIntegerType?(actual) => true
      isPositiveIntegerType?(expect) and isNonNegativeIntegerType?(actual) => true
      isIntegerType?(expect)         and isDoubleFloatType?(actual) => true      
      isPositiveIntegerType?(expect)  and isDoubleFloatType?(actual) => true
      isNonNegativeIntegerType?(expect)  and isDoubleFloatType?(actual) => true      
      isSingleIntegerType?(expect) and isDoubleFloatType?(actual) => true
      isSingleIntegerType?(expect) and isIntegerType?(actual) => true
      isSingleIntegerType?(expect) and isNonNegativeIntegerType?(actual) => true
      false

    -- checks whether two compound syntax have the same operands
    sameOperands?(actual: Syntax, expect: Syntax): Boolean == 
      compound? actual and compound? expect and_
      getOperands(actual) = getOperands(expect)

    -- does unification for two input types. Type unification returns more 
    -- refined one between the actual and expect types
    unification(actual: Syntax, expect: Syntax): Syntax ==
      isFreshTypeVariable?(expect) => freshVariableMapping.expect := actual
      isFreshTypeVariable?(actual) =>  freshVariableMapping.actual := expect
      isExit?(actual) => actual
      isExit?(expect) => expect
      isVoid?(actual) => expect
      isVoid?(expect) => actual
      actual = expect => actual
      actual < expect => actual
      actual > expect => expect 
      isList?(actual) and_
      isVector?(expect) and_
      sameOperands?(actual, expect) => expect
      isList?(actual) and_
      isTuple?(expect) and_
      sameOperands?(actual, expect) => expect
      isList?(actual) and isList?(expect) => 
        buildSyntax(makeList(),_
              [unification(first getOperands actual, first getOperands expect)])
      isUnion?(actual) and member?(expect, getOperands(actual)) => expect
      isUnion?(expect) and member?(actual, getOperands(expect)) => actual
      isInternalRepresentationType?(actual) and isMyself?(expect) => expect
      isMyself?(actual) and isInternalRepresentationType?(expect) => expect
      print(actual::OutputForm)
      print(expect::OutputForm)
      userError "unification error"

    -- extracted the identifier representing the outer most type constructor from a type syntax
    getIdentifier(tp: Syntax): Identifier ==
      not compound?(tp) => 
        print(tp::OutputForm)
        print(typeEnv::OutputForm)
        userError "the type syntax is not compound!"
      (tid := getOperator(tp)) case Identifier => tid::Identifier
      userError "unexpected type of a type identifier"

    -- obtain the constructor of a specific type (not type variable)
    getConstructor(tp: Syntax): Constructor ==
      tid := getIdentifier(tp)
      --print(tp::OutputForm)
      retract(findConstructor(tid)$Constructor)$(Maybe Constructor)

    -- instantiate number slots with category/domain parameters
    instantiateNumberSlots(current: Syntax, t: Syntax): Syntax ==
      typeParameters := getOperands current
      #typeParameters > 0 =>
        for i in 1 .. #typeParameters repeat
          t := replace(makeNumberSlot(i), t, typeParameters.i)$SyntaxHelper
        t
      t

    -- instantiate a percentage with the actual domain
    instantiatePercentages(current: Syntax, t: Syntax): Syntax ==
      replace(makePercentage(), t, current)$SyntaxHelper

    -- does symbolic instantiation for a type syntax in the signature 
    -- we instantiate number slots with category parameters
    instantiateTypeSyntax2(current: Syntax, tvar: Syntax, t: Syntax): Syntax ==
      t' := instantiatePercentages(current, t)
      t' := instantiateNumberSlots(tvar, t')
      t'      

    -- does symbolic instantiation for a type syntax in the signature     
    -- we instantiate number slots with domain parameters
    instantiateTypeSyntax(current: Syntax, t: Syntax): Syntax ==
      t' := instantiatePercentages(current, t)
      t' := instantiateNumberSlots(current, t')
      t'

    -- does symbolic instantiation for the target of a signature
    -- the signature is obtained from a function descriptor
    instantiateTarget2(current: Syntax, tvar: Syntax, tar: Syntax): Syntax ==
      instantiateTypeSyntax2(current, tvar, tar)     

    -- does symbolic instantiation for the target of a signature
    -- the signature is obtained from a function descriptor
    instantiateTarget(current: Syntax, tar: Syntax): Syntax ==
      instantiateTypeSyntax(current, tar)

    -- does symbolic instantiation for the source of a signature
    -- the signature is obtained from a function descriptor
    instantiateSource2(current: Syntax, tvar: Syntax,_
                       src: List Syntax): List Syntax ==
      for i in 1..#src repeat
        src.i := instantiateTypeSyntax2(current, tvar, src.i)
      src      

    -- does symbolic instantiation for the source of a signature
    -- the signature is obtained from a function descriptor
    instantiateSource(current: Syntax, src: List Syntax): List Syntax ==
      for i in 1..#src repeat
        src.i := instantiateTypeSyntax(current, src.i)
      src

    -- instantiate a signature with actual domain and domain parameters
    -- this instantiation is used for instantiating function descriptor obtained
    -- from some category which is implemented by the domain, therefore, the 
    -- instantiation is different from the one used in instantiateSignature
    -- in the sense that the parameter is instantiated with the category's 
    -- parameter not the domain's parameter
    instantiateSignature2(current: Syntax, tvar: Syntax,_
                                                   s: Signature): Signature ==
      -- source s returns the reference to the original 
      -- syntax of the source of the signature
      src := instantiateSource2(current, tvar, copy source s)
      tar := instantiateTarget2(current, tvar, target s)
      signature(src, tar)

    -- instantiate a signature with actual domain and domain parameters
    instantiateSignature(current: Syntax, s: Signature): Signature ==
      src := instantiateSource(current, copy source s)
      tar := instantiateTarget(current, target s)
      signature(src, tar)

    -- create a database record for a category function descriptor database
    -- i.e., extract each function information from each function descriptor, 
    -- symbolically instantiate the function signature with actual 
    -- domain and category parameters (not domain parameters)
    createRecord2(fn: Identifier, x: List FunctionDescriptor,_
                                   current: Syntax, tvar: Syntax): List FREC ==
      result : List FREC := empty()
      for x' in x repeat 
        s := signature x'
        a := #(source s)
        s' := instantiateSignature2(current, tvar, s)
        t : FREC := [fn, s', a]          
        result := concat(result, t)
      result

    -- create a database record for a domain function descriptor database
    -- i.e., extract each function information from each function descriptor, 
    -- symbolically instantiate the function signature with actual domain and 
    -- domain parameters
    createRecord(fn: Identifier, x: List FunctionDescriptor,_
                                                current: Syntax): List FREC ==
      result : List FREC := empty()
      for x' in x repeat
        s := signature x'
        a := #(source s)
        s' := instantiateSignature(current, s)
        t : FREC := [fn, s', a]       
        result := concat(result, t)
      result

    -- creates a database storing all the function descriptors of a specific 
    -- domain. The function descriptors are obtained from the categories that 
    -- the domain implements. Appearances of % and number slot #x in the 
    -- signature of each  function in the database are instantiated by 
    -- the actual domain and domain parameters    
    createCategoryFunctionDescriptorDatabase(current: Syntax, tvar: Syntax,_
                                        opList: List OverloadSet): List FREC ==
      database: List FREC := empty()
      for f in opList repeat
        newRecord := createRecord2(name f, members f, current, tvar)
        database := concat(database, newRecord)
      database

    -- creates a database storing all the function descriptors of a specific 
    -- domain. Appearances of % and number slot #x in the signature of each 
    -- function in the database are instantiated by the actual domain and domain
    -- parameters
    createDomainFunctionDescriptorDatabase(current: Syntax,_
                                  opList: List OverloadSet): List FREC ==
      database: List FREC := empty()
      for f in opList repeat
        newRecord := createRecord(name f, members f, current)
        database := concat(database, newRecord)
      database

    -- does unification for two input types. 
    -- If we can not find a unification for them, we return unknown instead of
    -- throwing a type error
    gentleUnification(actual: Syntax, expect: Syntax): Syntax ==
      isFreshTypeVariable?(expect) => freshVariableMapping.expect := actual
      isFreshTypeVariable?(actual) =>  freshVariableMapping.actual := expect
      isVoid?(actual) => actual
      isVoid?(expect) => expect
      actual = expect => actual
      actual < expect => actual
      actual > expect => expect
      isList?(actual) and_
      isVector?(expect) and_
      sameOperands?(actual, expect) => expect
      isList?(actual) and_
      isTuple?(expect) and_
      sameOperands?(actual, expect) => expect
      isUnion?(actual) and member?(expect, getOperands(actual)) => expect
      isUnion?(expect) and member?(actual, getOperands(expect)) => actual
      makeUnknown()

    -- checks the actual type against the expected type
    -- typechecks here means either there exists a type which is the unification
    -- of the two types, or the actual type is a subtype of the expected type
    compareTypes(l: Syntax, r: Syntax): Boolean ==  
       (gentleUnification(l, r) = r) or (l < r)

    -- given a list of actual types and a list of expected types
    -- this function does typechecking for each type pair, where one
    -- type from the pair is from actual type list and the other one
    -- is from the expected type list
    listTypeChecking(ll: List Syntax, rl: List Syntax): Boolean ==
      for l in ll for r in rl repeat
        if not(compareTypes(l, r)) then 
          return false
      return true

    -- the database entry matching function
    -- compares the search key with a key stored in the table.
    matchRecord?(fn: Identifier, tps: List Syntax,_
                 rtn: Syntax, record: FREC): Boolean ==
      (#tps = record.arity) and_
      (fn = record.funname) and_
      (listTypeChecking(tps, source(record.signature))) and_
      compareTypes(rtn, target(record.signature))

    -- search for the signature of a given function from the function overload 
    -- set of some category constructor, note that, signatures from that set
    -- needs to be instantiated by the domain which implements the category
    searchCurrentCategoryFunctionSet(current: Syntax, tvar: Syntax,_
                                     tps: List Syntax, rtn: Syntax,_
          fn: Identifier, opList: List OverloadSet): Pair(Boolean, Signature) ==
      database:=createCategoryFunctionDescriptorDatabase(current, tvar, opList)
      --print(database::OutputForm)
      for record in database repeat
        -- warning: we don't handle @ annotation (don't use this type to do 
        -- resolution) may add this case in the future, that is pass in the 
        -- return type and compare it here if there is no @, we could use ?.
        if matchRecord?(fn, tps, rtn, record) then
          return pair(true, record.signature)
      pair(false, signature([makeUnknown()], makeUnknown()))

    -- search for the signature of a given function from the function overload 
    -- set of some domain constructor
    searchCurrentFunctionSet(current: Syntax, tps: List Syntax, rtn: Syntax,_
         fn: Identifier, opList: List OverloadSet): Pair(Boolean, Signature) ==
      database := createDomainFunctionDescriptorDatabase(current, opList)
      for record in database repeat
        -- warning: we don't handle @ annotation (don't use this type 
        -- to do resolution) may add this case in the future, that is 
        -- pass in the return type and compare it here if there is 
        -- no @, we could use ?.
        if matchRecord?(fn, tps, rtn, record) then
          return pair(true, record.signature)
      pair(false, signature([makeUnknown()], makeUnknown()))

    -- search for the signature of a given function from the local operator
    -- database
    searchLocalSignatureDatabase(tps: List Syntax, rtn: Syntax,_
                    fn: Identifier, db: List FREC): Pair(Boolean, Signature) ==
      for entry in db repeat
        entry' := copy entry
        entry'.signature := instantiateSignature(buildSyntax(constructorName,_
                                       constructorParameters), entry'.signature)
        matchRecord?(fn, tps, rtn, entry') => 
          return pair(true, entry'.signature)
      pair(false, signature([makeUnknown()], makeUnknown()))

    -- resolve the local functions which are not exported
    resolveLocalFunction(tps: List Syntax, rtn: Syntax, fn: Identifier):_
                                                    Pair(Boolean, Signature) ==
      first(x := searchLocalSignatureDatabase(tps,_
                               rtn, fn, localUnexportedSignatureDatabase)) => x      
      searchLocalSignatureDatabase(tps, rtn, fn, localExportedSignatureDatabase)

    -- extract each element type from a union type
    extractUnionElements(t: Syntax): List Syntax ==
      [e for e in getOperands t | not e case String]

    -- does function resolution for exported functions
    resolveExportedFunction(tps: List Syntax, rtn: Syntax,_
                                  fn: Identifier): Pair(Boolean, Signature) ==
      -- if the type of this parameter is unknown, 
      -- we don't do any resolution, but directly skip
      index: PositiveInteger := 1
      for tp in (tl := concat(tps, rtn)) | not isFreshTypeVariable?(tp) and_
                                           not isRecord?(tp) repeat
        if isTypeVariable?(tp) and key?(tp, typeEnv) then
          tvar := typeEnv.tp -- this type has to be a category
          if isJoin?(tvar) then
            for tvar' in getOperands(tvar) repeat
              catCtor := getConstructor(tvar')
              opList := copy operations catCtor    
              if first(resolutionResult := searchCurrentCategoryFunctionSet(tp,_
                                             tvar', tps, rtn, fn, opList)) then
                return resolutionResult
          else
            catCtor := getConstructor(tvar)
            opList := copy operations catCtor
            --print(catCtor::OutputForm)
            --print(opList::OutputForm)
            if first(resolutionResult := searchCurrentCategoryFunctionSet(tp,_
                                              tvar, tps, rtn, fn, opList)) then
              return resolutionResult
        else if isTypeVariable?(tp) and not key?(tp, typeEnv) then     
          print(tp::OutputForm)
          print(typeEnv::OutputForm)
          userError "the type of this type variable can not be found in type environment"          
        else
          if isUnion?(tp) then
            unionElements : List Syntax := extractUnionElements(tp)
            for ue in unionElements repeat
              tl' := copy tl
              tl'.index := ue
              rtn' := last tl'
              tps' := remove(last tl', tl')
              if first(ufr := resolveExportedFunction(tps', rtn', fn)) then return ufr
          ctor   := getConstructor(tp)
          ary    := arity ctor              
          opList := copy operations ctor
          --print(opList::OutputForm)
          if isNonNegativeIntegerType?(tp) or isPositiveIntegerType?(tp) then 
            opList := concat(opList,_
                           copy(operations(getConstructor(makeIntegerType()))))
          if first(resolutionResult := searchCurrentFunctionSet(tp, tps,_
                                                         rtn, fn, opList)) then
            return resolutionResult
        index := index + 1
      pair(false, signature([makeUnknown()], makeUnknown()))

    -- does function resolution for annotated function calls
    resolveFunctionWithAnnotation(tpAnot: Syntax, tps: List Syntax,_
                  rtn: Syntax, fn: Identifier): Pair(Boolean, Signature) ==
      -- if this function call is annotated using $ with the package/domain name, 
      -- we directly go to that domain/package/category
      -- assumption: we don't handle $%, this annotation looks retard.
      if isTypeVariable?(tpAnot) and key?(tpAnot, typeEnv) then
        tvar := typeEnv.tpAnot
        if isJoin?(tvar) then
          for tvar' in getOperands(tvar) repeat
            catCtor := getConstructor(tvar')
            opList := copy operations catCtor          
            if first(resolutionResult := searchCurrentCategoryFunctionSet(tpAnot, tvar', tps, rtn, fn, opList)) then
              return resolutionResult
        else
          catCtor := getConstructor(tvar)
          opList := copy operations catCtor
          if first(resolutionResult := searchCurrentCategoryFunctionSet(tpAnot, tvar, tps, rtn, fn, opList)) then
            return resolutionResult
      else if isTypeVariable?(tpAnot) and not key?(tpAnot, typeEnv) then
        print(fn::OutputForm)
        print(tps::OutputForm)
        print(rtn::OutputForm)
        print(tpAnot::OutputForm)
        print(typeEnv::OutputForm)
        userError "[Annotated function resolver]: the type of this type variable can not be found in type environment"          
      else
        ctor   := getConstructor(tpAnot)
        ary    := arity ctor              
        opList := copy operations ctor
        if first(resolutionResult := searchCurrentFunctionSet(tpAnot, tps, rtn, fn, opList)) then
          return resolutionResult
      pair(false, signature([makeVoid(), makeVoid()], makeVoid()))

    -- try to resolve a given function from the domain/package/category
    -- imported by the current constructor definition
    resolveFunctionFromImports(tps: List Syntax, rtn: Syntax,_
                               fn: Identifier): Pair(Boolean, Signature) ==
      for il in importList repeat
        for i in imports il repeat
          i' := i::Syntax
          if not compound? i' and not isTypeVariable?(i') then
            i' := buildSyntax(i', [])
          first(r := resolveFunctionWithAnnotation(i', tps, rtn, fn)) => return r
      pair(false, signature([makeVoid(), makeVoid()], makeVoid()))

    --functionResolution: (List Syntax, Syntax, Identifier) -> FRES
      ++ funRsol(tps) 
      ++ takes in the syntax of types of parameters, and find the correct function
      ++ returning its signature
    functionResolution(tps: List Syntax, rtn: Syntax,_
                                  fn: Identifier): Pair(Boolean, Signature) ==
      -- search in the local capsule first, not implemented
      --print(tps::OutputForm)
      functionOrigin := makeUnknown()
      first(lr := resolveLocalFunction(tps, rtn, fn)) => 
        functionOrigin := constructorCallForm() 
        --print("found in locfunresol!"::OutputForm)
        lr
      -- if can not find, search each parameters' type constructors
      first(gr := resolveExportedFunction(tps, rtn, fn)) => gr
      -- if still can not find the function, return false
      -- search in the imported domain/category
      first(ir := resolveFunctionFromImports(tps, rtn, fn)) => ir
      pair(false, signature([makeVoid(), makeVoid()], makeVoid()))

    -- does typechecking for an element access form. 
    -- Instead of directly checking the aceess form syntax, we generate an 
    -- elt function and does typechecking on that
    checkIndexAgainstContainer(typeOfContainer: Syntax,_
                           typeOfIndex: List Syntax, expect: Syntax): Syntax ==
      -- actually the algorithm in this case should 
      -- be adpated to typechecking all the access form
      --isTypeVariable?(typeOfContainer) and (isIntegerType?(typeOfIndex) or isPositiveIntegerType?(typeOfIndex)) => 
      first(r := resolveFunctionWithAnnotation(typeOfContainer,_
       concat(typeOfContainer, typeOfIndex), expect, makeElt()::Identifier)) =>
        unification(target second r, expect)
      print(typeOfContainer::OutputForm)
      print(typeOfIndex::OutputForm)
      userError "the type of index does not match with the container's expectation!"        

    -- obtain the name of the container from an access form
    getContainerName(a: SpadAst): Syntax ==
      (left := getOperator(a::Syntax)) case Identifier => left::Identifier::Syntax
      userError "unexpected type of the container at array access form checking"

    -- does typechecking for each paramere of a function application
    checkOperands(exp: SpadAst): List Syntax ==
      opr :=  getOperands(exp::Syntax)
      compound?(exp::Syntax) and exp case CoerceAst =>
        opr := delete(opr, #opr)
        -- don't do typechecking for the last type annotation, at least for now.
        [checkStatement(operand::SpadAst, freshVariable()) for operand in opr]  
      [checkStatement(operand::SpadAst, freshVariable()) for operand in opr]

    -- does typechecking for record type
    checkRecord(tp: Syntax, indexName: Syntax, expect: Syntax): Syntax ==
      for f in getOperands tp repeat
        first getOperands f = indexName => return unification(second getOperands f, expect)
      print(indexName::OutputForm)
      userError "checking record: can not find the corresponding type of this field"

    -- get all the element type from a union type
    stripUnion(s: Syntax): Syntax ==
      isUnion?(s) => first getOperands s
      s

    -- examine whether the access form is like x.1.2 or rep(x).2
    multiAccess?(a: SpadAst): Boolean == 
      (op := getOperator(a::Syntax)) case Syntax and compound?(op::Syntax)

    -- does typechecking for the access form
    checkAccessForm(a: SpadAst, expect: Syntax): Syntax ==
      typeOfLeft := makeUnknown()
      if multiAccess?(a) then
        typeOfLeft := checkStatement(getOperator(a::Syntax)::Syntax::SpadAst, freshVariable())
      else
        left := getContainerName(a)
        typeOfLeft := typeEnv.left
      if isUnion? typeOfLeft then 
        typeOfLeft := first getOperands typeOfLeft
      isRecord?(typeOfLeft) => 
        checkRecord(typeOfLeft, first(getOperands(a::Syntax)), expect)
      isMyself?(typeOfLeft) and isRecord?(r := extractRep()) => 
        checkRecord(r, first(getOperands(a::Syntax)), expect)
      typeOfRight := checkOperands(a)
      checkIndexAgainstContainer(typeOfLeft, typeOfRight, expect)

    -- obtain the function name from the syntax of a function call
    getFunctionName(e: SpadAst): Identifier ==
      (functionName:= getOperator(e::Syntax)) case Identifier => 
        functionName::Identifier
      print(e::Syntax::OutputForm)
      userError "unexpected type of the operator of the expression"

    -- does typechecking of a collection syntax
    -- e.g. [i for i in 1..10]
    checkCollectAst(c: CollectAst, expect: Syntax): Syntax ==
      checkIterators(iterators c)
      elementExpectType := freshVariable()
      if isList?(expect) or isVector?(expect) then
        elementExpectType := first getOperands expect
      elementType := checkStatement(body c, elementExpectType)
      unification(buildSyntax(makeList(), [elementType]), expect)
        
    -- checks the type of each element in a construct syntax
    checkElements(els: List SpadAst, expect: Syntax): Syntax ==
      expect' := freshVariable()
      if isList?(expect) then 
        expect' := first getOperands expect
      elementTypes : List Syntax := [checkStatement(e, expect') for e in els]
      if ((x := reduce(gentleUnification, elementTypes)) = makeUnknown()) then
        return freshVariable()
      x

    -- collects all the record, vector and list types used in an Union type
    lookForRecLstVecInUnion(u: Syntax): List Syntax ==
      [opr for opr in getOperands(u) |_
       isRecord?(opr) or isVector?(opr) or isList?(opr)]

    -- does typechecking for a list construct syntax
    -- e.g. [1, 2, 3, 4]
    checkConstructAst(c: ConstructAst, expect: Syntax): Syntax ==
      empty? elements c => expect 
      isUnion?(expect) and_
      not empty?(e := lookForRecLstVecInUnion(expect)) => first e 
      isRecord?(expect) or isVector?(expect) => expect
      isMyself?(expect) and isRecord?(extractRep()) => expect
      elementType := checkElements(elements c, expect)
      unification(buildSyntax(makeList(), [elementType]), expect)

    -- does typechecking for has statement
    checkHasAst(h: HasAst, expect: Syntax): Syntax == 
      -- need to check the expressions of HasAst first, 
      -- but we do a simple version here.
      unification(buildSyntax(makeBoolean(), []), expect)

    -- does typechecking for pretend expression 
    checkPretendAst(p: PretendAst, expect: Syntax): Syntax == 
      -- need to check the expression of PretendAst first, 
      -- but we do a simple version here.
      unification(target(p)::Syntax, expect)

    -- does typechecking for RestrictAst
    checkRestrictAst(r: RestrictAst, expect: Syntax): Syntax ==
      target(r)::Syntax

    -- checks whether an ast is a reduce form
    isReduceForm?(r: SpadAst): Boolean ==
      r' := r::Syntax
      not compound? r' => false
      (id := getOperator(r::Syntax)) case Identifier and_ 
      (id::Identifier) = (makeREDUCE()::Identifier) => 
        true
      false

    -- a global environment for storing all the types of the type variables 
    -- used in some type syntax
    typeOfTypeVariable: VTB := empty()

    -- obtain the type of each type variable used in a type syntax
    checkTypeofTypeVariablesInType(t: Syntax): Void ==
      isTypeVariable?(t) =>
        key?(t, typeEnv) =>
          tp := typeEnv.t
          typeOfTypeVariable.t := tp
          checkTypeofTypeVariablesInType tp
      isFreshTypeVariable?(t) => void()
      t case String or t case Integer or t case DoubleFloat => void()
      not compound? t =>
        print(t::OutputForm)
        userError "unexpected uncompound type syntax"
      for opr in (oprs := getOperands t) repeat
        checkTypeofTypeVariablesInType opr

    -- obtain the type of each type variable which appears in a signature
    checkTypeofTypeVariablesInSignature(sig: Signature): VTB ==
      typeOfTypeVariable := empty()
      for t in concat(source sig, target sig) repeat
        checkTypeofTypeVariablesInType t
      typeOfTypeVariable

    -- this helper function does the opposite direction of 
    -- the symbolic instantiation for % appeared in a function signature
    replaceSignatureBack(s: Signature, callform: Syntax): Signature ==
      src := copy source s
      tar := target s
      for i in 1..#src repeat
        src.i := replace(callform, src.i, makePercentage())$SyntaxHelper
      tar := replace(callform, tar, makePercentage())$SyntaxHelper
      signature(src, tar)

    -- checks whether the call form constructed from the current constructor
    -- name and parameters has been replaced into some type of a signature
    callformWithinSignature?(s: Signature, callform: Syntax): Boolean ==
      for s' in concat(source s, target s) repeat
        within?(callform, s')$SyntaxHelper => return true
      false

    -- does typechecking for a reduce form
    checkReduceAst(r: SpadAst, expect: Syntax): Syntax ==
      lst := getOperands(r::Syntax).last
      isList?(lstTyp := checkStatement(lst::SpadAst, freshVariable())) => 
        t := unification(first getOperands lstTyp, expect)
        op := first(getOperands(r::Syntax))::Identifier
        sig := signature([t, t], t)$Signature
        rec : REDF := [r::Syntax, op, sig, checkTypeofTypeVariablesInSignature sig]
        if isCategory?(constructorCallForm())$SyntaxHelper and_
           callformWithinSignature?(rec.signature, constructorCallForm()) then
          rec.signature := replaceSignatureBack(rec.signature, constructorCallForm())
          k := makePercentage()
          tb := copy rec.tenv
          tb.k := constructorCallForm()
          rec.tenv := copy tb 
        reduceFormCandidatesWithSignatures := concat(reduceFormCandidatesWithSignatures, rec)
        t
      userError "the last operand in REDUCE form is not a list"
    
    -- does typechecking for each parameter of an expression
    checkOperands2(exp: SpadAst, ats: List Syntax, ets: List Syntax): List Syntax ==
      refinedOperandTypes : List Syntax := copy ats
      opr :=  getOperands(exp::Syntax)
      if compound?(exp::Syntax) and exp case CoerceAst then
        opr := delete(opr, #opr)
      for i in 1..#refinedOperandTypes for expectType in ets repeat
        if isFreshTypeVariable?(ats.i) then
          refinedOperandTypes.i := checkStatement((opr.i)::SpadAst, expectType)    
      refinedOperandTypes

    -- does typechecking for unannotated expression
    checkUnannotatedExpression(e: SpadAst, expect: Syntax): Syntax ==
      -- 1. unary and is in array access form
      -- 2. normal expressions, 0-aryity, unary, binary, ...
      e case RestrictAst  => checkRestrictAst(e::Syntax::RestrictAst, expect)
      e case PretendAst   => checkPretendAst(e::Syntax::PretendAst, expect)
      e case HasAst       => checkHasAst(e::Syntax::HasAst, expect)
      e case CollectAst   => checkCollectAst(e::Syntax::CollectAst, expect)
      e case ConstructAst => 
        --print("ready to check construct"::OutputForm)
        --print(expect::OutputForm)
        checkConstructAst(e::Syntax::ConstructAst, expect)
      isReduceForm?(e)    => checkReduceAst(e, expect)  -- unannotated expression only
      isAccessForm?(e)    => checkAccessForm(e, expect) -- can handle List, Vector, Table only

      -- obtain function name
      functionName: Identifier
      typesOfOperands := checkOperands(e)
      typeOfReturn := expect
      if (e case CoerceAst) then
        functionName := makeCoerce()::Identifier
        typeOfReturn := target(e::Syntax::CoerceAst)::Syntax
        return typeOfReturn
      else
        functionName := getFunctionName(e)

      -- by default 0 has type NonNegativeInteger
      functionName = makeZero() => unification(freshVariable(), expect)
      -- by default 1 has type PositiveInteger
      functionName = makeOne() =>  unification(freshVariable(), expect)
      (functionName = makeError()::Identifier) => return unification(buildSyntax(makeExit(), []), expect) 
  
      if functionName = 'reduce::Identifier and #typesOfOperands > 1 and isList?(typesOfOperands.2) then
        elementType := first(getOperands(typesOfOperands.2))
        typesOfOperands.1 := (signature([elementType, elementType], elementType)$Signature)::MappingAst::Syntax


      t := functionResolution(typesOfOperands, typeOfReturn, functionName)
      first t =>
        --print("after fun resol1!!!"::OutputForm)
        if startCollectSignature? and_
           #(oprs:=getOperands(e::Syntax)) = 2 and_
           (member?(oprs.1, accumulationVariableList.accVarListIndex) or member?(oprs.2, accumulationVariableList.accVarListIndex)) then
          rec : XREC := [functionName, second t, e::Syntax, checkTypeofTypeVariablesInSignature second t]
          if isCategory?(constructorCallForm())$SyntaxHelper and callformWithinSignature?(rec.signature, constructorCallForm()) then
            rec.signature := replaceSignatureBack(rec.signature, constructorCallForm())
            k := makePercentage()
            tb := copy rec.tenv
            tb.k := constructorCallForm()
            rec.tenv := copy tb 
          functionSignaturesOfThisLoop := concat(functionSignaturesOfThisLoop, rec)


        if not empty? reduceCandidates and functionName = 'reduce::Identifier::Syntax::Identifier and_ 
           (#typesOfOperands =2 or #typesOfOperands = 3 or #typesOfOperands = 4) and_
           compound?(fop := (first source second t)) and  fop::SpadAst case MappingAst then
          rec : REDU := [e::Syntax, first(getOperands(e::Syntax)), x := mappingAstToSignature(fop::SpadAst::MappingAst)$SyntaxHelper, checkTypeofTypeVariablesInSignature x]
          if isCategory?(constructorCallForm())$SyntaxHelper and callformWithinSignature?(rec.signature, constructorCallForm()) then
            rec.signature := replaceSignatureBack(rec.signature, constructorCallForm())
            k := makePercentage()
            tb := copy rec.tenv
            tb.k := constructorCallForm()
            rec.tenv := copy tb 
          reduceCandidatesWithSignatures := concat(reduceCandidatesWithSignatures, rec)

        typesOfOperands' := checkOperands2(e::SpadAst, typesOfOperands, source second t) --, typeOfOperands@(List Syntax), source second t)
        for actualType in typesOfOperands' for expectType in source second t repeat
          unification(actualType, expectType)
        unification(target second t, expect)
      print("[Unannotated function resolver] function can not be resolved, but we continue"::OutputForm)
      print(functionName::OutputForm)
      print(typesOfOperands::OutputForm)
      freshVariable()

    -- does typechecking for each parameters of an annotated function application
    checkOperandsInAnnotatedExpression(functionName: Syntax,_
                                       e: SpadAst): List Syntax == 
      checkOperands(e)

    -- does typechecking for an annotated expression/function application
    checkAnnotatedExpression(e: SpadAst, eltOperands: List Syntax, expect: Syntax): Syntax ==
      -- access form won't be used with $ sign at the same time
      tpAnot := first eltOperands
      functionName := second eltOperands

      -- if this is an annotated construct, then just return the type annotation.
      (functionName = makeConstruct()) => unification(tpAnot, expect)
      -- if this is an annotated collect, also just return the type annotation.
      (functionName = makeCOLLECT()) => unification(tpAnot, expect)
      (functionName = makeZero()) => unification(tpAnot, expect)
      (functionName = makeOne()) => unification(tpAnot, expect)

      typesOfOperands := checkOperandsInAnnotatedExpression(functionName, e)
      typeOfReturn := expect

      first (t:= resolveFunctionWithAnnotation(tpAnot, typesOfOperands, typeOfReturn, functionName)) =>
        if startCollectSignature? and_
           #(oprs:=getOperands(e::Syntax)) = 2 and_
           (member?(oprs.1, accumulationVariableList.accVarListIndex) or member?(oprs.2, accumulationVariableList.accVarListIndex)) then
          rec : XREC := [functionName::Identifier, second t, e::Syntax, checkTypeofTypeVariablesInSignature second t]
          functionSignaturesOfThisLoop := concat(functionSignaturesOfThisLoop, rec)

        if not empty? reduceCandidates and functionName = 'reduce::Identifier::Syntax and_ 
           (#typesOfOperands =2 or #typesOfOperands = 3 or #typesOfOperands = 4) and_
           compound?(fop := (first source second t)) and  fop::SpadAst case MappingAst then
          rec : REDU := [e::Syntax, first(getOperands(e::Syntax)), x := mappingAstToSignature(fop::SpadAst::MappingAst)$SyntaxHelper, checkTypeofTypeVariablesInSignature x]
          reduceCandidatesWithSignatures := concat(reduceCandidatesWithSignatures, rec)

        typesOfOperands' := checkOperands2(e, typesOfOperands, source second t)   
        for actualType in typesOfOperands' for expectType in source second t repeat
          unification(actualType, expectType)        
        unification(target second t, expect)
      print("[Annotated function resolver] function can not be resolved, but we continue"::OutputForm)
      print(functionName::OutputForm)
      print(typesOfOperands::OutputForm)
      freshVariable()
 
    -- does typechecking for an expression
    checkExpression(e: SpadAst, expect: Syntax): Syntax ==
      first (judge := isAnnotatedExpression?(e)) => 
        isLisp?(tpanot := first second judge) => expect
        checkAnnotatedExpression(e, second judge, expect)
      -- note that, the parser does a simplification to eliminate the annotation of coerce ast.
      -- therefore, coerceAst will never be annotated after parsing.
      checkUnannotatedExpression(e, expect)

    -- dose typechecking for a colon ast
    checkColon(c: ColonAst, expect: Syntax): Syntax ==
      -- if left hand side is varaible, just directly update type environment
      -- assumption: we don't check the type on the rhs is instantiated correctly
      not compound?(v := ((lhs c)::Syntax)) => 
        typeEnv.v := rhs(c)::Syntax      
      -- check LISTOF e.g. x, y: Integer
      compound? v and_ 
      (opr:= getOperator v) case Identifier and_
      opr::Identifier = makeLISTOF()::Identifier =>
        tp := rhs(c)::Syntax 
        for e in getOperands v repeat typeEnv.v := tp
      not(checkStatement(lhs(c), freshVariable()) = rhs(c)::Syntax) => 
        print(lhs(c)::OutputForm)
        userError "Left hand side of the colon ast does not have the expected type"
      unification(buildSyntax(makeInteger(), []), expect)

    -- does typechecking for the expression on the left hand side of an
    -- assignment
    checkLeftofLet(left: SpadAst, expect: Syntax): Syntax ==
      left' := left::Syntax
      compound?(left') => 
        (left case ColonAst) => 
          checkColon(left'::ColonAst, buildSyntax(makeVoid(), []))
          lv := lhs(left'::ColonAst)::Syntax
          unification(typeEnv.lv, expect)
        checkStatement(left, expect)
      -- if the left hand side is not in the type environment, return Void, meaning that
      -- the type is going to be infered from the right hand side of the let ast
      not(key?(left', typeEnv)) => unification(freshVariable(), expect) -- don't know what's the type right now
      unification(typeEnv.left', expect)

    -- does typechecking for the expression on the right hand side of an 
    -- assignment
    checkRightofLet(right: SpadAst, expect: Syntax): Syntax ==
      --print("checking right of let"::OutputForm)
      --print(expect::OutputForm)
      checkStatement(right, expect)

    -- does typechecking for an assignment
    checkLet(l: LAST, expect: Syntax): Syntax ==
      k := (getLhs l)$SyntaxHelper
      lt := checkLeftofLet(lhs l, expect)
      rt := checkRightofLet(rhs l, lt)
      isFreshTypeVariable?(t := unification(lt, rt)) =>
        (rhs l)::Syntax = buildSyntax(makeZero(), []) => 
          typeEnv.k := unification(makeNonNegativeIntegerType(), expect)
        (rhs l)::Syntax = buildSyntax(makeOne(), []) =>  
          typeEnv.k := unification(makePositiveIntegerType(), expect)
        expect
      isFreshTypeVariable?(lt) => 
        typeEnv.k := unification(lt, rt)
      t := unification(rt, expect)
      
    -- does typechecking for an exit ast
    checkExit(e: EAST, expect: Syntax): Syntax ==
      unification(checkStatement(expression e, expect), expect)

    -- does typechecking for an if-statement
    checkIf(f: IAST, expect: Syntax): Syntax ==
      thBranch := thenBranch f
      elBranch := elseBranch f
      typeOfThen := freshVariable()
      typeOfElse := freshVariable()
      -- check condition
      checkStatement(condition f, buildSyntax(makeBoolean(), []))
      -- check the body of the if statement
      hasElseBranch?(f) and not hasThenBranch?(f) =>
        typeOfElse := checkStatement(elBranch, expect)
        unification(typeOfElse, expect)
      hasThenBranch?(f) and not hasElseBranch?(f) =>
        typeOfThen := checkStatement(thBranch, expect)
        unification(typeOfThen, expect)
      typeOfThen := checkStatement(thBranch, expect)
      typeOfElse := checkStatement(elBranch, expect)

    -- does typechecking for an InAst used in loop iterator
    checkIn(i: InAst): Syntax ==
      typeOfSequence := checkStatement(sequence i, freshVariable())  
        -- this is a lie, actually we know we expect List of something
      typeOfSequence := stripUnion(typeOfSequence)
      iterationVariable := (iterationVar i)::Syntax
      -- the sequence right now can only be list
      getIdentifier(typeOfSequence) = makeList() => 
        typeEnv.iterationVariable := first getOperands typeOfSequence
        buildSyntax(makeVoid(), [])
      isMyself?(typeOfSequence) and isList?(rp := extractRep()) => 
        typeEnv.iterationVariable := first getOperands rp
        buildSyntax(makeVoid(), [])
      userError "the sequence is not a list"

    -- does typechecking for a whileAst used in loop iterator
    checkWhile(i: WhileAst): Syntax ==
      cond := first getOperands(i::Syntax)
      checkStatement(cond::SpadAst, buildSyntax(makeBoolean(), []))
      buildSyntax(makeVoid(), [])

    -- does typechecking for an until ast used in loop iterator
    checkUntil(i: SpadAst): Syntax ==
      cond := first getOperands(i::Syntax)
      checkStatement(cond::SpadAst, buildSyntax(makeBoolean(), []))
      buildSyntax(makeVoid(), [])
      
    -- checks whether a step iterator specifies the upper bound of the iterator
    endless?(i: SpadAst): Boolean ==
      #getOperands(i::Syntax) = 3

    -- does typechecking for an element in the step ast
    checkStepElement(typeOfElement: Syntax): Syntax ==
      unification(typeOfElement, makeIntegerType())

    -- does typechecking for an endless step ast, i.e., it does not have bound
    checkEndLessStep(typeOfBegin: Syntax, typeOfStep: Syntax,_
                                         iterationVariable: Syntax): Syntax ==
      checkStepElement(typeOfBegin)
      checkStepElement(typeOfStep)
      typeEnv.iterationVariable := typeOfBegin
      buildSyntax(makeVoid(), [])

    -- does typechecking for a step ast whose end
    checkWithEndStep(typeOfBegin: Syntax, typeOfStep: Syntax,_
                      typeOfEnd: Syntax, iterationVariable: Syntax): Syntax ==
      checkStepElement(typeOfBegin)
      checkStepElement(typeOfStep)
      checkStepElement(typeOfEnd)
      typeEnv.iterationVariable := typeOfBegin
      buildSyntax(makeVoid(), [])      

    -- does typechecking for a step ast
    checkStep(i: SpadAst): Syntax ==
      stepElements := getOperands(i::Syntax)
      iterationVariable := stepElements.1
      typeOfBegin := checkStatement((stepElements.2)::SpadAst, makeIntegerType())
      typeOfStep  := checkStatement((stepElements.3)::SpadAst, makeIntegerType())      
      endless?(i) => checkEndLessStep(typeOfBegin, typeOfStep, iterationVariable)
      typeOfEnd   := checkStatement((stepElements.4)::SpadAst, makeIntegerType())
      checkWithEndStep(typeOfBegin, typeOfStep, typeOfEnd, iterationVariable)
      buildSyntax(makeVoid(), [])

    -- does typechecking for SuchThatAst which is
    -- used as loop predicate in a loop iterator
    checkSuchThat(i: SuchThatAst): Syntax ==
      checkStatement(predicate(i), buildSyntax(makeBoolean(), []))

    -- does typechecking for a iterator of a loop
    checkIterator(i: SpadAst): Syntax ==
      i case InAst       => checkIn(i::Syntax::InAst)
      stepAst?(i)        => checkStep(i)
      i case SuchThatAst => checkSuchThat(i::Syntax::SuchThatAst)
      i case WhileAst    => checkWhile(i::Syntax::WhileAst)
      untilAst?(i)       => checkUntil(i)
      print(i::Syntax::OutputForm)
      userError "unexpected iterator kind"

    -- does typechecking for all the iterators of a loop
    checkIterators(its: List SpadAst): Void ==
      for it in its repeat checkIterator(it)

    -- checks whether the current loop is an accumulation candidate
    member?(r: RAST, rl: List RAST): Boolean ==
      l : List Syntax := [e::Syntax for e in rl]
      member?(r::Syntax, l)

    -- does typechecking for a loop
    checkRepeat(r: RAST, expect: Syntax): Syntax ==
      if member?(r, loopCandidates) then
        startCollectSignature? := true
        functionSignaturesOfThisLoop := []
      its := iterators r
      checkIterators(its)
      checkStatement(body r, freshVariable())
      if member?(r, loopCandidates) then
        rec : YREC := [r, copy functionSignaturesOfThisLoop]
        accumulationCandidatesWithSignatures :=_
          concat(accumulationCandidatesWithSignatures, rec)
        startCollectSignature? := false
        functionSignaturesOfThisLoop := []
        accVarListIndex := accVarListIndex + 1
      unification(buildSyntax(makeVoid(), []), expect)

    -- does typechecking for all the statements in a sequence 
    -- except the last one
    checkFirstFew(s: SAST): Void ==
      for s' in body s | not((s'::Syntax) = (last body s)::Syntax) repeat 
        checkStatement(s', freshVariable())

    -- does type checking for the last statement of a sequence
    checkLast(s: SAST, expect: Syntax): Syntax ==
      checkStatement(last body s, expect)

    -- does typechecking for a sequence statement
    checkSequence(s: SAST, expect: Syntax): Syntax ==
      checkFirstFew(s)
      unification(checkLast(s, expect), expect)

    -- updates type environment with the type of parameters of 
    -- the current function definition
    updateTypeEnvironmentWithParameterType(pars: List Identifier,_
                                           ptps: List Syntax): Void ==
      for i in 1..#pars repeat
        k := (pars.i)::Syntax
        typeEnv.k := ptps.i
    
    -- checks whether a function is exported in the constructor definition
    inLocalExported?(s: Syntax): Pair(Boolean, Syntax) ==
      for rec in localExportedSignatureDatabase repeat
        s = (rec.funname)::Syntax => 
          return pair(true, (rec.signature)::MappingAst::Syntax)
      pair(false, s)

    -- checks whether a function is an unexported function of the constructor
    inLocalUnexported?(s: Syntax): Pair(Boolean, Syntax) ==
      for rec in localUnexportedSignatureDatabase repeat
        s = (rec.funname)::Syntax => 
          return pair(true, (rec.signature)::MappingAst::Syntax)
      pair(false, s)
        
    -- checks the type of a variable
    checkVariable(s: Syntax, expect: Syntax): Syntax ==
      isTrue?(s) or isFalse?(s)    => 
        unification(buildSyntax(makeBoolean(), []), expect)
      s case Integer               => 
        unification(buildSyntax(makeInteger(), []), expect)
      s case String                =>
        s = "failed"::Syntax => s
        unification(buildSyntax(makeString(), []), expect)
      s case DoubleFloat           => 
        unification(buildSyntax(makeDoubleFloat(), []), expect)
      key?(s, typeEnv)             => 
        unification(typeEnv.s, expect)
      first(r := inLocalExported?(s))   => 
        unification(second r, expect)
      first(t := inLocalUnexported?(s)) => 
        unification(second t, expect)
      unification(freshVariable(), expect)
      
    -- does typechecking for a return statement
    checkReturn(s: ReturnAst, expect: Syntax): Syntax == 
      exp := (first(getOperands(s::Syntax)))::SpadAst
      checkStatement(exp, functionReturnType)

    -- does typechecking for a case statement
    checkCase(s: CaseAst, expect: Syntax): Syntax ==
      checkStatement(lhs s, freshVariable())
      unification(buildSyntax(makeBoolean(), []), expect)

    -- checks the type of a statement
    checkStatement(s: SpadAst, expect: Syntax): Syntax ==
      not compound?(s::Syntax)  => checkVariable(s::Syntax, expect)
      s case LetAst             => checkLet(s::Syntax::LetAst, expect)
      s case SequenceAst        => checkSequence(s::Syntax::SequenceAst, expect)
      s case IfAst              => checkIf(s::Syntax::IfAst, expect)
      s case RepeatAst          => checkRepeat(s::Syntax::RepeatAst, expect)
      s case ExitAst            => checkExit(s::Syntax::ExitAst, expect)
      s case ColonAst           => checkColon(s::Syntax::ColonAst, expect)
      s case ReturnAst          => checkReturn(s::Syntax::ReturnAst, expect)
      s case CaseAst            => checkCase(s::Syntax::CaseAst, expect)
      checkExpression(s, expect)

    -- initializes type environment and the table for storing
    -- fresh variables which are used in type inference algorithm
    cleanUp(): Void ==
      typeEnv := empty()
      freshVariableMapping := empty()

    -- checks the type of a gloal variable assignment
    -- in the capsule of a constructor definition
    checkGlobalVariableAssignment(l: LetAst, env: TENV, ctorName: Identifier,_
                      ctorPars: List Syntax, exported: L FREC,_
                      unexported: L FREC, importLst: L ImportAst): Syntax ==
      cleanUp()
      -- for local function resolution using
      constructorName       := ctorName
      constructorParameters := ctorPars
      importList            := importLst
      typeEnv               := copy env
      localExportedSignatureDatabase := exported
      localUnexportedSignatureDatabase := unexported
      checkLet(l, freshVariable())

    -- initialize the unexported function information
    updateUnexportedListWithGlobalMappingAst(gte: TENV): Void ==
      for k in keys gte repeat
        not compound? k and_
        compound?(t := gte.k) and_
        (t::SpadAst) case MappingAst => 
          s : Signature :=_
                     mappingAstToSignature(t::SpadAst::MappingAst)$SyntaxHelper
          a := #source(s)
          r : FREC := [k::Identifier, s, a]
          localUnexportedSignatureDatabase :=_
            concat(localUnexportedSignatureDatabase, r)

    -- setup global variables before verifying accumulations
    setupGlobalVariables1(r: DREC, ctorName: Identifier,_
                               ctorPars: List Syntax, exported: L FREC,_
                               unexported: L FREC, importLst: L ImportAst,_
                               macroTable: VTB, potentialReductions: L RAST,_
                               accVars: L L Syntax): Void ==
      sig := r.signature
      src := source sig
      tar := target sig
      functionReturnType := tar
      fn := r.funname
      pars := parameters head r.body
      -- set up global variables
      constructorName       := ctorName
      constructorParameters := ctorPars
      importList            := importLst
      typeEnv               := copy r.typeenv      
      updateTypeEnvironmentWithParameterType(pars, src)
      localExportedSignatureDatabase := exported
      localUnexportedSignatureDatabase := unexported
      updateUnexportedListWithGlobalMappingAst(typeEnv)
      constructorMacros := copy macroTable
      loopCandidates := potentialReductions
      accumulationVariableList := accVars
      accVarListIndex := 1

    -- setup global variables before verifying reduce calls and forms
    setupGlobalVariables2(r: DREC, ctorName: Identifier, ctorPars: List Syntax,_
                            exported: L FREC, unexported: L FREC,_
                            importLst: L ImportAst, macroTable: VTB,_
              potentialReductionForms: L Syntax): Void ==
      sig := r.signature
      src := source sig
      tar := target sig
      functionReturnType := tar
      fn := r.funname
      pars := parameters head r.body
      -- global setting up
      constructorName       := ctorName
      constructorParameters := ctorPars
      importList            := importLst
      typeEnv               := copy r.typeenv
      updateTypeEnvironmentWithParameterType(pars, src)
      localExportedSignatureDatabase   := exported
      localUnexportedSignatureDatabase := unexported
      updateUnexportedListWithGlobalMappingAst(typeEnv)
      constructorMacros := copy macroTable
      reduceCandidates  := potentialReductionForms

    -- print the information of the current function being checked
    printCurrentFunction(rec: DREC): Void ==
      print((rec.funname)::OutputForm)
      print((rec.signature)::OutputForm)

    -- checks the type of a function definition
    typeCheckFunctionDefinition(d: DefinitionAst): Syntax ==
      -- obtain type information from type parameter
      -- 1. obtaining types
      sig := signature d
      src := source sig
      tar := target sig
      functionReturnType := tar       -- for checking ReturnAst
      -- 2. obtaining parameters
      fn  := name head d
      pars := parameters head d
      -- 3. update type environment
      updateTypeEnvironmentWithParameterType(pars, src)
      -- 4. check the body, obtaining the resulting type
      rtp := checkStatement(body d, tar)
      --rtp ~= tar => userError "resultant type does not match the signature"
      unification(rtp, tar) ~= rtp => 
        print(fn::OutputForm)
        print(sig::OutputForm)
        userError "resultant type does not refine the target type in the signature"
      buildSyntax(rtp, src)

    -- verify accumulation loops by checking the reduction operators' types
    verifyAccumulationWithType(rec: DREC, ctorName: Identifier,_
                               ctorPars: List Syntax, exported: L FREC,_
                               unexported: L FREC, importLst: L ImportAst,_
                               macroTable: VTB, potentialReductions: L RAST,_
                               accVars: L L Syntax): Pair(TENV, List YREC) ==
      printCurrentFunction(rec)
      -- clean up the type environment
      cleanUp()
      accumulationCandidatesWithSignatures := []
      r := copy rec
      sig := r.signature
      tar := target sig
      setupGlobalVariables1(r, ctorName,ctorPars,exported,unexported,importLst,_
                            macroTable, potentialReductions, accVars)
     -- does typechecking for the function definition
      rtp := checkStatement(body(r.body), tar)
      unification(rtp, tar) ~= rtp => 
        print(fn::OutputForm)
        print(sig::OutputForm)
        userError "resultant type does not refine the target type in the signature"
      --print(typeEnv::OutputForm)
      pair(copy typeEnv, copy accumulationCandidatesWithSignatures)

    -- types check reduce calls and reduce forms
    -- via typechecking the whole function definition they stay in
    verifyReduceCallAndFormWithType(rec: DREC,ctorName: Identifier,_
       ctorPars: List Syntax, exported: L FREC, unexported: L FREC,_
       importLst: L ImportAst, macroTable: VTB,_
       potentialReductionForms: L Syntax): Pair(List REDU, List REDF) ==
      printCurrentFunction(rec)
      -- clean up the type environment
      cleanUp()
      reduceCandidatesWithSignatures := []
      reduceFormCandidatesWithSignatures := []
      -- local setting up
      r := copy rec
      sig := r.signature
      tar := target sig
      setupGlobalVariables2(r,ctorName,ctorPars,exported,unexported,_
                            importLst, macroTable, potentialReductionForms)
      -- does typechecking for the function definition
      rtp := checkStatement(body(r.body), tar)
      unification(rtp, tar) ~= rtp => 
        print(fn::OutputForm)
        print(sig::OutputForm)
        print(tar::OutputForm)
        print(rtp::OutputForm)
        userError "resultant type does not refine the target type in the signature"
      pair(copy reduceCandidatesWithSignatures,_
           copy reduceFormCandidatesWithSignatures)

    -- resolves the signature of an annotated operator       
    resolveAnnotatedFunction(tpAnot: Syntax, tps: List Syntax,_ 
                             rtn: Syntax, fn: Identifier,_
                             typeEnvironment: TENV): Pair(Boolean, Signature) == 
      typeEnv := copy typeEnvironment
      resolveFunctionWithAnnotation(tpAnot, tps, rtn, fn)






-- Problem: 
-- 2. IfAst should check both branches first, then do a unification on both branches, 
--    the unification results the type of the if statement
-- 3. Need to pass the expected type around, if the expected is unknown, then introduce a 
--    meta variable, say gensym(). We maintain a table from these symbol to their type value.
-- 4. for unitifcation, I think TOP === random fresh variable. BOTTOM === Void()
-- interesting syntax to be handled:
--   FLAS: FiniteLinearAggregate(S) with finiteAggregate
--- v.i :=  should be interpreted together as setelt function.
--- v.i on the right hand side such as Table, Matrix, Vector, List, should be intepreted as elt function.
-- record's operator should be generated by us manually.



-- Assumptions:
-- 0. For checking the access form, we don't handle record.
-- 1. All the function definitions should annotate their signatures in 
-- their heads of the definitions, or give their signatures in the capsule.
-- 2. Rightnow, assume there is no imported packages
-- 3. Rightnow, assume there is no $ annotated function
-- Based on 2, 3, we only look at the local constructor, and the parameters' constructor to 
-- do function resolution, using the types of parameters, we infer the result type.
-- 4. there is not collection such as [], such that |
-- 5. for access form, we only handle List, no record, no table
-- 6. only Integer, NonNegativeInteger, PositiveInteger have subtyping/subdomain checking.



-- Constants: Integer, Boolean
--


-- checkLet has two cases
-- 1. the one with ColonAst on the left hand side
-- 2. the one without ...
 
-- x: Integer := y + z
-- x: SetCategory := Integer
-- x := y + z
-- 

-- Notes:
-- Some useful domains: Constructor, FunctionDescriptor, CategoryConstructor, Domain, Category
-- OverloadSet
--1. Function resolution strategy
--1.a If the function call has been annotated by "$", then directly go to that constructor
-- and find the function, if can not find, report type error.
--1.b Else, search the current constructor to find the correct function
--        if can not find in the current constructor, 
--          then try to find the function in the imported packages
--          if still can not find the function, then
--            go to the constructor of the each parameter
--            if the function was found in one of the constructor, return the signature, and 
--               the function call is type checked.
--            else the correct function can not be found, 
--              then pick the function which looks most similar and report type error


