import SYNHELP
import TYPCHK
import LPANL
import REDANL
import CHKASSMP
import CEXCOL

)abbrev package REDUPKG ReductionAnalysisPackage
++ Author: Yue Li
++ Date Created: November 23, 2009
++ Date Last Updated: March 29, 2010
++ Description: This package provides library functions for extracting
++ parallelizable accumulation loops, reduce function calls, as well as 
++ reduce forms
ReductionAnalysisPackage(): Public == Private where
  macro VTB    == Table(Syntax, Syntax)
  macro XREC   == Record(funname: Identifier, signature: Signature, usedin: Syntax, tenv: VTB)
  macro YREC   == Record(loopcandidate: RepeatAst, signaturelist: List XREC)
  macro REDU   == Record(reduceexp: Syntax, reduceop: Syntax, signature: Signature, tenv: VTB)
  macro LTB    == Table(Pair(Identifier, Identifier), List RepeatAst)
  macro FREC   == Record(funname: Identifier, signature: Signature, arity: Integer)
  macro DREC   == Record(funname: Identifier, signature: Signature,_ 
                         body: DefinitionAst, typeenv: VTB, accumulations: List YREC)
  macro ZREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, accumulations: List YREC)
  macro RREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reductions: List REDU)
  macro RFREC  == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reduceforms: List Syntax)
  macro AREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, affineloops: List RepeatAst)
  -- format for storing reduce forms
  macro REDF   == Record(reduceform: Syntax, reduceop: Identifier, signature: Signature, tenv: VTB)
  macro RFORM  == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reduceforms: List REDF)
  -- format for storing associative operator records
  macro OPREC  == Record(funname: Identifier, origin: Syntax, signature: Signature, tenv: VTB)
  -- format for  category extension database to use
  macro TCR    == Record(funname: Identifier, signature: Signature, tenv: VTB)
  macro EXTP   == Pair(Syntax, List Syntax) -- (category/attribute, predicate)
  macro LEXTP  == List EXTP
  macro LAP    == LEXTP                -- for attributes, i.e. conditional and unconditional
  macro LSP    == LEXTP                -- for signatures, i.e. conditional and unconditional
  macro CEXTR  == Record(catname: Identifier, catpars: List Identifier,_ 
                        partyps: List Syntax, declarations: LSP, extensions: LEXTP, attributes: LAP)

  macro CEXTDB == List CEXTR
  Public == with
    analyze: (Integer, Integer) -> Void
      ++ This function analyzes all spad library files stored in some directory
      ++ according to its parameters that are passed in:
      ++ analyze(0, 0): extract accumulation loops
      ++ analyze(1, 0): extract reduce functions and reduce forms
      ++ analyze(2, 0): extract affine control loop (ACL) nests 
      ++ analyze(3, 0): extract all the normal loop nests
      ++ analyze(0, 1): extract parallel accumulation loops
      ++ analyze(1, 1): extract parallel reduce functions and reduce forms
      ++ note that the default directory points to my demonstrating example folder:
      ++ /users/yli/software/OA-latest/oa/bin/PARALLEL/example
  Private == add
    -- local forward function declarations:
    collectFromDefinition: (DefinitionAst, Identifier, VTB) -> Integer
      ++ this function collects parallel reduction (loop+reduce+reduce form) from 
      ++ a function definition
    collectFromTopLevel: (SpadAst, Identifier, VTB) -> Integer
      ++ this function collects parallel reduction from each statement of the capsule
    rightDomainHasLeftSignature?: (Syntax, Syntax, Syntax, VTB) -> Boolean
      ++ this function checks whether the some domain has some function
    rightDomainVariableHasLeftSignature?: (Syntax, Syntax, Syntax, VTB) -> Boolean
      ++ this function checks whether the domain represented by a domain variable has some function


    --Global variables
    reductionCounter : Integer := 0
    -- counter for files that have been analyzed
    fileCounter: Integer := 0
    count: Integer := 0
    -- counter for function definitions
    functionDefinitionCounter: Integer := 0
    bugcounter : Integer := 0
    -- ACL nests counter
    aclandnlcounter: Integer := 0
    aclLoopDepths: List Integer := []

    -- reduction loop counter
    totalcounter : Integer := 0

    -- parallel accumulation counter
    parallelAccumulationCounter : Integer := 0

    -- partially parallel accumulation counter
    partialParallelAccumulationCounter : Integer := 0

    reductionFormCounter: Integer := 0

    preductionFormCounter: Integer := 0

    reductionFunctionCounter: Integer := 0

    preductionFunctionCounter: Integer := 0

    -- used for preprocessing
    -- 0: extract reduction loops with functions used in the loop
    -- 1: extract reduce function and reduce forms. 
    -- 2: extract acl loop nests (e.g. analyze(2, 0))
    programOption : Integer := 0
    -- for affine loop nests
    aclList: List AREC                                 := []
    -- for nested loops
    nlList: List AREC                                  := []
    -- for reduction loops
    analysisResultList: List ZREC                      := []
    -- for reduce function calls
    reduceList: List RREC                              := []
    -- no longer used 
    reduceFormList: List RFREC                         := []
    -- the improved list for reduce forms
    rformList : List RFORM                             := []
    importList : List ImportAst                        := []
    fundefList : List DREC                             := []
    categorySet: Set Identifier                        := {}
    packageSet:  Set Identifier                        := {}
    domainSet:   Set Identifier                        := {}

    -- global variable storing name of a constructor
    constructorName: Identifier                        := gensym()

    -- global variable storing parameters taken by a constructor
    constructorParameters: List Syntax                 := []

    -- global variable storing the type of each constructor parameter
    constructorParameterTypes: List Syntax             := []

    -- global variable storing macros defined in some constructor
    constructorMacros: VTB                             := empty()

    localUnexportedSignatureDatabase : List FREC       := []
    -- exported signatures with slot instantiated but without instantiating %
    localExportedSignatureDatabase : List FREC         := [] 
    -- Table for storing global variables such as constructor parameter, and global variable in capsule
    -- this will become global type environment, storing global function declaration, global 

    -- global type environment
    globalTypeEnvironment: VTB := empty()

    -- the following functions are used for debugging the framework
    viewImports(): List ImportAst == importList

    -- lists all the function definitions in a domain/category/package definition
    viewFunctionDefinitions(): List DREC == fundefList

    -- lists all the macros declared in some constructor definition
    viewMacros():VTB  == constructorMacros

    -- prints the constructor name, parameters, and input types of a type constructor    
    viewConstructorHeadInformation():Void() ==
      print(constructorName::OutputForm)
      print(constructorParameters::OutputForm)
      print(constructorParameterTypes::OutputForm)

    -- returns all the function declarations exported by some type constructor
    viewExportedFunctionSignatures(): List FREC == localExportedSignatureDatabase

    -- returns all the function which is locally declared in some type constructor definition
    viewUnexportedFunctionSignatures(): List FREC == localUnexportedSignatureDatabase

    -- returns the table storing global variables of a constructor
    viewGlobalVariables(): VTB == globalTypeEnvironment

    -- returns all the reduce functions extracted
    viewReduceFunctions(): List RREC == reduceList
  
    -- returns all the reduce forms extracted
    viewReduceForms(): List RFREC == reduceFormList

    -- returns all the affine control loops extracted
    viewAffineControlLoops(): List AREC == aclList

    -- print all kinds of statistics on the results 
    -- given by the reduction detector
    viewStatistics(): Void() ==
      if programOption = 0 then 
        print("Reduction loop #:"::OutputForm)
        print(totalcounter::OutputForm)
      if programOption = 1 then
        print("Reduction function call #:"::OutputForm)
        print(reductionFunctionCounter::OutputForm)        
        print("Reduction form #:"::OutputForm)
        print(reductionFormCounter::OutputForm)      
      print("Total function definition #:"::OutputForm)
      print(functionDefinitionCounter::OutputForm)
      print("Total file #:"::OutputForm)
      print(fileCounter::OutputForm)
      print("Package #:"::OutputForm)
      print((#packageSet)::OutputForm)
      print("Category #:"::OutputForm)
      print((#categorySet)::OutputForm)
      print("Domain #:"::OutputForm)
      print((#domainSet)::OutputForm)

    makePercentage: Syntax          == '%::Identifier::Syntax
    makeCase: Syntax                == 'case::Identifier::Syntax
    makeTrue: Syntax                == 'true::Identifier::Syntax
    makeNil: Syntax                 == 'nil::Identifier::Syntax
    makeJoin: Syntax                == 'Join::Identifier::Syntax

    cleanUpConstructorInformation: Boolean ==
      globalTypeEnvironment := empty()
      constructorName: Identifier := gensym()
      constructorParameters := []
      constructorParameterTypes := []
      constructorMacros := empty()
      importList := []
      fundefList := []
      ctorExportedSignatures := []
      localExportedSignatureDatabase := []  
      localUnexportedSignatureDatabase := []
      true

    cleanUp():Boolean ==
      fileCounter := 0
      count := 0
      functionDefinitionCounter := 0
      analysisResultList := []
      aclList            := []
      nlList             := []
      reduceList         := []
      reduceFormList     := []
      rformList          := []
      categorySet        := {}
      packageSet         := {}
      domainSet          := {}
      cleanUpConstructorInformation()
      true

    -- collect macros into table
    collectMacroFromDefinitionAst(functionName: Identifier, definitionBody: SpadAst): Boolean ==
      macroName := functionName::Syntax
      macroBody := definitionBody::Syntax
      constructorMacros.macroName := macroBody
      true      

    collectMacro(t: MacroAst): Boolean ==
      macroHead := head(t)$MacroAst
      macroBody := (body(t)$MacroAst)::Syntax
      macroName := (name(macroHead)$HeadAst)::Syntax
      constructorMacros.macroName := macroBody
      true

    -- does maco expansion
    -- currently only for ColonAst, DefinitionAst before they are collected, and for global type environment before
    -- passing it to typechecker.
    macroExpansionForSyntax(s: SpadAst): SpadAst ==
      s' := s::Syntax
      for m in keys constructorMacros repeat
        mac := constructorMacros.m
        sub := m
        --if compound? mac then
        --  sub := buildSyntax(m, [])
        s' := replace(sub, s', mac)$SyntaxHelper
      s'::SpadAst

    macroExpansionForTypeEnvironmentTable(gte: VTB): VTB ==
      gte' := copy gte
      for k in keys gte' repeat
        gte'.k := macroExpansionForSyntax((gte'.k)::SpadAst)::Syntax
      gte'

    macroExpansionForImportList(): List ImportAst ==
      importList' := copy importList
      for i in 1..#importList' repeat
        importList'.i := macroExpansionForSyntax((importList'.i)::Syntax::SpadAst)::Syntax::ImportAst
      importList'

    macroExpansion(defAst: SpadAst): SpadAst ==
      defAst' := defAst
      op       := getOperator(defAst'::Syntax)::Identifier
      operands := getOperands(defAst'::Syntax)
      bodySyntax := operands.last
      -- from the last macro to the first macro
      -- function keys returns this correct order
      --bodySyntax := macroExpansionForSyntax(bodySyntax::SpadAst)::Syntax

      for m in keys constructorMacros repeat
        bodySyntax := replace(m, bodySyntax, constructorMacros.m)$SyntaxHelper

      operands.last := bodySyntax
      -- if this is definitionAst, we also need to expand its signature
      if defAst case DefinitionAst then
        --operands.2 := macroExpansionForSyntax((operands.2)::SpadAst)::Syntax
        for m in keys constructorMacros repeat
          operands.2 := replace(m, operands.2, constructorMacros.m)$SyntaxHelper
      -- if this is a LetAst and the left hand side is a ColonAst
      if defAst case LetAst and  compound?(lhs(defAst::Syntax::LetAst)::Syntax) and_
         (l := lhs(defAst::Syntax::LetAst)) case ColonAst then
        operands.1 := macroExpansion(l)::Syntax
      buildSyntax(op, operands)::SpadAst

    -- collects import statements at the head of some Spad file
    importFilter(l: List Syntax): Syntax ==
      for s in l repeat
        (s' := s::SpadAst) case ImportAst => importList := concat(importList, s::ImportAst)
        s' case MacroAst => collectMacro(s::MacroAst)
        s' case DefinitionAst or s' case WhereAst => return s
      l.last

    initGlobalVariableEnvironment(ctorName: Identifier, ctorPars: List Identifier, ctorTps: List Syntax): VTB ==
      for p in ctorPars for t in ctorTps repeat
        p' := p::Syntax
        globalTypeEnvironment.p'  := t
      globalTypeEnvironment

    constructorCallForm():Syntax == 
      buildSyntax(constructorName::Syntax, constructorParameters)

    instantiatePercentageWithCurrentConstructorName(signatureast: SpadAst): Syntax ==
      signatureast' := signatureast::Syntax
      replace(makePercentage(), signatureast', constructorCallForm())$SyntaxHelper

    -- update the global type environment
    updateGlobalTypeEnvironment(gte: VTB, id: Syntax, tp: Syntax): VTB ==
      qsetelt!(gte, id, tp)
      gte

    updateGlobalTypeEnvFromCondition(cond: SpadAst, gte: VTB): VTB ==
      compound?(cond::Syntax) and cond case HasAst =>
        cond := macroExpansionForSyntax(cond)
        cond' := cond::Syntax::HasAst
        v   := (lhs cond')::Syntax
        cat := (rhs cond')::Syntax
        key?(v, gte) => 
          if isJoin?(tp := gte.v)$SyntaxHelper then 
            gte.v := buildSyntax(makeJoin(), concat(getOperands tp, cat))
          else
            gte.v := buildSyntax(makeJoin(), [tp, cat])
          gte
        gte.v := cat
        gte
      gte

    mappingAst2Signature(m: MappingAst): Signature ==
      src : List Syntax := []
      tar := (target m)::Syntax
      for s in source m repeat
        src := concat(src, s::Syntax)
      signature(src, tar)

    updateUnexportedSignatureDatabase(fn: Identifier, sig: Signature, a: Integer): Boolean ==
      r: FREC := [fn, sig, a]
      localUnexportedSignatureDatabase := concat(localUnexportedSignatureDatabase, r)
      true

    getFunctionSignatureFromColonAst(sa: SpadAst, gte: VTB): Boolean ==
      sa'   := sa::Syntax::ColonAst
      right := rhs(sa')::Syntax::SpadAst
      left  := lhs(sa')::Syntax::SpadAst
      if compound?(right::Syntax) and_ 
         right case MappingAst and_
         (left' := left::Syntax) case Identifier  then
      -- if this is a function signature
        right' := right::Syntax::MappingAst
        updateUnexportedSignatureDatabase(left'::Identifier, mappingAst2Signature(right'),  #(source(right')$MappingAst))
        gte := updateGlobalTypeEnvironment(gte, left::Syntax, right::Syntax) 
      true

    signatureComplete?(sig: Signature): Boolean ==
      for t in concat(source sig, target sig) repeat
        nil? t => return false
      true

    -- update local unexported signature database
    -- skip those function definition which does not have a signature 
    -- their signatures have already been shown in exported ones, or in the local declaration extracted already.

    isRep?(fn: Identifier): Boolean == fn = 'Rep::Identifier

    updateUnexportedDatabaseWhenMeetRep(bd: SpadAst): Boolean ==
      recordForRep : FREC := ['rep::Identifier, signature([makePercentage()], bd::Syntax), 1]
      recordForPer : FREC := ['per::Identifier, signature([bd::Syntax], makePercentage()), 1]
      localUnexportedSignatureDatabase := concat(localUnexportedSignatureDatabase, [recordForRep, recordForPer])
      true

    updateUnexportedDatabaseWhenMeetFunDef(fn: Identifier, sig: Signature, a: Integer, bd: SpadAst): Boolean ==
      isRep?(fn)                  => updateUnexportedDatabaseWhenMeetRep(bd)
      not signatureComplete?(sig) => false
      r : FREC := [fn, sig, a]
      -- already in exported or unexported signature database?
      member?(r, localExportedSignatureDatabase) or member?(r, localExportedSignatureDatabase) => false
      -- otherwise, update the unexpoconstructorNamerted signature database with this entry
      localUnexportedSignatureDatabase := concat(localUnexportedSignatureDatabase, r)
      true

    signatureMatch?(actual: Signature, expect: Signature): Boolean ==
      actualSignatureList := concat(source actual, target actual)
      expectSignatureList := concat(source expect, target expect)
      for x in actualSignatureList for y in expectSignatureList repeat
        not nil? x and not x = y => return false
      true

    searchInSignatureDatabase(fn: Identifier, sig: Signature, db: List FREC): Pair(Boolean, Signature) ==
      for entry in db repeat
        if entry.funname = fn and_ 
           entry.arity = #source(sig) and_ 
           signatureMatch?(sig, entry.signature) then 
          return pair(true, entry.signature)
      pair(false, sig)

    updateParameterTypeFromTypeEnvironment(pars: List Syntax, sig: Signature, gte: VTB): Signature ==
      src := source sig
      tar := target sig
      for i in 1..#src for p in pars repeat
        if not (p case String) and key?(p, gte) then
          src.i := gte.p
      signature(src, tar)

    getCompleteSignature(fn: Identifier, pars: List Syntax, sig: Signature, gte: VTB): Signature ==
      -- search in global type environment first
      if not (fn = makeCase()::Identifier) then 
        sig := updateParameterTypeFromTypeEnvironment(pars, sig, gte)
        signatureComplete?(sig) => return sig
      -- after searching the global type environment, if the type is still incomplete
      -- then search the two databases
      first(x := searchInSignatureDatabase(fn, sig, localExportedSignatureDatabase))   => second x
      first(y := searchInSignatureDatabase(fn, sig, localUnexportedSignatureDatabase)) => second y
      print(fn::OutputForm)
      print(sig::OutputForm)
      print(constructorMacros::OutputForm)
      userError "unexpected: the signature can not be found in any of the two databases."

    -- should add exclamation.
    instantiatePercentageInSource(src: List Syntax): List Syntax ==
      for i in 1..#src repeat
        src.i := replace(makePercentage(), src.i, constructorCallForm())$SyntaxHelper
      src

    instantiatePercentageForListSyntax(s: List Syntax): List Syntax ==
      instantiatePercentageInSource(s)

    instantiatePercentageInTarget(tar: Syntax): Syntax ==
      replace(makePercentage(), tar, constructorCallForm())$SyntaxHelper

    instantiatePercentageForSignature(s: Signature): Signature ==
      src := instantiatePercentageInSource copy source s
      tar := instantiatePercentageInTarget target s
      signature(src, tar)

    instantiatePercentageForLoops(l: List RepeatAst): List RepeatAst ==
      result := copy l
      for i in 1..#result repeat
        result.i := (replace(makePercentage(), (result.i)::Syntax, constructorCallForm())$SyntaxHelper)::RepeatAst
      result

    filterOutMappingAst(gte: VTB): VTB == 
      gte' := copy gte
      for k in keys gte' repeat
        if compound?(gte'.k) and (gte'.k)::SpadAst case MappingAst then
          remove!(k, gte')
      gte'  

    collectReduceForms(r: List Syntax): Pair(List Syntax, List Syntax) ==
      reduceFun : List Syntax := []
      reduceForm: List Syntax := []
      for e in r repeat
        if getOperator(e) case Identifier then
          getOperator(e)::Identifier = 'REDUCE::Identifier => reduceForm := concat(reduceForm, e)
          getOperator(e)::Identifier = 'reduce::Identifier => reduceFun := concat(reduceFun, e)
      pair(reduceFun, reduceForm)

    -- collect all the function definitions in the capsule, attaching with its complete signature,
    -- its complete AST, and an initialized type environment
    -- Note that % in its signature is not replaced with the constructor call form
    updateFunDefList(fn: Identifier, sig: Signature, defAst: DefinitionAst, bd: SpadAst, gte: VTB): Boolean ==
      -- we don't do typechecking for rep and per. or Rep ==
      -- because we generate its type, not user, therefore it is always correct.
      isRep?(fn) => true
      -- make a copy of the defintion ast
      defAst' := defAst
      gte' := macroExpansionForTypeEnvironmentTable(gte)
      gte' := filterOutMappingAst(gte')
      importList' := macroExpansionForImportList()
      if programOption = 0 then
        -- analyze the loop, extracting reductions 
        resultFromLoopAnalysis: Pair(LTB, List List Syntax) := extractReductionPatternFromFunctionDefinition(defAst', constructorName, copy gte')$LoopAnalysis 
        loopTable: LTB := first resultFromLoopAnalysis
        accVariables: List List Syntax := second resultFromLoopAnalysis
        -- if there is no interesting loop, we do nothing.
        empty? loopTable => return true
        #keys(loopTable) > 1 => 
          print(loopTable::OutputForm)
          userError "unexpected results from analysis framework [has more than 1 entry in the table]"
        print(" ")
        print("-------------------------------------------------------------")
        print("|  Encounter potential reduction, start doing typechecking  |")
        print("-------------------------------------------------------------")
        print(" ")     
        k := first keys loopTable
        loopList : List RepeatAst := loopTable.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then 
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentageWithCurrentConstructorName(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        loopList' : List RepeatAst := instantiatePercentageForLoops(loopList)
        -- build the record
        r : DREC := [fn, sig', defAst', copy gte', []]
        -- typechecks the function definition body
        resultFromTypeChecker : Pair(VTB, List YREC) := checkFunctionDefinition(r,_ 
                                             constructorName, constructorParameters,_
                                             localExportedSignatureDatabase, localUnexportedSignatureDatabase,_
                                             importList', constructorMacros,_
                                             loopList', accVariables)$TypeChecker
        r.typeenv := first resultFromTypeChecker
        r.accumulations := second resultFromTypeChecker
        fundefList := concat(fundefList, r)
        -- update the final result to be written into file
        r' : ZREC := [constructorName, r.funname, r.signature, r.accumulations]
        analysisResultList := concat(analysisResultList, r')
------------------------------------------------------------------------------------------------------

      if programOption = 2 then
        resultFromACFAnalysis : LTB := extractAffineControlLoopFromFunctionDefinition(defAst', constructorName, copy gte')$LoopAnalysis
        empty? resultFromACFAnalysis => return true
        #keys(resultFromACFAnalysis) > 1 =>
          print(resultFromACFAnalysis::OutputForm)
          userError "unexpected results from analysis framework [has more than 1 entry in the table]"
        print(" ")
        print("-------------------------------------------------------------")
        print("|  Encounter affine control loop nest                       |")
        print("-------------------------------------------------------------")
        print(" ")
        k := first keys resultFromACFAnalysis
        loopList : List RepeatAst := resultFromACFAnalysis.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentageWithCurrentConstructorName(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        loopList' : List RepeatAst := instantiatePercentageForLoops(loopList)
        r' : AREC := [constructorName, fn, sig', loopList']
        aclList := concat(aclList, r')

------------------------------------------------------------------------------------------------------

      if programOption = 3 then
        resultFromLoopNestsAnalysis : LTB := extractAllLoopNests(defAst', constructorName, copy gte')$LoopAnalysis
        empty? resultFromLoopNestsAnalysis => return true
        #keys(resultFromLoopNestsAnalysis) > 1 =>
          print(resultFromLoopNestsAnalysis::OutputForm)
          userError "unexpected results from analysis framework [has more than 1 entry in the table]"
        print(" ")
        print("-------------------------------------------------------------")
        print("|  Encounter loop nest                                      |")
        print("-------------------------------------------------------------")
        print(" ")
        k := first keys resultFromLoopNestsAnalysis
        loopList : List RepeatAst := resultFromLoopNestsAnalysis.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentageWithCurrentConstructorName(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        loopList' : List RepeatAst := instantiatePercentageForLoops(loopList)
        r' : AREC := [constructorName, fn, sig', loopList']
        nlList := concat(nlList, r')

-------------------------------------------------------------------------------------------------------

      if programOption = 1 then
        -- analyze the loop, extracting reductions 
        reduceForms : List Syntax := extractReduceFormsFromFunctionDefinition(defAst', constructorName)$ReduceAnalysis 
        -- if there is no interesting loop, we do nothing.

        reductionCounter := reductionCounter + #(reduceForms)
        --k := first keys loopTable
        --loopList : List RepeatAst := loopTable.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then 
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentageWithCurrentConstructorName(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        reduceForms' : List Syntax := instantiatePercentageForListSyntax(reduceForms)

        -- we don't divide them right now
        --x := collectReduceForms(reduceForms')
        --reduceFormList := second x
        --reduceForms'   := first x

        --if not empty? reduceFormList then
        --  rec : RFREC := [constructorName, fn, sig', reduceFormList] 
        --  L_reduce_form := concat(L_reduce_form, rec)

        empty? reduceForms' => return true

        print(" ")
        print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
        print("$  Encounter potential reduce forms and expressions, start typechecking  $")
        print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
        print(" ")     

        r : DREC := [fn, sig', defAst', copy gte', []]

        -- typechecks the function definition body
        resultFromTypeChecker : Pair(List REDU, List REDF) := checkFunctionDefinition2(r,_ 
                                             constructorName, constructorParameters,_
                                             localExportedSignatureDatabase, localUnexportedSignatureDatabase,_
                                             importList', constructorMacros,_
                                             reduceForms')$TypeChecker

        reduceFunctionRecord : RREC := [constructorName, fn, sig', first resultFromTypeChecker]
        reduceFormRecord : RFORM := [constructorName, fn, sig', second resultFromTypeChecker]
        reduceList := concat(reduceList, reduceFunctionRecord)
        rformList := concat(rformList, reduceFormRecord)
      true

    updateGlobalTypeEnvironmentFromColonAst(cast: SpadAst, gte: VTB): VTB ==
      getFunctionSignatureFromColonAst(cast, gte)
      varLst := listColonAst(cast::Syntax::ColonAst)$SyntaxHelper
      varTyp := (rhs(cast::Syntax::ColonAst))::Syntax
      for v in varLst repeat
        gte := updateGlobalTypeEnvironment(gte, v, varTyp)
      gte

    isTypeExpression?(s: SpadAst): Boolean ==
      s' := s::Syntax
      not compound? s' => false
      (ctor := getOperator(s')) case Identifier => 
         retractIfCan(findConstructor(ctor::Identifier)$Constructor)$(Maybe Constructor) case "failed" => false
         true
      false
          
    -- collect the loop ast from a statement
    collectFromStatement(dBody: SpadAst, ctor: Identifier, gte: VTB): Integer ==
      if not compound?(dBody::Syntax) then
        return count
      dBody case ImportAst =>
        importList := concat(importList, dBody::Syntax::ImportAst)        
        count
      dBody case SignatureAst => count
      dBody case MacroAst => 
        collectMacro(dBody::Syntax::MacroAst)
        count
      dBody case DefinitionAst => 
        collectFromDefinition(dBody::Syntax::DefinitionAst, ctor, copy gte)
        count
      dBody case SequenceAst =>
        stmtLst:= body(dBody::Syntax::SequenceAst)$SequenceAst
        for stmt in stmtLst repeat
          collectFromStatement(stmt, ctor, gte)
        count
      dBody case IfAst => 
        dBody'   := dBody::Syntax::IfAst
        thBranch := thenBranch(dBody')$IfAst
        elBranch := elseBranch(dBody')$IfAst
        cond     := condition(dBody')$IfAst
        if compound?(thBranch::Syntax) then
          gte' := copy gte
          gte' := updateGlobalTypeEnvFromCondition(cond, gte')          
          collectFromStatement(thBranch, ctor, gte')
        if compound?(elBranch::Syntax) then
          collectFromStatement(elBranch, ctor, copy gte)
        count
      dBody case ReturnAst =>
        rtn := expression(dBody::Syntax::ReturnAst)$ReturnAst
        if compound?(rtn::Syntax) then
          collectFromStatement(rtn, ctor, gte)
        count
      dBody case RepeatAst =>
        b := dBody::Syntax::RepeatAst
        count := count + 1
        count
      dBody case CoerceAst =>
        coeast := dBody::Syntax::CoerceAst
        tp := ((target(coeast))$CoerceAst)::Syntax
        exp := (expression(coeast)$CoerceAst)::Syntax
        coerExp := expression(dBody::Syntax::CoerceAst)$CoerceAst
        if compound?(coerExp::Syntax) then
          collectFromStatement(coerExp, ctor, gte)
        count
      dBody case ExitAst =>
        dbexp := expression(dBody::Syntax::ExitAst)$ExitAst
        collectFromStatement(dbexp, ctor, gte)
      dBody case LetAst =>
        dBody' := (macroExpansion dBody)::Syntax::LetAst        
        id := getLhs(dBody')$SyntaxHelper
        if not compound?((l := lhs(dBody'))::Syntax) and_
           l case Identifier and_
           (isRep?(l::Identifier) or isTypeExpression? rhs dBody') then
          collectMacroFromDefinitionAst(l::Identifier, rhs(dBody'))  
          updateUnexportedDatabaseWhenMeetRep(rhs(dBody'))
        else if compound?((l := lhs(dBody'))::Syntax) and l case ColonAst then
          tp := rhs(l::Syntax::ColonAst)::Syntax
          gte := updateGlobalTypeEnvironment(gte, id, tp)
        else
          gte' := macroExpansionForTypeEnvironmentTable(gte)
          gte' := filterOutMappingAst(gte') 
          importList' := macroExpansionForImportList()
          tp   := checkGlobalLetAst(dBody',_ 
                                    gte', constructorName, constructorParameters,_
                                    localExportedSignatureDatabase, localUnexportedSignatureDatabase,_
                                    importList')$TypeChecker
          gte  := updateGlobalTypeEnvironment(gte, id, tp)  
        count
      dBody case WhileAst => count  
      dBody case ColonAst => 
        gte := updateGlobalTypeEnvironmentFromColonAst(macroExpansion(dBody), gte)
        count
      dBody case ConstructAst => count
      dBody case CollectAst => count
      dBody case CaseAst => count
      count

    -- collects loop from one function definition
    collectFromDefinition(defAst: DefinitionAst, ctor: Identifier, gte: VTB): Integer ==
      functionDefinitionCounter := inc(functionDefinitionCounter)
      defAst' := (macroExpansion(defAst::Syntax::SpadAst))::DefinitionAst
      hd := head(defAst')$DefinitionAst
      functionName := name hd
      ary := #(parameters(hd)$HeadAst)
      sig := signature(defAst')$DefinitionAst
      dBody := body(defAst')$DefinitionAst
      if not isRep?(functionName) and ary = 0 and isTypeExpression?(dBody) then
        -- treat this function abstraction as macro
        -- or can I say this is inlining?
        --print(defAst'::Syntax::OutputForm)
        collectMacroFromDefinitionAst(functionName, dBody)
      else
        ---------------------- add two passes here ----
        updateUnexportedDatabaseWhenMeetFunDef(functionName, sig, ary, dBody)
        updateFunDefList(functionName, sig, defAst', dBody, gte)
        --------------------------
      -- terminate at each function definition level
      count
    
    -- check whether a let assignment is a type assignment
    -- e.g. foo := Integer or Rep := foo
    isTypeAssignment?(s: LetAst): Boolean ==
      not compound?((l := lhs s)::Syntax) and_
      l case Identifier and_
      (isRep?(l::Identifier) or isTypeExpression? rhs s)

    -- update macro database with type assignment, i.e. we take type assignment as macro
    -- when we meet type assignment for Rep, we automatically generate two function per and rep
    -- updating these two functions into unexported function signature database of the constructor
    updateDatabaseFromTypeAssignment(s: LetAst): Void ==
      left := lhs s
      right := rhs s
      collectMacroFromDefinitionAst(left::Identifier, right)
      updateUnexportedDatabaseWhenMeetRep right


    -- check whether a let assignment is a immediate initialization
    -- e.g., foo : Integer := 5
    isImmediateInitialization?(s: LetAst): Boolean ==
      compound?((l := lhs(s))::Syntax) and l case ColonAst

    -- using a type checker for let statement which does not have type annotation for its lefthand side
    updateGlobalTypeEnvironmentUsingTypeChecker(s: LetAst, id: Syntax, typeEnvironment: VTB): Void ==
      -- expand the macros in typing environment and import list
      typeEnvironment' := macroExpansionForTypeEnvironmentTable typeEnvironment
      typeEnvironment' := filterOutMappingAst typeEnvironment' -- in case we may collect some global function signature
      importList'      := macroExpansionForImportList()
      -- start typechecking by passing the macro expanded syntax, typing environment and import list to the typechecker
      tp   := checkGlobalLetAst(s, typeEnvironment', constructorName, constructorParameters,_ 
                                localExportedSignatureDatabase, localUnexportedSignatureDatabase, importList')$TypeChecker
      -- update global typing environment
      typeEnvironment := updateGlobalTypeEnvironment(typeEnvironment, id, tp)

    -- update global typing environment when we meet a global let assignment
    collectTypesFromGlobalLetAst(s: LetAst, typeEnvironment: VTB): Void ==
      id := getLhs(s)$SyntaxHelper
      if isTypeAssignment?(s) then
        updateDatabaseFromTypeAssignment(s)
      else if isImmediateInitialization?(s) then
        typeEnvironment := updateGlobalTypeEnvironment(typeEnvironment, id, rhs((lhs s)::Syntax::ColonAst)::Syntax)
      -- if the let statement is an assignment to some global variable with an expression
      -- without type annotation, we ask our typechecker for help, i.e., to infer the type.
      else
        updateGlobalTypeEnvironmentUsingTypeChecker(s, id, typeEnvironment)

    -- update global typing environment when meet a if statement for conditional 
    -- function definition, we collect from its has predicate
    collectTypesFromGlobalIfAst(s: IfAst, ctor: Identifier, typeEnvironment: VTB): Void ==
      thBranch := thenBranch(s)$IfAst
      elBranch := elseBranch(s)$IfAst
      cond     := condition(s)$IfAst
      if compound?(thBranch::Syntax) then
        typeEnvironment' := copy typeEnvironment
        typeEnvironment' := updateGlobalTypeEnvFromCondition(cond, typeEnvironment')
        collectFromTopLevel(thBranch, ctor, typeEnvironment')
      if compound?(elBranch::Syntax) then
        collectFromTopLevel(elBranch, ctor, copy typeEnvironment)

    -- collect data from a statement of a capsule
    -- the statement can be a function definition, global variable declaration,
    -- a conditional function definition/declaration via if statement, ora macro
    collectFromTopLevel(sa: SpadAst, ctor: Identifier, typeEnvironment: VTB): Integer ==
      sa case ColonAst => 
        typeEnvironment := updateGlobalTypeEnvironmentFromColonAst(macroExpansion(sa), typeEnvironment)
        count
      sa case SignatureAst => count
      sa case MacroAst => 
        collectMacro(sa::Syntax::MacroAst)
        count
      sa case ImportAst => 
        importList := concat(importList, sa::Syntax::ImportAst)        
        count
      sa case DefinitionAst => 
        collectFromDefinition(sa::Syntax::DefinitionAst, ctor, copy typeEnvironment)
        count
      sa case SequenceAst => collectFromStatement(sa, ctor, typeEnvironment)
      sa case LetAst => 
        -- expand the macro for the let statement
        sa' := (macroExpansion sa)::Syntax::LetAst
        collectTypesFromGlobalLetAst(sa', typeEnvironment)
        count  
      sa case IfAst => 
        collectTypesFromGlobalIfAst(sa::Syntax::IfAst, ctor, typeEnvironment)
        count
      collectFromStatement(sa, ctor, typeEnvironment)

    -- collect data from each statement of the capsule of a constructor definition
    collectFromCapsule(l: List SpadAst, ctor: Identifier): Integer ==
      for s in l repeat collectFromTopLevel(s, ctor, globalTypeEnvironment)
      count

    -- obtain all the statements which form the qualifier of a WhereAst
    -- we collect macro and global variable information at the same time
    getStatementsOfQualifier(bodyOfQualifier: List SpadAst): List SpadAst ==
      result : List SpadAst := []
      for s in bodyOfQualifier repeat
        s case MacroAst => collectMacro(s::Syntax::MacroAst)
        s case ColonAst =>
          globalTypeEnvironment := updateGlobalTypeEnvironmentFromColonAst(macroExpansion(s), globalTypeEnvironment)
        s case ExitAst =>
          e := expression(s::Syntax::ExitAst)$ExitAst
          result := body(e::Syntax::CapsuleAst)$CapsuleAst
      result

    -- looking for the capsule body of the constructor definition 
    -- in each statement of a qulifier
    getBodyOfCapsule(statementOfQualifier: List SpadAst): List SpadAst ==
      result: List SpadAst
      for s in statementOfQualifier repeat
        id := getOperator(s::Syntax)
        if (id case Identifier) then
          id' := id::Identifier
          if (id'::Symbol = 'add) then
            result := body((body(s::Syntax::AddAst)$AddAst)::Syntax::CapsuleAst)$CapsuleAst
        if (s case CapsuleAst) then
          result := body(s::Syntax::CapsuleAst)$CapsuleAst
      result

    -- collects data from a constructor which can be either a category or package
    collectFromConstructorInWhere(s: Syntax, ctor: Identifier): Integer ==
      qual := qualifier(s::WhereAst)$WhereAst
      seq  := (qual::Syntax::SequenceAst)
      bodyOfQualifier := body(seq)$SequenceAst
      statementOfQualifier := getStatementsOfQualifier(bodyOfQualifier)
      bodyOfCapsule := getBodyOfCapsule(statementOfQualifier)
      collectFromCapsule(bodyOfCapsule, ctor)

    -- collects data from a typical category syntax, 
    -- i.e.,  Cats():Category == Cat with ... add..
    collectFromCategory(s: Syntax, ctor: Identifier): Integer == 
      bodyOfDefinition := body(s::DefinitionAst)$DefinitionAst::Syntax
      bodyOfDefinition' := bodyOfDefinition::SpadAst
      id := getOperator(bodyOfDefinition)
      if id case Identifier then
        id' := id::Identifier
        if (id'::Symbol = 'add) then 
          bodyOfAdd:=body(bodyOfDefinition::AddAst)$AddAst::Syntax
          statementOfCapsule : List SpadAst := body(bodyOfAdd::CapsuleAst)$CapsuleAst
          collectFromCapsule(statementOfCapsule, ctor)
        if (bodyOfDefinition' case CapsuleAst) then
          statementOfCapsule : List SpadAst := body(bodyOfDefinition::CapsuleAst)$CapsuleAst
          collectFromCapsule(statementOfCapsule, ctor)
      count

    -- collects data from a typical domain syntax which only has add capsule withou export
    collectFromDomain(s: Syntax, ctor: Identifier): Integer ==
      bodyOfDefinition := body(s::DefinitionAst)$DefinitionAst
      id := getOperator(bodyOfDefinition::Syntax)
      if id case Identifier then
        id' := id::Identifier
        if (id'::Symbol = 'add) then 
          bodyOfAdd := body(bodyOfDefinition::Syntax::AddAst)$AddAst
          if bodyOfAdd case CapsuleAst then
            statementOfCapsule: List SpadAst := body(bodyOfAdd::Syntax::CapsuleAst)$CapsuleAst
            collectFromCapsule(statementOfCapsule, ctor)
        if (bodyOfDefinition case CapsuleAst) then
          statementOfCapsule: List SpadAst := body(bodyOfDefinition::Syntax::CapsuleAst)$CapsuleAst
          collectFromCapsule(statementOfCapsule, ctor)
      count

    -- for building local function database
    makeNumberSlot(i: Integer): Syntax ==
      x := concat("#", convert(i)@String)::Symbol
      (x pretend Identifier)::Syntax

    -- instantiate each number slot with the corresponding constructor type parameter
    instantiateNumberSlots(t: Syntax): Syntax ==
      typeParameters := copy constructorParameters
      #typeParameters > 0 =>
        for i in 1 .. #typeParameters repeat
          t := replace(makeNumberSlot(i), t, typeParameters.i)$SyntaxHelper
        t
      t

    instantiateTypeSyntax(t: Syntax): Syntax ==
      -- a little bit different here: we don't instantiate %
      -- this makes later extract local function signatures easier
      t' := instantiateNumberSlots(t)
      t'

    instantiateTarget(tar: Syntax): Syntax ==
      instantiateTypeSyntax(tar)

    instantiateSource(src: List Syntax): List Syntax ==
      for i in 1..#src repeat
        src.i := instantiateTypeSyntax(src.i)
      src

    instantiateSignature(s: Signature): Signature ==
      src := instantiateSource(copy source s)
      tar := instantiateTarget(target s)
      signature(src, tar)

    -- create an entry of the exported signature database
    createRecord(fn: Identifier, x: List FunctionDescriptor): List FREC ==
      result : List FREC := empty()
      for x' in x repeat
        s := signature x'
        a := #(source s)
        s' := instantiateSignature(s)
        t : FREC := [fn, s', a]
        result := concat(result, t)
      result
  
    -- instantiate number slots which appear in function signature with the real constructor type parameter
    instantiateFunctionDescriptor(opList: List OverloadSet): List FREC ==
      database: List FREC := empty()
      for f in opList repeat
        newRecord := createRecord(name f, members f)
        database := concat(database, newRecord)
      database

    -- obtain all the exported signatures of a constructor
    getExportedSignatures(): List OverloadSet ==
      constructor := retract(findConstructor(constructorName)$Constructor)$(Maybe Constructor)
      copy operations constructor

    -- update the global variables of the current constructor head information
    updateGlobalConstructorInformation(sast: SpadAst, ctorName: Identifier,_ 
                                       ctorPar: List Identifier, ctorTps: List Syntax): Void ==
      constructorName := ctorName
      for p in ctorPar repeat
        constructorParameters   := concat(constructorParameters, p::Syntax)
      constructorParameterTypes := ctorTps
      -- build the exported signature database of the constructor
      localExportedSignatureDatabase := instantiateFunctionDescriptor(getExportedSignatures())
      -- initialize the global type environment of the constructor definition
      initGlobalVariableEnvironment(ctorName, ctorPar, ctorTps)

    -- given an constructor name, find its kind
    getConstructorKind(c: Identifier): ConstructorKind == 
      kind(retract(findConstructor(c)$Constructor)$(Maybe Constructor))$Constructor
  
    -- this function collects names of categories, domains and packages
    -- these information will be used for counting total number of each kind of constructor
    countConstructors(c: Identifier): Void ==
      k : ConstructorKind := getConstructorKind(c)
      k = category$ConstructorKind =>  categorySet := union(categorySet, {c}) 
      k = package$ConstructorKind  =>  packageSet := union(packageSet, {c}) 
      domainSet := union(domainSet, {c})

    -- analyze constructor definition which is defined using where
    -- this constructor could be either a package or a category constructor
    collectFromConstructorDefinitionInWhereAst(s: Syntax): Integer ==
      -- collect constructor head information
      mainexp  := mainExpression(s::WhereAst)$WhereAst::Syntax::DefinitionAst
      ctorName := name(head(mainexp)$DefinitionAst)$HeadAst
      ctorPar  := parameters(head(mainexp)$DefinitionAst)$HeadAst
      ctorSig  := signature(mainexp)$DefinitionAst
      ctorTps  := source(ctorSig)
      countConstructors(ctorName)
      updateGlobalConstructorInformation(s::SpadAst, ctorName, ctorPar, ctorTps)
      collectFromConstructorInWhere(s, ctorName)

    -- analyze a constructor definition which is in DefinitionAst
    -- this constructor can be either a category or a domain constructor
    collectFromConstructorDefinitionInDefinitionAst(s: Syntax): Integer ==
      -- collect constructor head information
      ctorName := name(head(s::DefinitionAst)$DefinitionAst)$HeadAst
      ctorPar  := parameters(head(s::DefinitionAst)$DefinitionAst)$HeadAst
      ctorSig  := signature(s::DefinitionAst)$DefinitionAst
      ctorTps  := source(ctorSig)
      countConstructors(ctorName)
      updateGlobalConstructorInformation(s::SpadAst, ctorName, ctorPar, ctorTps)
      sig := signature(s::DefinitionAst)$DefinitionAst
      tar := target(sig)$Signature
      tar = buildSyntax('Category,[]) => collectFromCategory(s, ctorName)
      collectFromDomain(s, ctorName)

    -- this function extract parallel reduction 
    -- from syntax obtained by parsing one spad library file
    analyzeOneFile(l: List Syntax): Integer == 
      -- initialize global variables for storing the current constructor information
      cleanUpConstructorInformation()
      -- collect all the import information at the head of a Spad file
      -- these information will be used for function resolution
      s := importFilter l
      s' := s::SpadAst
      -- if this is a package or category
      s' case WhereAst => collectFromConstructorDefinitionInWhereAst(s)
      -- if this is a domain or category
      s' case DefinitionAst => collectFromConstructorDefinitionInDefinitionAst(s)
      count

    -- obtain all the Spad file name stored in a directory
    getAllFileName: List FileName ==
      sexp := DIRECTORY("/users/yli/software/OA-latest/oa/bin/PARALLEL/example/*.spad")$Lisp
      sexp pretend List(FileName)

    -- convert an sexpression to string
    sexpressionToString(s: FileName): String == s::String

    -- analyze all the Spad files stored in some directory
    analyzeAllFiles(): Integer ==
      -- initialize all the counters 
      -- as well as records for holding analysis results
      cleanUp()
      fileNameList :List FileName := getAllFileName() 
      for s in fileNameList repeat
        fname := sexpressionToString(s)
        constructorDefinitionSyntax: List Syntax := parse(fname)$SpadParser
        analyzeOneFile constructorDefinitionSyntax
        fileCounter := inc(fileCounter)
      fileCounter

    -- convert a signature to string
    -- for output use
    signatureToString(s: Signature): String ==
      result : String := ""
      src := source s
      tar := target s
      result := concat([result, "("]) 
      for i in 1..#src repeat
        str := toString(src.i)$SyntaxHelper
        if i < #src then
          result := concat([result, str, ", "])
        else
          result := concat([result, str])
      result := concat([result, ") -> ", toString(tar)$SyntaxHelper])
      result

    -- convert a type environment to string
    tenvToString(tb: VTB): String ==
      result : String := ""
      for i in 1..#(ks := keys tb) repeat
        k := toString(ks.i)$SyntaxHelper
        t := toString(tb.(ks.i))$SyntaxHelper
        if i < #ks then
          result := concat([result, "      ", k, ": ", t, "\n\r"])
        else
          result := concat([result, "      ", k, ": ", t])
      result

    -- convert a list of signature to string
    signaturelistToString(sl: List XREC): String ==
      result : String := ""
      totalcounter := totalcounter + 1
      if empty? sl then
        bugcounter := bugcounter + 1
        result := concat([result, "    [Function signature is not available]"])

      for i in 1..#sl repeat
        f := string(((sl.i).funname)::Symbol)
        s := signatureToString((sl.i).signature)
        if i < #sl then
          empty?(sl.i.tenv) => result := concat([result, "    ", f, ": ", s, "\n\r\n\r"])
          stringOfTenv := tenvToString(sl.i.tenv)
          result := concat([result, "    ", f, ": ", s, " where ", "\n\r", stringOfTenv, "\n\r\n\r"]) 
        else
          empty?(sl.i.tenv) => result := concat([result, "    ", f, ": ", s])
          stringOfTenv := tenvToString(sl.i.tenv)
          result := concat([result, "    ", f, ": ", s, " where ", "\n\r", stringOfTenv])
      result

    accumulationToString(al: List YREC): String ==
      result : String := ""
      for i in 1..#al repeat
        loopStr   := toString(((al.i).loopcandidate)::Syntax)$SyntaxHelper
        funsigStr := signaturelistToString((al.i).signaturelist)
        if i < #al then
          result := concat([result, "  Loop Body==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r", "  Operators being Reduced==>",_
                             "\n\r\n\r", funsigStr, ",", "\n\r\n\r"])
        else
          result := concat([result, "  Loop Body==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r", "  Operators being Reduced==>",_
                     "\n\r\n\r", funsigStr, "\n\r\n\r", "------------------------", "\n\r"])
      result

    aclToString(al: List RepeatAst): String ==
      result : String := ""
      aclandnlcounter := aclandnlcounter + #al
      for i in 1..#al repeat
        aclLoopDepths := concat(aclLoopDepths, getLoopDepth(al.i)$LoopAnalysis)
        loopStr   := toString((al.i)::Syntax)$SyntaxHelper
        if i < #al then
          result := concat([result, "  ACL Nests ==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r"])
        else
          result := concat([result, "  ACL Nests==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r", "------------------------", "\n\r"])
      result

    reductionToString(al: List REDU): String == 
      reductionFunctionCounter := reductionFunctionCounter + #al
      result : String := ""
      for i in 1..#al repeat
        expStr   := toString((al.i.reduceexp)::Syntax)$SyntaxHelper
        -- we don't differentiate annotated and unannotated.
        -- therefore, the final result may contain $
        binOp    := toString(al.i.reduceop)$SyntaxHelper
        sigStr   := signatureToString(al.i.signature)
        if i < #al then
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce function application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                               "\n\r\n\r", "    ", binOp, ": ", sigStr, ",", "\n\r\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce function application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                              "\n\r\n\r", "    ", binOp, ": ", sigStr, " where ", "\n\r", stringOfTenv, "\n\r\n\r"])
        else
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce functino application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                       "\n\r\n\r", "    ", binOp, ": ", sigStr, "\n\r\n\r", "------------------------", "\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce functino application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                        "\n\r\n\r", "    ", binOp, ": ", sigStr, " where ", "\n\r", stringOfTenv, "\n\r\n\r", "------------------------", "\n\r"])

      result

    -- no longer used
    reductionFormsToString(al: List Syntax): String == 
      reductionFormCounter := reductionFormCounter + #al
      result : String := ""
      for i in 1..#al repeat
        expStr   := toString(al.i)$SyntaxHelper
        if i < #al then
          result := concat([result, "    ", expStr, ",", "\n\r\n\r"])
        else
          result := concat([result, "    ", expStr, ",", "\n\r\n\r", "------------------------", "\n\r"])
      result

    reductionFormsToString2(al: List REDF): String == 
      reductionFormCounter := reductionFormCounter + #al
      result : String := ""
      for i in 1..#al repeat
        expStr   := toString(al.i.reduceform)$SyntaxHelper
        binOP    := string((al.i.reduceop)::Symbol)
        opSig    := signatureToString((al.i).signature)
        if i < #al then
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                               "\n\r\n\r", "    ", binOP, ": ", opSig, ",", "\n\r\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                             "\n\r\n\r", "    ", binOP, ": ", opSig, " where ", "\n\r", stringOfTenv, ",", "\n\r\n\r"])          


        else
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                       "\n\r\n\r", "    ", binOP, ": ", opSig, "\n\r\n\r", "------------------------", "\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                      "\n\r\n\r", "    ", binOP, ": ", opSig, " where ", "\n\r", stringOfTenv, "\n\r\n\r", "------------------------", "\n\r"])


      result

    getConstructorKindInString(c: Identifier): String ==
      k : ConstructorKind := getConstructorKind(c)
      k = category$ConstructorKind =>  "Category"
      k = package$ConstructorKind  =>  "Package"
      "Domain"

    toString(rl: List ZREC): String ==
      result : String := ""
      for r in rl repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := accumulationToString(r.accumulations)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    toString2(rl: List RREC): String ==
      result : String := ""
      for r in rl | not empty?(r.reductions) repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := reductionToString(r.reductions)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    toString3(rl: List RFREC): String ==
      result : String := ""
      for r in rl | not empty?(r.reduceforms) repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := reductionFormsToString(r.reduceforms)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r", "Reduce Forms==>\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    toString4(rl: List RFORM): String ==
      result : String := ""
      for r in rl | not empty?(r.reduceforms) repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := reductionFormsToString2(r.reduceforms)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result


    toString5(rl: List AREC): String ==
      result : String := ""
      for r in rl repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := aclToString(r.affineloops)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    writeARecordToFile(al: List AREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString5 al)
      true

    writeZRecordToFile(rl: List ZREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString rl)
      true

    writeRRecordToFile(rl: List RREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString2 rl)
      true

    writeRFRecordToFile(rl: List RFREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString3 rl)
      true

    writeRFORMToFile(rl: List RFORM, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString4 rl)
      true

    -- checks whether a variable is a type variable 
    -- by looking up in the global type environment
    isTypeVariable?(tp: Syntax, env: VTB): Boolean == not compound? tp and tp case Identifier and key?(tp, env)

    -- checks whether some category/domain is parameterized by some type variable
    containTypeVariable?(cat: Syntax, env: VTB): Boolean ==
      not compound? cat => isTypeVariable?(cat, env)
      for opr in getOperands cat repeat
        containTypeVariable?(opr, env) => return true
      false 

    -- returns mapping between the parameters of a category constructor
    -- and the actual parameters in the corresponding constructed category
    findMapping(l: List Identifier, rs: Syntax): VTB ==
      res: Table(Syntax, Syntax) := empty()
      for e in l for e' in getOperands(rs) repeat
        x := e::Syntax
        res.x := e'
      res

    -- replaces the appearances of all the keys of variable mapping in s with 
    -- the corresponding contents indexed by those keys    
    instantiateSyntax(s: Syntax, mapping: VTB): Syntax ==
      for k in keys mapping repeat
        s := replace(k, s, mapping.k)$SyntaxHelper
      s

    -- replaces % in as signature with the domain that implements the owner category
    -- of the signature
    instantiatePercentages(current: Syntax, t: Syntax): Syntax ==
      replace(makePercentage(), t, current)$SyntaxHelper

    -- instantiates predicate list associated to category extension/signature/attribute
    -- using the parameter mapping information in variable mapping
    instantiatePredicate(pl: List Syntax, mapping: VTB): List Syntax ==
      [instantiateSyntax(p, mapping) for p in pl]

    -- instantiates a single category extension
    -- meaning that to replace each parameter used in category definition
    -- with the actual parameter of category
    -- such mapping of replacement is stored in variable mapping
    instantiateExtension(e: Syntax, mapping: VTB): Syntax ==
      instantiateSyntax(e, mapping)

    -- called by the instantiation function below.
    instantiatePair(p: EXTP, mapping: VTB): EXTP ==
      pair(instantiateExtension(first p, mapping), instantiatePredicate(second p, mapping))

    -- instantiate both of the predicate and category extension 
    -- from a category extension list of a category constructor
    instantiateExtensionList(l: LEXTP, mapping: VTB): LEXTP ==
      l' := copy l
      [instantiatePair(e, mapping) for e in l']

    -- by instantiate attribute list, we mean only to instantiate predicate of each attribute.
    -- attribute itself is no more than an identifier, and does not need to be instantiated.
    instantiateAttributeList(l: LAP, mapping: VTB): LAP ==
      l' := copy l
      [pair(first e, instantiatePredicate(second e, mapping)) for e in l']

--------
    rightTypeHasLeftAttribute?: (Syntax, Syntax, VTB) -> Boolean
    rightTypeHasLeftSignature?: (Syntax, Syntax, VTB) -> Boolean
    rightCategoryHasLeftCategory?: (Syntax, VTB, Syntax, VTB) -> Boolean
    typeChecks?: (Syntax, VTB, Syntax, VTB) -> Boolean
--------

    -- checks whether two type constructors have the same name
    sameName?(leftType: Syntax, rightType: Syntax): Boolean ==
      (not compound?(leftType)) or (not compound?(rightType)) => false
      getOperator(rightType)::Identifier = getOperator(leftType)::Identifier 

    -- This function evaluates one predicate of a predicate list
    -- again each predicate is a term of a disjunctive normal form represented by the predicate list
    evaluatePredicate(pred: Syntax, rightEnv: VTB): Boolean ==
      -- there are two main kinds of predicates:
      -- 1. trivial: true
      -- 2. has statement whose right hand side is:
      --   2.1 attribute
      --   2.2 signature of some operator
      --   2.3 category
      pred = makeTrue() => true
      (pred' := pred::SpadAst) case HasAst =>
        r := rhs pred'
        r' := r::Syntax
        l := lhs pred'
        l' := l::Syntax
        r case AttributeAst             => rightTypeHasLeftAttribute?(name(r::AttributeAst)::Syntax, l', rightEnv)   
        r case SignatureAst             => rightTypeHasLeftSignature?(r', l', rightEnv)
        isCategory?(r')$CheckAssumption => typeChecks?(r', rightEnv, l', rightEnv)
        userError "unexpected kind of right hand side in this has predicate"
      false

    -- This function statically evaluates predicate list except the trivial [true]
    evaluateNontrivialPredicates(preds: List Syntax, rightEnv: VTB): Boolean ==
      -- evaluate each predicate in the predicate list
      -- since the predicates are orgnized in disjunctive normal form
      -- we use laziness here, i.e. some predicate evaluates to false, we directly return false
      for pred in preds repeat
        not evaluatePredicate(pred, rightEnv) => return false
      true

    -- trivial predicate list is [true]
    trivialPredicate?(preds: List Syntax): Boolean ==
      (#preds = 1) and (first(preds)::Identifier = makeTrue()::Identifier)

    -- this function does static predicate evaluation
    -- each category extension, functino declaration, or attribute in a category constructor data
    -- is associated with a predicate list whose elements represent all componenets of a disjunctive normal form
    matchPredicate(preds: List Syntax, rightEnv: VTB): Boolean ==
      -- case 1: trivial predicate [true]
      trivialPredicate? preds => true
      -- case 2: nontrivial predicates in the list
      -- the function returns true when all predicates in the list evaluate to true
      evaluateNontrivialPredicates(preds, rightEnv)

    -- this function will be called when predicate list of some category extension evaluates to true
    -- it checks whether that category extension is leftType
    matchExtension(ext: Syntax, rightEnv: VTB, leftType: Syntax, leftEnv: VTB): Boolean ==
      not sameName?(leftType, ext)                => false
      not containTypeVariable?(leftType, leftEnv) => true
      for l in getOperands(leftType) for r in getOperands(ext) repeat
        not typeChecks?(l, leftEnv, r, rightEnv)  => return false
      true

    -- This function checks whether category leftType is extList
    -- 1. we first statically evaluate the predicate of some category extension
    -- 2. if 1 returns true, we further compare whether the category under the predicate equals leftType
    searchExtensionList(leftType: Syntax, leftEnv: VTB, extList: LEXTP, rightEnv: VTB): Boolean ==
      -- look at each category extension in the extension list
      -- searching for category stored in leftType
      for ext in extList repeat
        matchPredicate(second ext, rightEnv) and matchExtension(first ext, rightEnv, leftType, leftEnv) =>
          return true
      false
   
    -- this function searches whether there is an attribute which equals attr
    -- in the attribute list attl.
    searchAttributeList(attr: Syntax, attl: LAP, rightEnv: VTB): Boolean ==
      for att in attl repeat
        matchPredicate(second att, rightEnv) and (first att = attr)=> return true
      false

    -- returns the constructor of a domain/category.
    getConstructor(t: Syntax): Constructor ==
      c := getOperator(t)::Identifier
      retract(findConstructor(c)$Constructor)$(Maybe Constructor)

    -- returns all the attributes owned by some domain.
    -- this is implemented under the help of the FunctorData domain functions.
    attributesOfDomain(dom: Syntax): List Syntax ==
      domctor := getConstructor(dom)
      domCtor: DomainConstructor := toDomainConstructor(domctor)$SyntaxHelper
      ftorData : FunctorData := functorData(domCtor)
      domAtts : List Pair(Syntax,NonNegativeInteger) := attributeData ftorData
      [first e for e in domAtts]     

    -- checks whether a domain rightType has attribute att
    rightDomainHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      attrl := attributesOfDomain(rightType)
      member?(att, attrl)

    -- recursively look into each category in a category extension list extl
    -- to examine whether there is one category has attribute att
    recursiveSearchAttributeList(att: Syntax, extl: LEXTP, rightEnv: VTB): Boolean ==
      for ext in extl repeat
        -- again we first examine the predicate, then recursively look at each qualified category
        matchPredicate(second ext, rightEnv) and rightTypeHasLeftAttribute?(att, first ext, rightEnv) => 
          return true
      false

    -- checks whether category rightType has attribute att
    rightCategoryHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isNil?(rightType)$SyntaxHelper => false
      rightTypeName : Identifier := getOperator(rightType)::Identifier
      r := getCategoryConstructorData(rightTypeName)$CategoryExtensionCollection
      m := findMapping(r.catpars, rightType)
      attrl := instantiateAttributeList(r.attributes, m)
      extl  := instantiateExtensionList(r.extensions, m)
      searchAttributeList(att, attrl, rightEnv) => true
      recursiveSearchAttributeList(att, extl, rightEnv)
      false

    -- checks whether there is a category in a join syntax has attribute att
    -- or there is an attribute in the join syntax that equals att
    rightJoinCategoriesHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- look at each element in the join ast
      for c in getOperands rightType repeat
        -- if the element is an attribute, then directly compare their name
        (c' := c::SpadAst) case AttributeAst => 
          (name(c')::Syntax) = att => return true
          false
        -- otherwise, the element is a category, we recursively examine whether the
        -- category has the attribute
        rightTypeHasLeftAttribute?(att, c, rightEnv) => return true
      false

    -- evaluates one has-predicate whose right hand side is an attribute
    -- and left hand side is a domain/category/type variable/join of categories and attributes
    rightTypeHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isDomain?(rightType)$CheckAssumption   => rightDomainHasLeftAttribute?(att, rightType, rightEnv)
      isCategory?(rightType)$CheckAssumption => rightCategoryHasLeftAttribute?(att, rightType, rightEnv)
      isTypeVariable?(rightType, rightEnv)   => rightTypeHasLeftAttribute?(att, rightEnv.rightType, rightEnv)
      isJoin?(rightType)$SyntaxHelper        => rightJoinCategoriesHasLeftAttribute?(att, rightType, rightEnv)
      userError "unexpected cases in rightTypeHasLeftAttribute?"

    instantiateSourceOfSignature(src: List Syntax, mapping: VTB, domVar: Syntax): List Syntax ==
      res : List Syntax := []
      for s in src repeat
        s' := instantiateSyntax(s, mapping)
        s' := instantiatePercentages(domVar, s')
        res := concat(res, s')
      res

    instantiateTargetOfSignature(tar: Syntax, mapping: VTB, domVar: Syntax): Syntax ==
      s' := instantiateSyntax(tar, mapping)
      s' := instantiatePercentages(domVar, s')
      s'
     
    -- This function instantiates the signature syntax of some function
    -- declaration from some category constructor data
    -- 1. replace % with the current domain domVar
    -- 2. replace each parameter used in the category definition 
    -- with the actual category constructor parameter
    instantiateSignatureSyntax(sig: Syntax, mapping: VTB, domVar: Syntax): Syntax ==
      -- bug in signature function on handling 0 and 1
      compound?(first(getOperands(sig))) => sig
      sig' := signature(sig::SpadAst::SignatureAst)
      fid := name(sig::SpadAst::SignatureAst)
      src := copy source sig'
      tar := target sig'
      src' := instantiateSourceOfSignature(src, mapping, domVar)
      tar' := instantiateTargetOfSignature(tar, mapping, domVar)
      newsig := signature(src', tar')$Signature
      newsigast := signatureAst(fid, newsig)$SignatureAst
      newsigast::Syntax

    -- This function instantaites
    --	1. the predicate list associated to a signature
    --  2. the signature itself
    instantiateSignaturePair(p: EXTP, mapping: VTB, domVar: Syntax): EXTP ==
      pair(instantiateSignatureSyntax(first p, mapping, domVar), instantiatePredicate(second p, mapping))

    -- instantiate each signature in a signature list of some category
    instantiateSignatureList(l: LSP, mapping: VTB, domVar: Syntax): LSP ==
      l' := copy l
      [instantiateSignaturePair(e, mapping, domVar) for e in l']

    -- checks whether the two signatures are equivalent
    sameSignature?(l: Syntax, r: Syntax): Boolean ==
      -- the following condition skips the function declaration for 0 and 1, 
      -- it's a workround for the nasty bug on generating signature syntax for 0 and 1
      compound?(first(getOperands(l))) or compound?(first(getOperands(r))) => false
      l' := l::SpadAst::SignatureAst
      r' := r::SpadAst::SignatureAst
      name(l') = name(r') and (signature l') = (signature r')
    
    searchSignatureList(sig: Syntax, sigList: LSP, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- look at each category extension in the extension list
      -- searching for category stored in leftType
      for s in sigList repeat
        matchPredicate(second s, rightEnv) and sameSignature?(first s, sig) => 
          return true
      false

    -- recursively look into each category, looking for the function declaration decl
    recursiveSearchSignatureList(decl: Syntax, extl: LEXTP, rightType: Syntax, rightEnv: VTB): Boolean ==
      for ext in extl repeat
        matchPredicate(second ext, rightEnv) and_
        rightDomainHasLeftSignature?(decl, first ext, rightType, rightEnv) => 
          return true
      false

    -- this function instantaite a single category cat with domain sig (whose type is cat), then looks for
    -- declaration decl in the instantiated declaration list from the operation list of the category constructor
    rightDomainHasLeftSignature?(decl: Syntax, cat: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      catName := getOperator(cat)::Identifier
      rec := getCategoryConstructorData(catName)$CategoryExtensionCollection
      m := findMapping(rec.catpars, cat)
      extl := instantiateExtensionList(rec.extensions, m)
      decll := instantiateSignatureList(rec.declarations, m, rightType)
      searchSignatureList(decl, decll, rightType, rightEnv) => true
      recursiveSearchSignatureList(decl, extl, rightType, rightEnv)

    -- this function is invoked when the type of domain rightType is a join of categories and attributes
    -- it instantiates each category in the join syntax with the domain, and checks about the membership of the
    -- function declaration 
    rightJoinCategoriesHasLeftSignature?(decl: Syntax, cat: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      for c in getOperands cat | not((c::SpadAst) case AttributeAst) repeat
        rightDomainVariableHasLeftSignature?(decl, c, rightType, rightEnv) => return true
      false

    -- this function checks whether some domain(variable) rightType implementing category cat 
    -- has some function declaration decl
    rightDomainVariableHasLeftSignature?(decl: Syntax, cat: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isJoin?(cat)$SyntaxHelper     => rightJoinCategoriesHasLeftSignature?(decl, cat, rightType, rightEnv)
      isCategory?(cat)$SyntaxHelper => rightDomainHasLeftSignature?(decl, cat, rightType, rightEnv)
      false

    -- this function checks whether the type rightType has function declaration decl
    rightTypeHasLeftSignature?(decl: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isTypeVariable?(rightType, rightEnv) => rightDomainVariableHasLeftSignature?(decl, rightEnv.rightType, rightType, rightEnv)
      userError "unexpected cases in rightTypeHasLeftSignature?"

    -- recursively goes into each qualified category extension to see whether any one of them has category leftType
    -- by qualified we mean the predicate list associated to the category extension evaluates to true
    recursiveSearchExtensionList(leftType: Syntax, leftEnv: VTB, extl: LEXTP, rightEnv: VTB): Boolean ==
      for ext in extl repeat
        matchPredicate(second ext, rightEnv) and_ 
        rightCategoryHasLeftCategory?(leftType, leftEnv, first ext, rightEnv) => return true
      false

    -- this function checks whether there's one category in the join syntax has	category leftType
    rightJoinCategoriesHasLeftCategory?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- obtain category extensions and attributes in a join ast
      catsAndAtts := getOperands rightType
      -- only search those category extensions in Join ast, skipping attributes
      for c in catsAndAtts | not((c::SpadAst) case AttributeAst) repeat
        rightCategoryHasLeftCategory?(leftType, leftEnv, c, rightEnv) => return true
      false

    -- this function finds out whether category rightType directly or indirectly extends category leftType
    foundInCategoryHierarchy?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      rightTypeName := getOperator(rightType)::Identifier
      -- obtain the category constructor data for rightType
      rec := getCategoryConstructorData(rightTypeName)$CategoryExtensionCollection
      m := findMapping(rec.catpars, rightType)
      -- does beta-conversion for the category extension list of rightType category
      extl := instantiateExtensionList(rec.extensions, m)
      -- search whether rightType directly extends leftType
      searchExtensionList(leftType, leftEnv, extl, rightEnv) => true
      -- if rightType doesn't directly extends, we further check whether it indirectly extends leftType
      -- by recursively looking into each category rightType directly extends.
      recursiveSearchExtensionList(leftType, leftEnv, extl, rightEnv)

    handleCategoryWithAttribute(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      rightType' := (rightType::SpadAst)::CategoryAst
      bd := body(rightType')
      bd' := [e::Syntax for e in bd]
      joinType := buildSyntax(makeJoin(), bd')
      rightCategoryHasLeftCategory?(leftType, leftEnv, joinType, rightEnv)

    -- this function checks whether the category rightType has category leftType
    -- e.g., this handles query such as PolynomialCategory(R, E, VarSet) has AbelianMonoid
    rightCategoryHasLeftCategory?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- case 1: the rightType is nil
      isNil?(rightType)$SyntaxHelper  => false
      -- case 2: the leftType is Type, we directly returns, this is an optimization
      isType?(leftType)$SyntaxHelper => true
      -- case 3: the two categories are equivalent
      rightType = leftType            => true
      -- case 4: rightType is a join syntax of categories and attributes
      isJoin?(rightType)$SyntaxHelper => rightJoinCategoriesHasLeftCategory?(leftType, leftEnv, rightType, rightEnv)
      -- case 5: rightType is a list of attribute wrapped as a CategoryAst
      -- for instance, this happens when we see the following sytnax: R: Ring with commutative("*") 
      (rightType::SpadAst) case CategoryAst => handleCategoryWithAttribute(leftType, leftEnv, rightType, rightEnv)
      -- case 6: rightType is a normal category
      foundInCategoryHierarchy?(leftType, leftEnv, rightType, rightEnv)

    -- convert formats between PrimitiveArray ConstructorCall and List Syntax
    convert(a: PrimitiveArray ConstructorCall): List Syntax ==
      [buildSyntax(name(constructor(a.i)), arguments(a.i)) for i in 0..(#a-1)]

    -- helper function for replacing the local slots
    replaceLocal(s: Syntax, oprs: List Syntax): Syntax ==
      empty? oprs => s
      s' := s
      for i in 1..#oprs repeat
        s' := replace(makeLocalNumberSlot(i)$SyntaxHelper, s', oprs.i)$SyntaxHelper
      s'
 
    -- Record domain constructor is not supported via functorData
    -- we manually generate functor data for it
    -- this function will be improved once necessary
    generateCategoryExtensionForRecord(): List Syntax ==
      [buildSyntax(makeSetCategory()$SyntaxHelper, [])]    

    -- this function takes in a domain dom, and returns a list of categories
    -- implemented by the domain
    getInstantiatedCategoryExtensionList(dom: Syntax): List Syntax ==
      isRecord?(dom)$SyntaxHelper => generateCategoryExtensionForRecord()
      ctor := getConstructor(dom)
      domCtor: DomainConstructor := toDomainConstructor(ctor)$SyntaxHelper
      ftorData : FunctorData := functorData(domCtor)
      domTemp : DomainTemplate := domainTemplate(ftorData)
      domCats : List Syntax := convert(categories(ftorData)$FunctorData)
      -- replace number slots in category extensions using elements in domain template
      l := [replace(c, domTemp)$SyntaxHelper for c in domCats]
      pars := getOperands(dom)
      -- further replace local# slots with the actual parameters of constructor dom
      [replaceLocal(e, pars) for e in l]

    -- this function checks domain rightType has category leftType
    -- e.g., this handles query such as Polynomial(R) has AbelianMonoid
    rightDomainHasLeftCategory?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      isType?(leftType)$SyntaxHelper => true  -- an optimization for saving query time
      categoryExtensionList := getInstantiatedCategoryExtensionList(rightType)
      member?(leftType, categoryExtensionList)

    -- this function typechecks each domain parameter against domain parameter type in the assumption 
    typeCheckDomainParameters(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      leftPars := getOperands(leftType)
      rightPars := getOperands(rightType)
      for leftPar in leftPars for rightPar in rightPars repeat
        not typeChecks?(leftPar, leftEnv, rightPar, rightEnv) => return false
      true

    -- this function checks whether an input/output domain of a reduction operator
    -- matches an input/output domain in the assumption operator
    domainVsDomain(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      not sameName?(leftType, rightType) => false
      typeCheckDomainParameters(leftType, leftEnv, rightType, rightEnv)

    -- this function checks whether the signature of a reduction operator satisfies 
    -- the type requirement specified in a user assumption
    -- here leftType is the input/output type of the binary operator from assumption
    -- rightType is the input/output type of the binary operator from extracted reduction
    typeChecks?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- case 1: basic assumption vs a specific reduction operator, 
      -- i.e., input and output types are domains
      isDomain?(leftType)$CheckAssumption and isDomain?(rightType)$CheckAssumption =>
        domainVsDomain(leftType, leftEnv, rightType, rightEnv)
      -- case 2: generic assumption vs a specific reduction operator
      isTypeVariable?(leftType, leftEnv) and isDomain?(rightType)$CheckAssumption => 
        rightDomainHasLeftCategory?(leftEnv.leftType, leftEnv, rightType, rightEnv)
      -- case 3: generic assumption vs a generic reduction operator
      isTypeVariable?(leftType, leftEnv) and isTypeVariable?(rightType, rightEnv) =>
        rightCategoryHasLeftCategory?(leftEnv.leftType, leftEnv, rightEnv.rightType, rightEnv)
      false

    -- check whether the input and output types of a reduction operator
    -- satisfies the type requirement specified in user assumption
    typeMatch?(op: TCR, rec: TCR): Boolean ==
      signatureFromAssumption := op.signature
      signatureFromReduction  := rec.signature
      -- compare each input/output types of the two operators
      for left in concat(source signatureFromAssumption, target signatureFromAssumption)_
      for right in concat(source signatureFromReduction, target signatureFromReduction) repeat
        not typeChecks?(left, op.tenv, right, rec.tenv) => return false
      true

    -- helper function for checking the membership of operator records
    -- i.e. whether operator stored in rec satisfies name and type requirements 
    -- of some operator record stored in assocops
    isInList?(rec: TCR, assocops: List TCR): Boolean ==
      for r in assocops repeat
        rec.funname = r.funname =>
          -- if the signature of the reduction operator does not contain type variable
          empty?(r.tenv) => rec.signature = r.signature  => return true
          -- if the signature contains type variable, we use the advanced type checking algorithm
          typeMatch?(r, rec) => return true
      false

    -- examine whether the operator used in the current accumulation statement
    -- is attached with associativity via user assumption
    -- the current operator information is stored in variable rec
    -- user assumption information is stored in assocops
    matchesOne?(rec: TCR, assocops: List TCR): Boolean ==
      empty?(rec.tenv) =>  isInList?(rec, assocops)
      for op in assocops repeat
        rec.funname = op.funname and typeMatch?(op, rec) => return true
      false

    --macro XREC   == Record(funname: Identifier, signature: Signature, usedin: Syntax, tenv: VTB)
    --macro YREC   == Record(loopcandidate: RepeatAst, signaturelist: List XREC)
    --macro ZREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, accumulations: List YREC)
    --macro TCR    == Record(funname: Identifier, signature: Signature, tenv: VTB)
    --macro OPREC  == Record(funname: Identifier, origin: Syntax, signature: Signature, tenv: VTB)
    -- creates a database view of the format of recording storing associative operator information
    -- the two formats are respectively defined in macros OPREC and TCR
    formatConverterTCR(rs: List OPREC): List TCR == [[r.funname, r.signature, r.tenv] for r in rs]

    -- examine whether all the accumulation statements in an accumulation loop 
    -- are using user specified associative operators so that 
    -- the whole loop is fully parallelizable
    isFullyParallelizable?(l: YREC, assocops: List OPREC): Boolean ==
      -- if the typechecker can not obtain the any signature of operator used in the loop
      -- we return false, meaning "unknown"
      empty?(l.signaturelist) => false
      assocops' := formatConverterTCR assocops
      -- verify that all the reduction operators have associativity
      for f in l.signaturelist repeat
        rec : TCR := [f.funname, f.signature, f.tenv]
        not matchesOne?(rec, assocops') => return false
      true

    -- this function examines whether there's at least one accumulation statement in an accumulation loop
    -- has associativity.
    isPartiallyParallelizable?(l: YREC, assocops: List OPREC): Boolean ==
      empty?(l.signaturelist) => false
      assocops' := formatConverterTCR assocops
      for f in l.signaturelist repeat
        rec : TCR := [f.funname, f.signature, f.tenv]
        matchesOne?(rec, assocops') => return true
      false

    -- divide extracted accumulation loop into two parts according to 
    -- their reduction operators' algebraic properties:
    -- 1. fully parallel accumulation loop
    -- 2. partially parallel accumulation loop
    extractParallelizableReductionLoop(assocops: List OPREC, recs: List ZREC): Pair(List ZREC, List ZREC)==
      full :   List ZREC := []
      partial: List ZREC := []
      for rec in recs repeat
        recf : ZREC := [rec.ctorname, rec.funname, rec.signature, []]
        recp : ZREC := [rec.ctorname, rec.funname, rec.signature, []]
        loops := rec.accumulations
        for l in loops repeat
          isFullyParallelizable?(l, assocops)     => 
            parallelAccumulationCounter := inc(parallelAccumulationCounter)
            recf.accumulations := concat(recf.accumulations, l)
          isPartiallyParallelizable?(l, assocops) => 
            partialParallelAccumulationCounter := inc(partialParallelAccumulationCounter)
            recp.accumulations := concat(recp.accumulations, l)
        if not empty?(recf.accumulations) then
          full := concat(full, recf)
        if not empty?(recp.accumulations) then
          partial := concat(partial, recp)
      pair(full, partial)

    --macro REDU   == Record(reduceexp: Syntax, reduceop: Syntax, signature: Signature)
    --macro RREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reductions: List REDU)
    -- extract parallel reduce function calls whose reduction operator is associative
    extractParallelizableReduceCall(assocops: List OPREC, recs: List RREC): List RREC ==
      result : List RREC := []
      assocops' := formatConverterTCR assocops
      for rec in recs repeat
        newrec : RREC := [rec.ctorname, rec.funname, rec.signature, []]
        for r in rec.reductions repeat
          rec : TCR := [getOperatorName(r.reduceop)$SyntaxHelper, r.signature, r.tenv]
          matchesOne?(rec, assocops') => 
            preductionFunctionCounter := preductionFunctionCounter + 1
            newrec.reductions := concat(newrec.reductions, r)
        not empty?(newrec.reductions) => result := concat(result, newrec)
      result

    --macro REDF   == Record(reduceform: Syntax, reduceop: Identifier, signature: Signature)
    --macro RFORM  == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reduceforms: List REDF)
    -- extract parallel reduce forms whose operators are associative
    extractParallelizableReduceForm(assocops: List OPREC, recs: List RFORM): List RFORM ==
      result : List RFORM := []
      assocops' := formatConverterTCR assocops
      for rec in recs repeat
        newrec : RFORM := [rec.ctorname, rec.funname, rec.signature, []]
        for r in rec.reduceforms repeat
          rec : TCR := [r.reduceop, r.signature, r.tenv]
          matchesOne?(rec, assocops') =>
            preductionFormCounter := preductionFormCounter + 1 
            newrec.reduceforms := concat(newrec.reduceforms, r) 
        not empty?(newrec.reduceforms) => result := concat(result, newrec)
      result

    -- prints out all the interesting statistics obtained from reduction detector
    printStatistics(option: Integer, useassumption: Integer, associativeOperatorList: List OPREC): Void ==
      -- first print general statistics on category/package/domain numbers
      viewStatistics()
      useassumption = 0 =>
        (option = 2) or (option =3) =>
          if (option = 2) then
            print("Affine control loop #:"::OutputForm)
          else
            print("Nested loop #:"::OutputForm)
          print(aclandnlcounter::OutputForm)
          print("Average loop depth:"::OutputForm)
          averageDepth:DoubleFloat:=convert(reduce(_+$Integer, aclLoopDepths)/aclandnlcounter)$Fraction(Integer)    
          print(averageDepth::OutputForm)
      useassumption = 1 => 
        print("Associative Operator database extracted form user assumption:"::OutputForm)
        print(associativeOperatorList::OutputForm)
        (option = 0) =>
          print("Partial parallelizable loop #:"::OutputForm)
          print(partialParallelAccumulationCounter::OutputForm)
          print("Fully parallelizable loop #:"::OutputForm)
          print(parallelAccumulationCounter::OutputForm)    
        print("Parallelizable reduce function application#:"::OutputForm)
        print(preductionFunctionCounter::OutputForm)
        print("Parallelizable reduce form #:"::OutputForm)
        print(preductionFormCounter::OutputForm)
      userError "Please read the documentation to find out correct analysis option"

    -- this function does various intializations for later reduction detection
    initialization(option: Integer, useassumption: Integer): List OPREC ==
      reductionCounter := 0
      programOption := option
      useassumption = 1 =>
        -- building category extension database for later assumption checking use
        collectAllConstructorData()$CategoryExtensionCollection
        -- collect all the associative operator from user assumption
        collectAssociativeOperator()$CheckAssumption
      []
    
    -- obtain and save both fully parallel and partially parallel accumulation loops
    extractAndSaveParallelAccumulationLoop(associativeOperatorList: List OPREC): Void ==
      r : Pair(List ZREC, List ZREC)  := extractParallelizableReductionLoop(associativeOperatorList, analysisResultList)
      parallelReductionLoops          := first r
      partiallyParallelReductionLoops := second r
      writeZRecordToFile(parallelReductionLoops, "parallel-reduce-loops")
      print("Results for fully parallelizable reduction loops have been written into parallel-reduce-loops.txt"::OutputForm)
      writeZRecordToFile(partiallyParallelReductionLoops, "partial-parallel-reduce-loops")
      print("Results for partial parallelizable reduction loops have been written into partial-parallel-reduce-loops.txt"::OutputForm)

    -- obtain and save all the accumulation loops (parallel, sequential, and partially parallel)
    saveAccumulationLoopsToFile(): Void == 
      writeZRecordToFile(analysisResultList, "reduce-loops")
      print("Results for reduction loops have been written into reduce-loops.txt"::OutputForm)

    -- obtain and save all the reduce function calls
    saveReduceFunctionsToFile(): Void ==
      writeRRecordToFile(reduceList, "reduce-functions")
      print("Results for reduce function applications have been written into reduce-functions.txt"::OutputForm)
      
    -- obtain and save all reduce forms
    saveRediceFormsToFile(): Void ==
      writeRFORMToFile(rformList, "reduce-forms")
      print("Results for reduction forms have been written into reduce-forms.txt"::OutputForm)

    -- obtain and save affine control loops
    saveAffineControlLoopsToFile(): Void ==
      writeARecordToFile(aclList, "acl-nests")
      print("ACL loop nests have been written into acl-nests.txt"::OutputForm)

    -- obtain and save all loop nests, i.e. any loop whose depth is larger than 1
    saveLoopNestsToFile(): Void ==
      writeARecordToFile(nlList, "loop-nests")
      print("All loop nests have been written into loop-nests.txt"::OutputForm)

    -- obtain and save parallel reduce function calls
    extractAndSaveParallelReduceFunction(associativeOperatorList: List OPREC): Void() ==
      parallelReduceList := extractParallelizableReduceCall(associativeOperatorList, reduceList)
      writeRRecordToFile(parallelReduceList, "parallel-reduce-functions")
      print("Results for parallelizable reduce function applications have_ 
      been written into parallel-reduce-functions.txt"::OutputForm)

    -- obtain and save parallel reduce forms
    extractAndSaveParallelReduceForm(associativeOperatorList: List OPREC): Void() ==
      parallelReduceForms := extractParallelizableReduceForm(associativeOperatorList, rformList)
      writeRFORMToFile(parallelReduceForms, "parallel-reduce-forms")
      print("Results for parallelizable reduction forms have been written into reduce-forms.txt"::OutputForm)

    -- according to analysis option, further extract corresponding information,e.g.parallel reduce function calls
    -- and save the data in a .tex file
    filterAnalysisOutput(associativeOperatorList: List OPREC, option: Integer, useassumption: Integer): Void() ==
      option = 0 =>  
        saveAccumulationLoopsToFile()
        if useassumption = 1 then extractAndSaveParallelAccumulationLoop(associativeOperatorList)      
      option = 1 =>  
        saveReduceFunctionsToFile()
        saveRediceFormsToFile()
        if useassumption = 1 then 
          extractAndSaveParallelReduceFunction(associativeOperatorList)        
          extractAndSaveParallelReduceForm(associativeOperatorList)
      option = 2 => saveAffineControlLoopsToFile()
      option = 3 => saveLoopNestsToFile()
      userError "Please read the documentation to provide correct analyze option!"   
    
    -- main entry of reduction detector
    -- parameter option:
    -- 0: extract reduction loops with functions used in the loop
    -- 1: extract reduce function and reduce forms.
    -- 2: extract all the ACL nests
    -- 3: extract all the nested loops
    -- parameter useassumption:
    -- 0: do not use user assumption to help analysis
    -- 1: use user's assumption for extracting parallel reduction
    analyze(option, useassumption) == 
      -- initilization
      associativeOperatorList : List OPREC := initialization(option, useassumption)
      -- start analyzing all files to extract accumulation loops and reduce 
      analyzeAllFiles()
      -- filters analysis results, e.g., extracting parallel reductions
      -- and write the filtered results into file
      filterAnalysisOutput(associativeOperatorList, option, useassumption)
      printStatistics(option, useassumption, associativeOperatorList)






