import SYNHELP
import TYPCHK
import LPANL
import REDANL
import CHKASSMP
import CEXCOL

)abbrev package REDUPKG ReductionAnalysisPackage
++ Author: Yue Li
++ Date Created: November 23, 2009
++ Date Last Updated: March 22, 2010
++ Description: This package provides library functions for extracting
++ parallelizable accumulation loops, reduce function calls, as well as 
++ reduce forms
ReductionAnalysisPackage(): Public == Private where
  macro VTB    == Table(Syntax, Syntax)
  macro XREC   == Record(funname: Identifier, signature: Signature, usedin: Syntax, tenv: VTB)
  macro YREC   == Record(loopcandidate: RepeatAst, signaturelist: List XREC)
  macro REDU   == Record(reduceexp: Syntax, reduceop: Syntax, signature: Signature, tenv: VTB)
  macro LTB    == Table(Pair(Identifier, Identifier), List RepeatAst)
  macro FREC   == Record(funname: Identifier, signature: Signature, arity: Integer)
  macro DREC   == Record(funname: Identifier, signature: Signature, body: DefinitionAst, typeenv: VTB, accumulations: List YREC)
  macro ZREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, accumulations: List YREC)
  macro RREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reductions: List REDU)
  macro RFREC  == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reduceforms: List Syntax)
  macro AREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, affineloops: List RepeatAst)

  -- for storing reduce forms
  macro REDF   == Record(reduceform: Syntax, reduceop: Identifier, signature: Signature, tenv: VTB)
  macro RFORM  == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reduceforms: List REDF)
  -- for storing associative operator records
  macro OPREC == Record(funname: Identifier, origin: Syntax, signature: Signature, tenv: VTB)
  --- for  category extension database to use
  macro TCR == Record(funname: Identifier, signature: Signature, tenv: VTB)
  macro EXTP  == Pair(Syntax, List Syntax) -- (category/attribute, predicate)
  macro LEXTP == List EXTP
  macro LAP   == LEXTP                -- for attributes, i.e. conditional and unconditional
  macro LSP   == LEXTP                -- for signatures, i.e. conditional and unconditional
  macro CEXTR == Record(catname: Identifier, catpars: List Identifier,_ 
                        partyps: List Syntax, declarations: LSP, extensions: LEXTP, attributes: LAP)
  macro CEXTDB == List CEXTR
  Public == with
    analyze: (Integer, Integer) -> Boolean
    analyzeReduction: (String, Integer) -> Boolean
    analyzeOneFile: List Syntax -> Integer
    analyzeAllFiles: Integer
    viewImports: List ImportAst
    viewMacros: VTB
    viewCtorInfo: Void()
    viewReplacedCtor: Syntax
    viewExportedSig: List FREC
    viewUnexportedSig: List FREC
    viewReduceFuns: List RREC
    viewReduceForms: List RFREC
    viewFunDefs: List DREC
    viewGlobalVars: VTB
    viewStatistics: Void

    ++ testing
    collectFromStatement: (SpadAst, Identifier, VTB) -> Integer
    collectFromDefinition: (DefinitionAst, Identifier, VTB) -> Integer
    getConstructorKindInString: Identifier -> String
    viewAcls: () -> List AREC


  Private == add
    import SpadParser
    --Global variables
    reductionCounter : Integer := 0
    fCount: Integer := 0
    count: Integer := 0
    defNo: Integer := 0
    bugcounter : Integer := 0
    -- ACL nests counter
    aclandnlcounter: Integer := 0
    aclLoopDepths: List Integer := []
    -- reductino loop counter
    totalcounter : Integer := 0
    ptotalcounter : Integer := 0
    pptotalcounter : Integer := 0
    reductionFormCounter: Integer := 0
    preductionFormCounter: Integer := 0
    reductionFunctionCounter: Integer := 0
    preductionFunctionCounter: Integer := 0

    -- used for preprocessing
    -- 0: extract reduction loops with functions used in the loop
    -- 1: extract reduce function and reduce forms. 
    -- 2: extract acl loop nests (e.g. analyze(2, 0))
    programOption : Integer := 0
    -- for affine loop nests
    aclList: List AREC                                 := []
    -- for nested loops
    nlList: List AREC                                  := []
    -- for reduction loops
    analysisResultList: List ZREC                      := []
    -- for reduce function calls
    reduceList: List RREC                              := []
    -- no longer used 
    reduceFormList: List RFREC                         := []
    -- the improved list for reduce forms
    rformList : List RFORM                             := []
    importList : List ImportAst                        := []
    fundefList : List DREC                             := []
    categorySet: Set Identifier                        := {}
    packageSet:  Set Identifier                        := {}
    domainSet:   Set Identifier                        := {}
    constructorName: Identifier                        := gensym()
    constructorParameters: List Syntax                 := []
    constructorParameterTypes: List Syntax             := []
    constructorMacros: VTB                             := empty()
    -- the whole constructor definition body with % replaced by the constructor call form
    replacedConstructorDef : Syntax                    := gensym()::Syntax
    localUnexportedSignatureDatabase : List FREC       := []
    -- exported signatures with slot instantiated but without instantiating %
    localExportedSignatureDatabase : List FREC         := [] 
    -- Table for storing global variables such as constructor parameter, and global variable in capsule
    -- this will become global type environment, storing global function declaration, global 
    -- variable declaration including the immediate initialization
    cgv: VTB := empty()
    viewImports == importList
    viewFunDefs == fundefList
    viewMacros  == constructorMacros
    viewCtorInfo ==
      print(constructorName::OutputForm)
      print(constructorParameters::OutputForm)
      print(constructorParameterTypes::OutputForm)
    viewReplacedCtor  == replacedConstructorDef
    viewExportedSig   == localExportedSignatureDatabase
    viewUnexportedSig == localUnexportedSignatureDatabase
    viewGlobalVars    == cgv
    viewReduceFuns    == reduceList
    viewReduceForms   == reduceFormList
    viewAcls          == aclList
    viewStatistics    ==
      if programOption = 0 then 
        print("Reduction loop #:"::OutputForm)
        print(totalcounter::OutputForm)
      if programOption = 1 then
        print("Reduction function call #:"::OutputForm)
        print(reductionFunctionCounter::OutputForm)        
        print("Reduction form #:"::OutputForm)
        print(reductionFormCounter::OutputForm)      
      print("Total function definition #:"::OutputForm)
      print(defNo::OutputForm)
      print("Total file #:"::OutputForm)
      print(fCount::OutputForm)
      print("Package #:"::OutputForm)
      print((#packageSet)::OutputForm)
      print("Category #:"::OutputForm)
      print((#categorySet)::OutputForm)
      print("Domain #:"::OutputForm)
      print((#domainSet)::OutputForm)

    makePercentage: Syntax          == '%::Identifier::Syntax
    makeCase: Syntax                == 'case::Identifier::Syntax
    makeTrue: Syntax                == 'true::Identifier::Syntax
    makeNil: Syntax                 == 'nil::Identifier::Syntax
    makeJoin: Syntax                == 'Join::Identifier::Syntax

    cleanUpConstructorInformation: Boolean ==
      cgv := empty()
      constructorName: Identifier := gensym()
      replacedConstructorDef : Syntax := gensym()::Syntax
      constructorParameters := []
      constructorParameterTypes := []
      constructorMacros := empty()
      importList := []
      fundefList := []
      ctorExportedSignatures := []
      localExportedSignatureDatabase := []  
      localUnexportedSignatureDatabase := []
      true

    cleanUp():Boolean ==
      fCount := 0
      count := 0
      defNo := 0
      analysisResultList := []
      aclList            := []
      nlList             := []
      reduceList         := []
      reduceFormList     := []
      rformList          := []
      categorySet        := {}
      packageSet         := {}
      domainSet          := {}
      cleanUpConstructorInformation()
      true

    -- collect macros into table
    collectMacroFromDefinitionAst(functionName: Identifier, definitionBody: SpadAst): Boolean ==
      macroName := functionName::Syntax
      macroBody := definitionBody::Syntax
      constructorMacros.macroName := macroBody
      true      

    collectMacro(t: MacroAst): Boolean ==
      macroHead := head(t)$MacroAst
      macroBody := (body(t)$MacroAst)::Syntax
      macroName := (name(macroHead)$HeadAst)::Syntax
      constructorMacros.macroName := macroBody
      true

    -- does maco expansion
    -- currently only for ColonAst, DefinitionAst before they are collected, and for global type environment before
    -- passing it to typechecker.
    macroExpansionForSyntax(s: SpadAst): SpadAst ==
      s' := s::Syntax
      for m in keys constructorMacros repeat
        mac := constructorMacros.m
        sub := m
        --if compound? mac then
        --  sub := buildSyntax(m, [])
        s' := replace(sub, s', mac)$SyntaxHelper
      s'::SpadAst

    macroExpansionForTypeEnvironmentTable(gte: VTB): VTB ==
      gte' := copy gte
      for k in keys gte' repeat
        gte'.k := macroExpansionForSyntax((gte'.k)::SpadAst)::Syntax
      gte'

    macroExpansionForImportList(): List ImportAst ==
      importList' := copy importList
      for i in 1..#importList' repeat
        importList'.i := macroExpansionForSyntax((importList'.i)::Syntax::SpadAst)::Syntax::ImportAst
      importList'

    macroExpansion(defAst: SpadAst): SpadAst ==
      defAst' := defAst
      op       := getOperator(defAst'::Syntax)::Identifier
      operands := getOperands(defAst'::Syntax)
      bodySyntax := operands.last
      -- from the last macro to the first macro
      -- function keys returns this correct order
      --bodySyntax := macroExpansionForSyntax(bodySyntax::SpadAst)::Syntax

      for m in keys constructorMacros repeat
        bodySyntax := replace(m, bodySyntax, constructorMacros.m)$SyntaxHelper

      operands.last := bodySyntax
      -- if this is definitionAst, we also need to expand its signature
      if defAst case DefinitionAst then
        --operands.2 := macroExpansionForSyntax((operands.2)::SpadAst)::Syntax
        for m in keys constructorMacros repeat
          operands.2 := replace(m, operands.2, constructorMacros.m)$SyntaxHelper
      -- if this is a LetAst and the left hand side is a ColonAst
      if defAst case LetAst and  compound?(lhs(defAst::Syntax::LetAst)::Syntax) and_
         (l := lhs(defAst::Syntax::LetAst)) case ColonAst then
        operands.1 := macroExpansion(l)::Syntax
      buildSyntax(op, operands)::SpadAst

    -- filter out the import statement before the category definition
    importFilter(l: List Syntax): Syntax ==
      for s in l repeat
        (s' := s::SpadAst) case ImportAst => importList := concat(importList, s::ImportAst)
        s' case MacroAst => collectMacro(s::MacroAst)
        s' case DefinitionAst or s' case WhereAst => return s
      l.last

    initGlobalVariableEnvironment(ctorName: Identifier, ctorPars: List Identifier, ctorTps: List Syntax): VTB ==
      for p in ctorPars for t in ctorTps repeat
        p' := p::Syntax
        cgv.p'  := t
      cgv

    constructorCallForm():Syntax == 
      buildSyntax(constructorName::Syntax, constructorParameters)

    instantiatePercentage(signatureast: SpadAst): Syntax ==
      signatureast' := signatureast::Syntax
      replace(makePercentage(), signatureast', constructorCallForm())$SyntaxHelper

    -- update the global type environment
    updateGlobalTypeEnvironment(gte: VTB, id: Syntax, tp: Syntax): VTB ==
      qsetelt!(gte, id, tp)
      gte

    updateGlobalTypeEnvFromCondition(cond: SpadAst, gte: VTB): VTB ==
      compound?(cond::Syntax) and cond case HasAst =>
        cond := macroExpansionForSyntax(cond)
        cond' := cond::Syntax::HasAst
        v   := (lhs cond')::Syntax
        cat := (rhs cond')::Syntax
        key?(v, gte) => 
          if isJoin?(tp := gte.v)$SyntaxHelper then 
            gte.v := buildSyntax(makeJoin(), concat(getOperands tp, cat))
          else
            gte.v := buildSyntax(makeJoin(), [tp, cat])
          gte
        gte.v := cat
        gte
      gte

    mappingAst2Signature(m: MappingAst): Signature ==
      src : List Syntax := []
      tar := (target m)::Syntax
      for s in source m repeat
        src := concat(src, s::Syntax)
      signature(src, tar)

    updateUnexportedSignatureDatabase(fn: Identifier, sig: Signature, a: Integer): Boolean ==
      r: FREC := [fn, sig, a]
      localUnexportedSignatureDatabase := concat(localUnexportedSignatureDatabase, r)
      true

    getFunctionSignatureFromColonAst(sa: SpadAst, gte: VTB): Boolean ==
      sa'   := sa::Syntax::ColonAst
      right := rhs(sa')::Syntax::SpadAst
      left  := lhs(sa')::Syntax::SpadAst
      if compound?(right::Syntax) and_ 
         right case MappingAst and_
         (left' := left::Syntax) case Identifier  then
      -- if this is a function signature
        right' := right::Syntax::MappingAst
        updateUnexportedSignatureDatabase(left'::Identifier, mappingAst2Signature(right'),  #(source(right')$MappingAst))
        gte := updateGlobalTypeEnvironment(gte, left::Syntax, right::Syntax) 
      true

    signatureComplete?(sig: Signature): Boolean ==
      for t in concat(source sig, target sig) repeat
        nil? t => return false
      true

    -- update local unexported signature database
    -- skip those function definition which does not have a signature 
    -- their signatures have already been shown in exported ones, or in the local declaration extracted already.

    isRep?(fn: Identifier): Boolean == fn = 'Rep::Identifier

    updateUnexportedDatabaseWhenMeetRep(bd: SpadAst): Boolean ==
      recordForRep : FREC := ['rep::Identifier, signature([makePercentage()], bd::Syntax), 1]
      recordForPer : FREC := ['per::Identifier, signature([bd::Syntax], makePercentage()), 1]
      localUnexportedSignatureDatabase := concat(localUnexportedSignatureDatabase, [recordForRep, recordForPer])
      true

    updateUnexportedDatabaseWhenMeetFunDef(fn: Identifier, sig: Signature, a: Integer, bd: SpadAst): Boolean ==
      isRep?(fn)                  => updateUnexportedDatabaseWhenMeetRep(bd)
      not signatureComplete?(sig) => false
      r : FREC := [fn, sig, a]
      -- already in exported or unexported signature database?
      member?(r, localExportedSignatureDatabase) or member?(r, localExportedSignatureDatabase) => false
      -- otherwise, update the unexpoconstructorNamerted signature database with this entry
      localUnexportedSignatureDatabase := concat(localUnexportedSignatureDatabase, r)
      true

    signatureMatch?(actual: Signature, expect: Signature): Boolean ==
      actualSignatureList := concat(source actual, target actual)
      expectSignatureList := concat(source expect, target expect)
      for x in actualSignatureList for y in expectSignatureList repeat
        not nil? x and not x = y => return false
      true

    searchInSignatureDatabase(fn: Identifier, sig: Signature, db: List FREC): Pair(Boolean, Signature) ==
      for entry in db repeat
        if entry.funname = fn and_ 
           entry.arity = #source(sig) and_ 
           signatureMatch?(sig, entry.signature) then 
          return pair(true, entry.signature)
      pair(false, sig)

    updateParameterTypeFromTypeEnvironment(pars: List Syntax, sig: Signature, gte: VTB): Signature ==
      src := source sig
      tar := target sig
      for i in 1..#src for p in pars repeat
        if not (p case String) and key?(p, gte) then
          src.i := gte.p
      signature(src, tar)

    getCompleteSignature(fn: Identifier, pars: List Syntax, sig: Signature, gte: VTB): Signature ==
      -- search in global type environment first
      if not (fn = makeCase()::Identifier) then 
        sig := updateParameterTypeFromTypeEnvironment(pars, sig, gte)
        signatureComplete?(sig) => return sig
      -- after searching the global type environment, if the type is still incomplete
      -- then search the two databases
      first(x := searchInSignatureDatabase(fn, sig, localExportedSignatureDatabase))   => second x
      first(y := searchInSignatureDatabase(fn, sig, localUnexportedSignatureDatabase)) => second y
      print(fn::OutputForm)
      print(sig::OutputForm)
      print(constructorMacros::OutputForm)
      userError "unexpected: the signature can not be found in any of the two databases."

    -- should add exclamation.
    instantiatePercentageInSource(src: List Syntax): List Syntax ==
      for i in 1..#src repeat
        src.i := replace(makePercentage(), src.i, constructorCallForm())$SyntaxHelper
      src

    instantiatePercentageForListSyntax(s: List Syntax): List Syntax ==
      instantiatePercentageInSource(s)

    instantiatePercentageInTarget(tar: Syntax): Syntax ==
      replace(makePercentage(), tar, constructorCallForm())$SyntaxHelper

    instantiatePercentageForSignature(s: Signature): Signature ==
      src := instantiatePercentageInSource copy source s
      tar := instantiatePercentageInTarget target s
      signature(src, tar)

    instantiatePercentageForLoops(l: List RepeatAst): List RepeatAst ==
      result := copy l
      for i in 1..#result repeat
        result.i := (replace(makePercentage(), (result.i)::Syntax, constructorCallForm())$SyntaxHelper)::RepeatAst
      result

    filterOutMappingAst(gte: VTB): VTB == 
      gte' := copy gte
      for k in keys gte' repeat
        if compound?(gte'.k) and (gte'.k)::SpadAst case MappingAst then
          remove!(k, gte')
      gte'  

    collectReduceForms(r: List Syntax): Pair(List Syntax, List Syntax) ==
      reduceFun : List Syntax := []
      reduceForm: List Syntax := []
      for e in r repeat
        if getOperator(e) case Identifier then
          getOperator(e)::Identifier = 'REDUCE::Identifier => reduceForm := concat(reduceForm, e)
          getOperator(e)::Identifier = 'reduce::Identifier => reduceFun := concat(reduceFun, e)
      pair(reduceFun, reduceForm)

    -- collect all the function definitions in the capsule, attaching with its complete signature,
    -- its complete AST, and an initialized type environment
    -- Note that % in its signature is not replaced with the constructor call form
    updateFunDefList(fn: Identifier, sig: Signature, defAst: DefinitionAst, bd: SpadAst, gte: VTB): Boolean ==
      -- we don't do typechecking for rep and per. or Rep ==
      -- because we generate its type, not user, therefore it is always correct.
      isRep?(fn) => true
      -- make a copy of the defintion ast
      defAst' := defAst
      gte' := macroExpansionForTypeEnvironmentTable(gte)
      gte' := filterOutMappingAst(gte')
      importList' := macroExpansionForImportList()
      if programOption = 0 then
        -- analyze the loop, extracting reductions 
        resultFromLoopAnalysis: Pair(LTB, List List Syntax) := extractReductionPatternFromFunctionDefinition(defAst', constructorName, copy gte')$LoopAnalysis 
        loopTable: LTB := first resultFromLoopAnalysis
        accVariables: List List Syntax := second resultFromLoopAnalysis
        -- if there is no interesting loop, we do nothing.
        empty? loopTable => return true
        #keys(loopTable) > 1 => 
          print(loopTable::OutputForm)
          userError "unexpected results from analysis framework [has more than 1 entry in the table]"
        print(" ")
        print("-------------------------------------------------------------")
        print("|  Encounter potential reduction, start doing typechecking  |")
        print("-------------------------------------------------------------")
        print(" ")     
        k := first keys loopTable
        loopList : List RepeatAst := loopTable.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then 
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentage(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        loopList' : List RepeatAst := instantiatePercentageForLoops(loopList)
        -- build the record
        r : DREC := [fn, sig', defAst', copy gte', []]
        -- typechecks the function definition body
        resultFromTypeChecker : Pair(VTB, List YREC) := checkFunctionDefinition(r,_ 
                                             constructorName, constructorParameters,_
                                             localExportedSignatureDatabase, localUnexportedSignatureDatabase,_
                                             importList', constructorMacros,_
                                             loopList', accVariables)$TypeChecker
        r.typeenv := first resultFromTypeChecker
        r.accumulations := second resultFromTypeChecker
        fundefList := concat(fundefList, r)
        -- update the final result to be written into file
        r' : ZREC := [constructorName, r.funname, r.signature, r.accumulations]
        analysisResultList := concat(analysisResultList, r')
------------------------------------------------------------------------------------------------------

      if programOption = 2 then
        resultFromACFAnalysis : LTB := extractAffineControlLoopFromFunctionDefinition(defAst', constructorName, copy gte')$LoopAnalysis
        empty? resultFromACFAnalysis => return true
        #keys(resultFromACFAnalysis) > 1 =>
          print(resultFromACFAnalysis::OutputForm)
          userError "unexpected results from analysis framework [has more than 1 entry in the table]"
        print(" ")
        print("-------------------------------------------------------------")
        print("|  Encounter affine control loop nest                       |")
        print("-------------------------------------------------------------")
        print(" ")
        k := first keys resultFromACFAnalysis
        loopList : List RepeatAst := resultFromACFAnalysis.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentage(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        loopList' : List RepeatAst := instantiatePercentageForLoops(loopList)
        r' : AREC := [constructorName, fn, sig', loopList']
        aclList := concat(aclList, r')

------------------------------------------------------------------------------------------------------

      if programOption = 3 then
        resultFromLoopNestsAnalysis : LTB := extractAllLoopNests(defAst', constructorName, copy gte')$LoopAnalysis
        empty? resultFromLoopNestsAnalysis => return true
        #keys(resultFromLoopNestsAnalysis) > 1 =>
          print(resultFromLoopNestsAnalysis::OutputForm)
          userError "unexpected results from analysis framework [has more than 1 entry in the table]"
        print(" ")
        print("-------------------------------------------------------------")
        print("|  Encounter loop nest                                      |")
        print("-------------------------------------------------------------")
        print(" ")
        k := first keys resultFromLoopNestsAnalysis
        loopList : List RepeatAst := resultFromLoopNestsAnalysis.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentage(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        loopList' : List RepeatAst := instantiatePercentageForLoops(loopList)
        r' : AREC := [constructorName, fn, sig', loopList']
        nlList := concat(nlList, r')

-------------------------------------------------------------------------------------------------------

      if programOption = 1 then
        -- analyze the loop, extracting reductions 
        reduceForms : List Syntax := extractReduceFormsFromFunctionDefinition(defAst', constructorName)$ReduceAnalysis 
        -- if there is no interesting loop, we do nothing.

        reductionCounter := reductionCounter + #(reduceForms)
        --k := first keys loopTable
        --loopList : List RepeatAst := loopTable.k
        sig' := sig
        -- sigh, the following code is due to the bug caused by "left", "last"
        pars := getOperands(first(getOperands(defAst::Syntax)))
        if not signatureComplete?(sig) then 
          sig' := getCompleteSignature(fn, pars, sig, gte)
        -- instantiate the % in the function body with the ctor call form
        defAst' := instantiatePercentage(defAst::Syntax::SpadAst)::DefinitionAst
        -- instantiate the % in the signature with the ctor call form
        sig'    := instantiatePercentageForSignature(sig')
        --instantiate the % in the collected potential repeatAsts
        reduceForms' : List Syntax := instantiatePercentageForListSyntax(reduceForms)

        -- we don't divide them right now
        --x := collectReduceForms(reduceForms')
        --reduceFormList := second x
        --reduceForms'   := first x

        --if not empty? reduceFormList then
        --  rec : RFREC := [constructorName, fn, sig', reduceFormList] 
        --  L_reduce_form := concat(L_reduce_form, rec)

        empty? reduceForms' => return true

        print(" ")
        print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
        print("$  Encounter potential reduce forms and expressions, start typechecking  $")
        print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
        print(" ")     

        r : DREC := [fn, sig', defAst', copy gte', []]

        -- typechecks the function definition body
        resultFromTypeChecker : Pair(List REDU, List REDF) := checkFunctionDefinition2(r,_ 
                                             constructorName, constructorParameters,_
                                             localExportedSignatureDatabase, localUnexportedSignatureDatabase,_
                                             importList', constructorMacros,_
                                             reduceForms')$TypeChecker

        reduceFunctionRecord : RREC := [constructorName, fn, sig', first resultFromTypeChecker]
        reduceFormRecord : RFORM := [constructorName, fn, sig', second resultFromTypeChecker]
        reduceList := concat(reduceList, reduceFunctionRecord)
        rformList := concat(rformList, reduceFormRecord)
      true

    updateGlobalTypeEnvironmentFromColonAst(cast: SpadAst, gte: VTB): VTB ==
      getFunctionSignatureFromColonAst(cast, gte)
      varLst := listColonAst(cast::Syntax::ColonAst)$SyntaxHelper
      varTyp := (rhs(cast::Syntax::ColonAst))::Syntax
      for v in varLst repeat
        gte := updateGlobalTypeEnvironment(gte, v, varTyp)
      gte

    isTypeExpression?(s: SpadAst): Boolean ==
      s' := s::Syntax
      not compound? s' => false
      (ctor := getOperator(s')) case Identifier => 
         retractIfCan(findConstructor(ctor::Identifier)$Constructor)$(Maybe Constructor) case "failed" => false
         true
      false
          
    -- collect the loop ast from a statement
    collectFromStatement(dBody: SpadAst, ctor: Identifier, gte: VTB): Integer ==
      if not compound?(dBody::Syntax) then
        return count
      dBody case ImportAst =>
        importList := concat(importList, dBody::Syntax::ImportAst)        
        count
      dBody case SignatureAst => count
      dBody case MacroAst => 
        collectMacro(dBody::Syntax::MacroAst)
        count
      dBody case DefinitionAst => 
        defNo := defNo + 1
        collectFromDefinition(dBody::Syntax::DefinitionAst, ctor, copy gte)
        count
      dBody case SequenceAst =>
        stmtLst:= body(dBody::Syntax::SequenceAst)$SequenceAst
        for stmt in stmtLst repeat
          collectFromStatement(stmt, ctor, gte)
        count
      dBody case IfAst => 
        dBody'   := dBody::Syntax::IfAst
        thBranch := thenBranch(dBody')$IfAst
        elBranch := elseBranch(dBody')$IfAst
        cond     := condition(dBody')$IfAst
        if compound?(thBranch::Syntax) then
          gte' := copy gte
          gte' := updateGlobalTypeEnvFromCondition(cond, gte')          
          collectFromStatement(thBranch, ctor, gte')
        if compound?(elBranch::Syntax) then
          collectFromStatement(elBranch, ctor, copy gte)
        count
      dBody case ReturnAst =>
        rtn := expression(dBody::Syntax::ReturnAst)$ReturnAst
        if compound?(rtn::Syntax) then
          collectFromStatement(rtn, ctor, gte)
        count
      dBody case RepeatAst =>
        b := dBody::Syntax::RepeatAst
        count := count + 1
        count
      dBody case CoerceAst =>
        coeast := dBody::Syntax::CoerceAst
        tp := ((target(coeast))$CoerceAst)::Syntax
        exp := (expression(coeast)$CoerceAst)::Syntax
        coerExp := expression(dBody::Syntax::CoerceAst)$CoerceAst
        if compound?(coerExp::Syntax) then
          collectFromStatement(coerExp, ctor, gte)
        count
      dBody case ExitAst =>
        dbexp := expression(dBody::Syntax::ExitAst)$ExitAst
        collectFromStatement(dbexp, ctor, gte)
      dBody case LetAst =>
        dBody' := (macroExpansion dBody)::Syntax::LetAst        
        id := getLhs(dBody')$SyntaxHelper
        if not compound?((l := lhs(dBody'))::Syntax) and_
           l case Identifier and_
           (isRep?(l::Identifier) or isTypeExpression? rhs dBody') then
          collectMacroFromDefinitionAst(l::Identifier, rhs(dBody'))  
          updateUnexportedDatabaseWhenMeetRep(rhs(dBody'))
        else if compound?((l := lhs(dBody'))::Syntax) and l case ColonAst then
          tp := rhs(l::Syntax::ColonAst)::Syntax
          gte := updateGlobalTypeEnvironment(gte, id, tp)
        else
          gte' := macroExpansionForTypeEnvironmentTable(gte)
          gte' := filterOutMappingAst(gte') 
          importList' := macroExpansionForImportList()
          tp   := checkGlobalLetAst(dBody',_ 
                                    gte', constructorName, constructorParameters,_
                                    localExportedSignatureDatabase, localUnexportedSignatureDatabase,_
                                    importList')$TypeChecker
          gte  := updateGlobalTypeEnvironment(gte, id, tp)  
        count
      dBody case WhileAst => count  
      dBody case ColonAst => 
        gte := updateGlobalTypeEnvironmentFromColonAst(macroExpansion(dBody), gte)
        count
      dBody case ConstructAst => count
      dBody case CollectAst => count
      dBody case CaseAst => count
      count

    -- collects loop from one function definition
    collectFromDefinition(defAst: DefinitionAst, ctor: Identifier, gte: VTB): Integer ==
      defAst' := (macroExpansion(defAst::Syntax::SpadAst))::DefinitionAst
      hd := head(defAst')$DefinitionAst
      functionName := name hd
      ary := #(parameters(hd)$HeadAst)
      sig := signature(defAst')$DefinitionAst
      dBody := body(defAst')$DefinitionAst
      if not isRep?(functionName) and ary = 0 and isTypeExpression?(dBody) then
        -- treat this function abstraction as macro
        -- or can I say this is inlining?
        --print(defAst'::Syntax::OutputForm)
        collectMacroFromDefinitionAst(functionName, dBody)
      else
        ---------------------- add two passes here ----
        updateUnexportedDatabaseWhenMeetFunDef(functionName, sig, ary, dBody)
        updateFunDefList(functionName, sig, defAst', dBody, gte)
        --------------------------
      -- terminate at each function definition level
      count

    -- analysis for T_TopLevel statements (definitions)
    collectFromTopLevel(sa: SpadAst, ctor: Identifier, gte: VTB): Integer ==
      sa case ColonAst => 
        -- collect the global variable declared in the capsule
        --print(sa::Syntax::OutputForm)
        gte := updateGlobalTypeEnvironmentFromColonAst(macroExpansion(sa), gte)
        count
      sa case SignatureAst => count
      sa case MacroAst => 
        collectMacro(sa::Syntax::MacroAst)
        count
      sa case ImportAst => 
        importList := concat(importList, sa::Syntax::ImportAst)        
        count
      sa case DefinitionAst => 
        defNo := defNo + 1
        collectFromDefinition(sa::Syntax::DefinitionAst, ctor, copy gte)
        count
      sa case SequenceAst => collectFromStatement(sa, ctor, gte)
      sa case LetAst => 
        -- macroExpansion first
        sa' := (macroExpansion sa)::Syntax::LetAst
        id := getLhs(sa')$SyntaxHelper
        if not compound?((l := lhs(sa'))::Syntax) and_
           l case Identifier and_
           (isRep?(l::Identifier) or isTypeExpression? rhs sa') then
          collectMacroFromDefinitionAst(l::Identifier, rhs sa')  
          updateUnexportedDatabaseWhenMeetRep rhs sa'
        else if compound?((l := lhs(sa'))::Syntax) and l case ColonAst then
          tp := rhs(l::Syntax::ColonAst)::Syntax
          gte := updateGlobalTypeEnvironment(gte, id, tp)
        else
          gte' := macroExpansionForTypeEnvironmentTable gte
          gte' := filterOutMappingAst gte'
          importList' := macroExpansionForImportList()
          tp   := checkGlobalLetAst(sa', gte', constructorName, constructorParameters, localExportedSignatureDatabase, localUnexportedSignatureDatabase, importList')$TypeChecker
          gte := updateGlobalTypeEnvironment(gte, id, tp)
        count  
        --collectFromStatement(sa, ctor, gte)
        -- above two cases are for handling some weird parsing result (ZMOD)
      sa case IfAst =>
        sa' := sa::Syntax::IfAst
        thBranch := thenBranch(sa')$IfAst
        elBranch := elseBranch(sa')$IfAst
        cond     := condition(sa')$IfAst
        if compound?(thBranch::Syntax) then
          gte' := copy gte
          gte' := updateGlobalTypeEnvFromCondition(cond, gte')
          collectFromTopLevel(thBranch, ctor, gte')
        if compound?(elBranch::Syntax) then
          collectFromTopLevel(elBranch, ctor, copy gte)
        count
      collectFromStatement(sa, ctor, gte)

    -- collect loops from a list of capsules
    collectCapsule(sal: List SpadAst, ctor: Identifier): Integer ==
      for sa in sal repeat
        collectFromTopLevel(sa, ctor, cgv)
      count

    -- collect loops from a package
    collectPackage(s: Syntax, ctor: Identifier): Integer ==
      ctorPar : List Identifier := parameters(head(mainExpression(s::WhereAst)$WhereAst::Syntax::DefinitionAst)$DefinitionAst)$HeadAst
      qual := qualifier(s::WhereAst)$WhereAst
      seq  := (qual::Syntax::SequenceAst)
      seqBody := body(seq)$SequenceAst
      wCapAl : List SpadAst := empty()      
      b : List SpadAst
      k : Integer := 0
      for st in seqBody repeat
        if (st case MacroAst) then
          collectMacro(st::Syntax::MacroAst)
        if (st case ColonAst) then
          cgv := updateGlobalTypeEnvironmentFromColonAst(macroExpansion(st), cgv)
        if (st case ExitAst) then
          a := expression(st::Syntax::ExitAst)$ExitAst
          b := body(a::Syntax::CapsuleAst)$CapsuleAst
        b
      for x in b repeat
        x' := x::Syntax
        id := getOperator(x')
        if (id case Identifier) then
          id' := id::Identifier
          if (id'::Symbol = 'add) then
            wCapAl := body((body(x::Syntax::AddAst)$AddAst)::Syntax::CapsuleAst)$CapsuleAst
            k := 1 
        if (x case CapsuleAst) then
          wCapAl := body(x::Syntax::CapsuleAst)$CapsuleAst
      collectCapsule(wCapAl, ctor)
      count

    -- collects loops from a typical category, i.e.,  Cats():Category == Cat with ... add..
    collectCategory(s: Syntax, ctor: Identifier): Integer == 
      cDef := (s::DefinitionAst)
      cBody := body(cDef)$DefinitionAst::Syntax
      cb := cBody::SpadAst
      id := getOperator(cBody)
      id case Identifier =>
        id' := id::Identifier
        if (id'::Symbol = 'add) then 
          cCap:=body(cBody::AddAst)$AddAst::Syntax
          cCapAl : List SpadAst := body(cCap::CapsuleAst)$CapsuleAst
          collectCapsule(cCapAl, ctor)
        if (cb case CapsuleAst) then
          cCapAl : List SpadAst := body(cBody::CapsuleAst)$CapsuleAst
          collectCapsule(cCapAl, ctor)
        count
      -- this case handles a category which only has with capsule
      cb case CategoryAst => count
      count

    -- analysis for typical domain only has add
    collectDomain(s: Syntax, ctor: Identifier): Integer ==
      domDef := body(s::DefinitionAst)$DefinitionAst
      dDef := domDef::Syntax
      id := getOperator(dDef)
      if id case Identifier then
        id' := id::Identifier
        if (id'::Symbol = 'add) then 
          t := body(domDef::Syntax::AddAst)$AddAst
          if t case CapsuleAst then
            domCap: List SpadAst := body(t::Syntax::CapsuleAst)$CapsuleAst
            collectCapsule(domCap, ctor)
        if (domDef case CapsuleAst) then
          domCap: List SpadAst := body(domDef::Syntax::CapsuleAst)$CapsuleAst
          collectCapsule(domCap, ctor)
      count

----------------------------------- for building local function database
    makeNumberSlot(i: Integer): Syntax ==
      x := concat("#", convert(i)@String)::Symbol
      (x pretend Identifier)::Syntax

    instantiateNumberSlots(current: Syntax, t: Syntax): Syntax ==
      typeParameters := getOperands current
      #typeParameters > 0 =>
        for i in 1 .. #typeParameters repeat
          t := replace(makeNumberSlot(i), t, typeParameters.i)$SyntaxHelper
        t
      t

    instantiateTypeSyntax(current: Syntax, t: Syntax): Syntax ==
      -- a little bit different here: we don't instantiate %
      -- this makes later extract local function signatures easier
      t' := instantiateNumberSlots(current, t)
      t'

    instantiateTarget(current: Syntax, tar: Syntax): Syntax ==
      instantiateTypeSyntax(current, tar)

    instantiateSource(current: Syntax, src: List Syntax): List Syntax ==
      for i in 1..#src repeat
        src.i := instantiateTypeSyntax(current, src.i)
      src

    instantiateSignature(current: Syntax, s: Signature): Signature ==
      src := instantiateSource(current, copy source s)
      tar := instantiateTarget(current, target s)
      signature(src, tar)

    createRecord(fn: Identifier, x: List FunctionDescriptor, current: Syntax): List FREC ==
      result : List FREC := empty()
      for x' in x repeat
        s := signature x'
        a := #(source s)
        s' := instantiateSignature(current, s)
        t : FREC := [fn, s', a]
        result := concat(result, t)
      result

    instantiateFunctionDescriptor(current: Syntax, opList: List OverloadSet): List FREC ==
      database: List FREC := empty()
      for f in opList repeat
        newRecord := createRecord(name f, members f, current)
        database := concat(database, newRecord)
      database
----------------------------------------------------

    getExportedSignatures(): List OverloadSet ==
      --print(constructorName::OutputForm)
      ctor := retract(findConstructor(constructorName)$Constructor)$(Maybe Constructor)
      copy operations ctor

    updateGlobalConstructorInformation(sast: SpadAst, ctorName: Identifier, ctorPar: List Identifier, ctorTps: List Syntax): Boolean ==
      constructorName           := ctorName
      for p in ctorPar repeat
        constructorParameters   := concat(constructorParameters, p::Syntax)
      constructorParameterTypes := ctorTps      
      replacedConstructorDef := instantiatePercentage(sast)
      localExportedSignatureDatabase := instantiateFunctionDescriptor(constructorCallForm(), getExportedSignatures())
      initGlobalVariableEnvironment(ctorName, ctorPar, ctorTps)
      true

    getConstructorKind(c: Identifier): ConstructorKind == 
      kind(retract(findConstructor(c)$Constructor)$(Maybe Constructor))$Constructor

    countDomPacCat(c: Identifier): Void ==
      k : ConstructorKind := getConstructorKind(c)
      k = category$ConstructorKind =>  categorySet := union(categorySet, {c}) 
      k = package$ConstructorKind  =>  packageSet := union(packageSet, {c}) 
      domainSet := union(domainSet, {c})

    analyzeOneFile l == 
      cleanUpConstructorInformation()
      -- clean the ctor global variable table
      s := importFilter(l)
      sast := s::SpadAst
      -- if this is a package AST
      sast case WhereAst => 
        mainexp := mainExpression(s::WhereAst)$WhereAst::Syntax::DefinitionAst
        ctorName : Identifier := name(head(mainexp)$DefinitionAst)$HeadAst
        ctorPar  := parameters(head(mainexp)$DefinitionAst)$HeadAst
        ctorSig  := signature(mainexp)$DefinitionAst
        ctorTps  := source(ctorSig)
        countDomPacCat(ctorName)
        updateGlobalConstructorInformation(sast, ctorName, ctorPar, ctorTps)
        collectPackage(s, ctorName)
      -- if this is a domain or category
      sast case DefinitionAst => 
        ctorName : Identifier := name(head(sast::Syntax::DefinitionAst)$DefinitionAst)$HeadAst
        ctorPar  := parameters(head(sast::Syntax::DefinitionAst)$DefinitionAst)$HeadAst
        ctorSig  := signature(sast::Syntax::DefinitionAst)$DefinitionAst
        ctorTps  := source(ctorSig)         
        countDomPacCat(ctorName)
        updateGlobalConstructorInformation(sast, ctorName, ctorPar, ctorTps)
        sig := signature(sast::Syntax::DefinitionAst)$DefinitionAst
        tar := target(sig)$Signature
        if tar = buildSyntax('Category,[]) then
          collectCategory(s, ctorName)
        else
          collectDomain(s, ctorName)
        count
      count

--------------------------------------------------
    getAllFileName: List FileName ==
      sex := DIRECTORY("/users/yli/software/OA-latest/oa/bin/PARALLEL/example/*.spad")$Lisp
      sexLst := sex pretend List(FileName)
      sexLst

    sexpressionToString(s: FileName): String ==
      res := s::String

    analyzeAllFiles: Integer ==
      cleanUp()
      sexls :List FileName := getAllFileName() 
      for s in sexls repeat
        fname := sexpressionToString(s)
        nm: List Syntax := parse(fname)
        analyzeOneFile(nm)
        fCount := fCount + 1
      fCount

    signatureToString(s: Signature): String ==
      result : String := ""
      src := source s
      tar := target s
      result := concat([result, "("]) 
      for i in 1..#src repeat
        str := toString(src.i)$SyntaxHelper
        if i < #src then
          result := concat([result, str, ", "])
        else
          result := concat([result, str])
      result := concat([result, ") -> ", toString(tar)$SyntaxHelper])
      result

    tenvToString(tb: VTB): String ==
      result : String := ""
      for i in 1..#(ks := keys tb) repeat
        k := toString(ks.i)$SyntaxHelper
        t := toString(tb.(ks.i))$SyntaxHelper
        if i < #ks then
          result := concat([result, "      ", k, ": ", t, "\n\r"])
        else
          result := concat([result, "      ", k, ": ", t])
      result

    signaturelistToString(sl: List XREC): String ==
      result : String := ""
      totalcounter := totalcounter + 1
      if empty? sl then
        bugcounter := bugcounter + 1
        result := concat([result, "    [Function signature is not available]"])

      for i in 1..#sl repeat
        f := string(((sl.i).funname)::Symbol)
        s := signatureToString((sl.i).signature)
        if i < #sl then
          empty?(sl.i.tenv) => result := concat([result, "    ", f, ": ", s, "\n\r\n\r"])
          stringOfTenv := tenvToString(sl.i.tenv)
          result := concat([result, "    ", f, ": ", s, " where ", "\n\r", stringOfTenv, "\n\r\n\r"]) 
        else
          empty?(sl.i.tenv) => result := concat([result, "    ", f, ": ", s])
          stringOfTenv := tenvToString(sl.i.tenv)
          result := concat([result, "    ", f, ": ", s, " where ", "\n\r", stringOfTenv])
      result

    accumulationToString(al: List YREC): String ==
      result : String := ""
      for i in 1..#al repeat
        loopStr   := toString(((al.i).loopcandidate)::Syntax)$SyntaxHelper
        funsigStr := signaturelistToString((al.i).signaturelist)
        if i < #al then
          result := concat([result, "  Loop Body==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r", "  Operators being Reduced==>",_
                             "\n\r\n\r", funsigStr, ",", "\n\r\n\r"])
        else
          result := concat([result, "  Loop Body==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r", "  Operators being Reduced==>",_
                     "\n\r\n\r", funsigStr, "\n\r\n\r", "------------------------", "\n\r"])
      result

    aclToString(al: List RepeatAst): String ==
      result : String := ""
      aclandnlcounter := aclandnlcounter + #al
      for i in 1..#al repeat
        aclLoopDepths := concat(aclLoopDepths, getLoopDepth(al.i)$LoopAnalysis)
        loopStr   := toString((al.i)::Syntax)$SyntaxHelper
        if i < #al then
          result := concat([result, "  ACL Nests ==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r"])
        else
          result := concat([result, "  ACL Nests==>\n\r\n\r", "    ", loopStr, ",", "\n\r\n\r", "------------------------", "\n\r"])
      result

    reductionToString(al: List REDU): String == 
      reductionFunctionCounter := reductionFunctionCounter + #al
      result : String := ""
      for i in 1..#al repeat
        expStr   := toString((al.i.reduceexp)::Syntax)$SyntaxHelper
        -- we don't differentiate annotated and unannotated.
        -- therefore, the final result may contain $
        binOp    := toString(al.i.reduceop)$SyntaxHelper
        sigStr   := signatureToString(al.i.signature)
        if i < #al then
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce function application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                               "\n\r\n\r", "    ", binOp, ": ", sigStr, ",", "\n\r\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce function application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                              "\n\r\n\r", "    ", binOp, ": ", sigStr, " where ", "\n\r", stringOfTenv, "\n\r\n\r"])
        else
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce functino application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                       "\n\r\n\r", "    ", binOp, ": ", sigStr, "\n\r\n\r", "------------------------", "\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce functino application==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                        "\n\r\n\r", "    ", binOp, ": ", sigStr, " where ", "\n\r", stringOfTenv, "\n\r\n\r", "------------------------", "\n\r"])

      result

    -- no longer used
    reductionFormsToString(al: List Syntax): String == 
      reductionFormCounter := reductionFormCounter + #al
      result : String := ""
      for i in 1..#al repeat
        expStr   := toString(al.i)$SyntaxHelper
        if i < #al then
          result := concat([result, "    ", expStr, ",", "\n\r\n\r"])
        else
          result := concat([result, "    ", expStr, ",", "\n\r\n\r", "------------------------", "\n\r"])
      result

    reductionFormsToString2(al: List REDF): String == 
      reductionFormCounter := reductionFormCounter + #al
      result : String := ""
      for i in 1..#al repeat
        expStr   := toString(al.i.reduceform)$SyntaxHelper
        binOP    := string((al.i.reduceop)::Symbol)
        opSig    := signatureToString((al.i).signature)
        if i < #al then
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                               "\n\r\n\r", "    ", binOP, ": ", opSig, ",", "\n\r\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                             "\n\r\n\r", "    ", binOP, ": ", opSig, " where ", "\n\r", stringOfTenv, ",", "\n\r\n\r"])          


        else
          empty?(al.i.tenv) =>
            result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                       "\n\r\n\r", "    ", binOP, ": ", opSig, "\n\r\n\r", "------------------------", "\n\r"])
          stringOfTenv := tenvToString(al.i.tenv)
          result := concat([result, "  Reduce Form==>\n\r\n\r", "    ", expStr, ",", "\n\r\n\r", "  Operator being Reduced==>",_
                      "\n\r\n\r", "    ", binOP, ": ", opSig, " where ", "\n\r", stringOfTenv, "\n\r\n\r", "------------------------", "\n\r"])


      result

    getConstructorKindInString(c: Identifier): String ==
      k : ConstructorKind := getConstructorKind(c)
      k = category$ConstructorKind =>  "Category"
      k = package$ConstructorKind  =>  "Package"
      "Domain"

    toString(rl: List ZREC): String ==
      result : String := ""
      for r in rl repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := accumulationToString(r.accumulations)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    toString2(rl: List RREC): String ==
      result : String := ""
      for r in rl | not empty?(r.reductions) repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := reductionToString(r.reductions)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    toString3(rl: List RFREC): String ==
      result : String := ""
      for r in rl | not empty?(r.reduceforms) repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := reductionFormsToString(r.reduceforms)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r", "Reduce Forms==>\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    toString4(rl: List RFORM): String ==
      result : String := ""
      for r in rl | not empty?(r.reduceforms) repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := reductionFormsToString2(r.reduceforms)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_ 
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result


    toString5(rl: List AREC): String ==
      result : String := ""
      for r in rl repeat
        c := string((r.ctorname)::Symbol)
        f := string((r.funname)::Symbol)
        s := signatureToString(r.signature)
        a := aclToString(r.affineloops)
        k : String := getConstructorKindInString(r.ctorname)
        result := concat(result, concat([k, ": ", c, "\n\r",_
                                         "Function: ", f,": ", s, "\n\r\n\r",_
                                              a, "\n\r"]))

      result := concat(["\begin{program}\n\r", result, "\end{program}\n\r"])
      result

    writeARecordToFile(al: List AREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString5 al)
      true

    writeZRecordToFile(rl: List ZREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString rl)
      true

    writeRRecordToFile(rl: List RREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString2 rl)
      true

    writeRFRecordToFile(rl: List RFREC, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString3 rl)
      true

    writeRFORMToFile(rl: List RFORM, f: String): Boolean ==
      ofname : FileName := filename(".", f, "tex")
      ofile := open(ofname, "output")$File(String)
      write!(ofile, toString4 rl)
      true

    analyzeReduction(fileStr, option) == 
      bugcounter := 0
      reductionCounter := 0
      programOption := option
      analyzeAllFiles()
      if programOption = 0 then
        writeZRecordToFile(analysisResultList, fileStr)
        print(bugcounter::OutputForm)
        print(totalcounter::OutputForm)
      if programOption = 1 then
        print(reductionCounter::OutputForm)
      true



    -- checks whether a variable is a type variable 
    -- by looking up in the global type environment
    isTypeVariable?(tp: Syntax, env: VTB): Boolean == not compound? tp and tp case Identifier and key?(tp, env)

    -- checks whether some category/domain is parameterized by some type variable
    containTypeVariable?(cat: Syntax, env: VTB): Boolean ==
      not compound? cat => isTypeVariable?(cat, env)
      for opr in getOperands cat repeat
        containTypeVariable?(opr, env) => return true
      false 

    -- returns mapping between the parameters of a category constructor
    -- and the actual parameters in the corresponding constructed category
    findMapping(l: List Identifier, rs: Syntax): VTB ==
      res: Table(Syntax, Syntax) := empty()
      for e in l for e' in getOperands(rs) repeat
        x := e::Syntax
        res.x := e'
      res

    -- replaces the appearances of all the keys of variable mapping in s with 
    -- the corresponding contents indexed by those keys    
    instantiateSyntax(s: Syntax, mapping: VTB): Syntax ==
      for k in keys mapping repeat
        s := replace(k, s, mapping.k)$SyntaxHelper
      s

    -- replaces % in as signature with the domain that implements the owner category
    -- of the signature
    instantiatePercentages(current: Syntax, t: Syntax): Syntax ==
      replace(makePercentage(), t, current)$SyntaxHelper

    -- instantiates predicate list associated to category extension/signature/attribute
    -- using the parameter mapping information in variable mapping
    instantiatePredicate(pl: List Syntax, mapping: VTB): List Syntax ==
      [instantiateSyntax(p, mapping) for p in pl]

    -- instantiates a single category extension
    -- meaning that to replace each parameter used in category definition
    -- with the actual parameter of category
    -- such mapping of replacement is stored in variable mapping
    instantiateExtension(e: Syntax, mapping: VTB): Syntax ==
      instantiateSyntax(e, mapping)

    -- called by the instantiation function below.
    instantiatePair(p: EXTP, mapping: VTB): EXTP ==
      pair(instantiateExtension(first p, mapping), instantiatePredicate(second p, mapping))

    -- instantiate both of the predicate and category extension 
    -- from a category extension list of a category constructor
    instantiateExtensionList(l: LEXTP, mapping: VTB): LEXTP ==
      l' := copy l
      [instantiatePair(e, mapping) for e in l']

    -- by instantiate attribute list, we mean only to instantiate predicate of each attribute.
    -- attribute itself is no more than an identifier, and does not need to be instantiated.
    instantiateAttributeList(l: LAP, mapping: VTB): LAP ==
      l' := copy l
      [pair(first e, instantiatePredicate(second e, mapping)) for e in l']

--------
    rightTypeHasLeftAttribute?: (Syntax, Syntax, VTB) -> Boolean
    rightTypeHasLeftSignature?: (Syntax, Syntax, VTB) -> Boolean
    rightCategoryHasLeftCategory?: (Syntax, VTB, Syntax, VTB) -> Boolean
    typeChecks?: (Syntax, VTB, Syntax, VTB) -> Boolean
--------

    -- checks whether two type constructors have the same name
    sameName?(leftType: Syntax, rightType: Syntax): Boolean ==
      (not compound?(leftType)) or (not compound?(rightType)) => false
      getOperator(rightType)::Identifier = getOperator(leftType)::Identifier 

    -- This function evaluates one predicate of a predicate list
    -- again each predicate is a term of a disjunctive normal form represented by the predicate list
    evaluatePredicate(pred: Syntax, rightEnv: VTB): Boolean ==
      -- there are two main kinds of predicates:
      -- 1. trivial: true
      -- 2. has statement whose right hand side is:
      --   2.1 attribute
      --   2.2 signature of some operator
      --   2.3 category
      pred = makeTrue() => true
      (pred' := pred::SpadAst) case HasAst =>
        r := rhs pred'
        r' := r::Syntax
        l := lhs pred'
        l' := l::Syntax
        r case AttributeAst             => rightTypeHasLeftAttribute?(name(r::AttributeAst)::Syntax, l', rightEnv)   
        r case SignatureAst             => rightTypeHasLeftSignature?(r', l', rightEnv)
        isCategory?(r')$CheckAssumption => typeChecks?(r', rightEnv, l', rightEnv)
        userError "unexpected kind of right hand side in this has predicate"
      false

    -- This function statically evaluates predicate list except the trivial [true]
    evaluateNontrivialPredicates(preds: List Syntax, rightEnv: VTB): Boolean ==
      -- evaluate each predicate in the predicate list
      -- since the predicates are orgnized in disjunctive normal form
      -- we use laziness here, i.e. some predicate evaluates to false, we directly return false
      for pred in preds repeat
        not evaluatePredicate(pred, rightEnv) => return false
      true

    -- trivial predicate list is [true]
    trivialPredicate?(preds: List Syntax): Boolean ==
      (#preds = 1) and (first(preds)::Identifier = makeTrue()::Identifier)

    -- this function does static predicate evaluation
    -- each category extension, functino declaration, or attribute in a category constructor data
    -- is associated with a predicate list whose elements represent all componenets of a disjunctive normal form
    matchPredicate(preds: List Syntax, rightEnv: VTB): Boolean ==
      -- case 1: trivial predicate [true]
      trivialPredicate? preds => true
      -- case 2: nontrivial predicates in the list
      -- the function returns true when all predicates in the list evaluate to true
      evaluateNontrivialPredicates(preds, rightEnv)

    -- this function will be called when predicate list of some category extension evaluates to true
    -- it checks whether that category extension is leftType
    matchExtension(ext: Syntax, rightEnv: VTB, leftType: Syntax, leftEnv: VTB): Boolean ==
      not sameName?(leftType, ext)                => false
      not containTypeVariable?(leftType, leftEnv) => true
      for l in getOperands(leftType) for r in getOperands(ext) repeat
        not typeChecks?(l, leftEnv, r, rightEnv)  => return false
      true

    -- This function checks whether category leftType is extList
    -- 1. we first statically evaluate the predicate of some category extension
    -- 2. if 1 returns true, we further compare whether the category under the predicate equals leftType
    searchExtensionList(leftType: Syntax, leftEnv: VTB, extList: LEXTP, rightEnv: VTB): Boolean ==
      -- look at each category extension in the extension list
      -- searching for category stored in leftType
      for ext in extList repeat
        matchPredicate(second ext, rightEnv) and matchExtension(first ext, rightEnv, leftType, leftEnv) =>
          return true
      false
   
    -- this function searches whether there is an attribute which equals attr
    -- in the attribute list attl.
    searchAttributeList(attr: Syntax, attl: LAP, rightEnv: VTB): Boolean ==
      for att in attl repeat
        matchPredicate(second att, rightEnv) and (first att = attr)=> return true
      false

    -- returns the constructor of a domain/category.
    getConstructor(t: Syntax): Constructor ==
      c := getOperator(t)::Identifier
      retract(findConstructor(c)$Constructor)$(Maybe Constructor)

    -- returns all the attributes owned by some domain.
    -- this is implemented under the help of the FunctorData domain functions.
    attributesOfDomain(dom: Syntax): List Syntax ==
      domctor := getConstructor(dom)
      domCtor: DomainConstructor := toDomainConstructor(domctor)$SyntaxHelper
      ftorData : FunctorData := functorData(domCtor)
      domAtts : List Pair(Syntax,NonNegativeInteger) := attributeData ftorData
      [first e for e in domAtts]     

    -- checks whether a domain rightType has attribute att
    rightDomainHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      attrl := attributesOfDomain(rightType)
      member?(att, attrl)

    -- recursively look into each category in a category extension list extl
    -- to examine whether there is one category has attribute att
    recursiveSearchAttributeList(att: Syntax, extl: LEXTP, rightEnv: VTB): Boolean ==
      for ext in extl repeat
        -- again we first examine the predicate, then recursively look at each qualified category
        matchPredicate(second ext, rightEnv) and rightTypeHasLeftAttribute?(att, first ext, rightEnv) => 
          return true
      false

    -- checks whether category rightType has attribute att
    rightCategoryHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isNil?(rightType)$SyntaxHelper => false
      rightTypeName : Identifier := getOperator(rightType)::Identifier
      r := getCategoryConstructorData(rightTypeName)$CategoryExtensionCollection
      m := findMapping(r.catpars, rightType)
      attrl := instantiateAttributeList(r.attributes, m)
      extl  := instantiateExtensionList(r.extensions, m)
      searchAttributeList(att, attrl, rightEnv) => true
      recursiveSearchAttributeList(att, extl, rightEnv)
      false

    -- checks whether there is a category in a join syntax has attribute att
    -- or there is an attribute in the join syntax that equals att
    rightJoinCategoriesHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- look at each element in the join ast
      for c in getOperands rightType repeat
        -- if the element is an attribute, then directly compare their name
        (c' := c::SpadAst) case AttributeAst => 
          (name(c')::Syntax) = att => return true
          false
        -- otherwise, the element is a category, we recursively examine whether the
        -- category has the attribute
        rightTypeHasLeftAttribute?(att, c, rightEnv) => return true
      false

    -- evaluates one has-predicate whose right hand side is an attribute
    -- and left hand side is a domain/category/type variable/join of categories and attributes
    rightTypeHasLeftAttribute?(att: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isDomain?(rightType)$CheckAssumption   => rightDomainHasLeftAttribute?(att, rightType, rightEnv)
      isCategory?(rightType)$CheckAssumption => rightCategoryHasLeftAttribute?(att, rightType, rightEnv)
      isTypeVariable?(rightType, rightEnv)   => rightTypeHasLeftAttribute?(att, rightEnv.rightType, rightEnv)
      isJoin?(rightType)$SyntaxHelper        => rightJoinCategoriesHasLeftAttribute?(att, rightType, rightEnv)
      userError "unexpected cases in rightTypeHasLeftAttribute?"

    instantiateSourceOfSignature(src: List Syntax, mapping: VTB, domVar: Syntax): List Syntax ==
      res : List Syntax := []
      for s in src repeat
        s' := instantiateSyntax(s, mapping)
        s' := instantiatePercentages(domVar, s')
        res := concat(res, s')
      res

    instantiateTargetOfSignature(tar: Syntax, mapping: VTB, domVar: Syntax): Syntax ==
      s' := instantiateSyntax(tar, mapping)
      s' := instantiatePercentages(domVar, s')
      s'
     
    -- This function instantiates the signature syntax of some function
    -- declaration from some category constructor data
    -- 1. replace % with the current domain domVar
    -- 2. replace each parameter used in the category definition 
    -- with the actual category constructor parameter
    instantiateSignatureSyntax(sig: Syntax, mapping: VTB, domVar: Syntax): Syntax ==
      -- bug in signature function on handling 0 and 1
      compound?(first(getOperands(sig))) => sig
      sig' := signature(sig::SpadAst::SignatureAst)
      fid := name(sig::SpadAst::SignatureAst)
      src := copy source sig'
      tar := target sig'
      src' := instantiateSourceOfSignature(src, mapping, domVar)
      tar' := instantiateTargetOfSignature(tar, mapping, domVar)
      newsig := signature(src', tar')$Signature
      newsigast := signatureAst(fid, newsig)$SignatureAst
      newsigast::Syntax

    -- This function instantaites
    --	1. the predicate list associated to a signature
    --  2. the signature itself
    instantiateSignaturePair(p: EXTP, mapping: VTB, domVar: Syntax): EXTP ==
      pair(instantiateSignatureSyntax(first p, mapping, domVar), instantiatePredicate(second p, mapping))

    -- instantiate each signature in a signature list of some category
    instantiateSignatureList(l: LSP, mapping: VTB, domVar: Syntax): LSP ==
      l' := copy l
      [instantiateSignaturePair(e, mapping, domVar) for e in l']

    -- checks whether the two signatures are equivalent
    sameSignature?(l: Syntax, r: Syntax): Boolean ==
      -- the following condition skips the function declaration for 0 and 1, 
      -- it's a workround for the nasty bug on generating signature syntax for 0 and 1
      compound?(first(getOperands(l))) or compound?(first(getOperands(r))) => false
      l' := l::SpadAst::SignatureAst
      r' := r::SpadAst::SignatureAst
      name(l') = name(r') and (signature l') = (signature r')
    
    searchSignatureList(sig: Syntax, sigList: LSP, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- look at each category extension in the extension list
      -- searching for category stored in leftType
      for s in sigList repeat
        matchPredicate(second s, rightEnv) and sameSignature?(first s, sig) => 
          return true
      false

    rightDomainHasLeftSignature?: (Syntax, Syntax, Syntax, VTB) -> Boolean

    rightDomainVariableHasLeftSignature?: (Syntax, Syntax, Syntax, VTB) -> Boolean

    -- recursively look into each category, looking for the function declaration decl
    recursiveSearchSignatureList(decl: Syntax, extl: LEXTP, rightType: Syntax, rightEnv: VTB): Boolean ==
      for ext in extl repeat
        matchPredicate(second ext, rightEnv) and_
        rightDomainHasLeftSignature?(decl, first ext, rightType, rightEnv) => 
          return true
      false

    -- this function instantaite a single category cat with domain sig (whose type is cat), then looks for
    -- declaration decl in the instantiated declaration list from the operation list of the category constructor
    rightDomainHasLeftSignature?(decl: Syntax, cat: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      catName := getOperator(cat)::Identifier
      rec := getCategoryConstructorData(catName)$CategoryExtensionCollection
      m := findMapping(rec.catpars, cat)
      extl := instantiateExtensionList(rec.extensions, m)
      decll := instantiateSignatureList(rec.declarations, m, rightType)
      searchSignatureList(decl, decll, rightType, rightEnv) => true
      recursiveSearchSignatureList(decl, extl, rightType, rightEnv)

    -- this function is invoked when the type of domain rightType is a join of categories and attributes
    -- it instantiates each category in the join syntax with the domain, and checks about the membership of the
    -- function declaration 
    rightJoinCategoriesHasLeftSignature?(decl: Syntax, cat: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      for c in getOperands cat | not((c::SpadAst) case AttributeAst) repeat
        rightDomainVariableHasLeftSignature?(decl, c, rightType, rightEnv) => return true
      false

    -- this function checks whether some domain(variable) rightType implementing category cat 
    -- has some function declaration decl
    rightDomainVariableHasLeftSignature?(decl: Syntax, cat: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isJoin?(cat)$SyntaxHelper     => rightJoinCategoriesHasLeftSignature?(decl, cat, rightType, rightEnv)
      isCategory?(cat)$SyntaxHelper => rightDomainHasLeftSignature?(decl, cat, rightType, rightEnv)
      false

    -- this function checks whether the type rightType has function declaration decl
    rightTypeHasLeftSignature?(decl: Syntax, rightType: Syntax, rightEnv: VTB): Boolean ==
      isTypeVariable?(rightType, rightEnv) => rightDomainVariableHasLeftSignature?(decl, rightEnv.rightType, rightType, rightEnv)
      userError "unexpected cases in rightTypeHasLeftSignature?"

    -- recursively goes into each qualified category extension to see whether any one of them has category leftType
    -- by qualified we mean the predicate list associated to the category extension evaluates to true
    recursiveSearchExtensionList(leftType: Syntax, leftEnv: VTB, extl: LEXTP, rightEnv: VTB): Boolean ==
      for ext in extl repeat
        matchPredicate(second ext, rightEnv) and_ 
        rightCategoryHasLeftCategory?(leftType, leftEnv, first ext, rightEnv) => return true
      false

    -- this function checks whether there's one category in the join syntax has	category leftType
    rightJoinCategoriesHasLeftCategory?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- obtain category extensions and attributes in a join ast
      catsAndAtts := getOperands rightType
      -- only search those category extensions in Join ast, skipping attributes
      for c in catsAndAtts | not((c::SpadAst) case AttributeAst) repeat
        rightCategoryHasLeftCategory?(leftType, leftEnv, c, rightEnv) => return true
      false

    -- this function finds out whether category rightType directly or indirectly extends category leftType
    foundInCategoryHierarchy?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      rightTypeName := getOperator(rightType)::Identifier
      -- obtain the category constructor data for rightType
      rec := getCategoryConstructorData(rightTypeName)$CategoryExtensionCollection
      m := findMapping(rec.catpars, rightType)
      -- does beta-conversion for the category extension list of rightType category
      extl := instantiateExtensionList(rec.extensions, m)
      -- search whether rightType directly extends leftType
      searchExtensionList(leftType, leftEnv, extl, rightEnv) => true
      -- if rightType doesn't directly extends, we further check whether it indirectly extends leftType
      -- by recursively looking into each category rightType directly extends.
      recursiveSearchExtensionList(leftType, leftEnv, extl, rightEnv)

    handleCategoryWithAttribute(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      rightType' := (rightType::SpadAst)::CategoryAst
      bd := body(rightType')
      bd' := [e::Syntax for e in bd]
      joinType := buildSyntax(makeJoin(), bd')
      rightCategoryHasLeftCategory?(leftType, leftEnv, joinType, rightEnv)

    -- this function checks whether the category rightType has category leftType
    -- e.g., this handles query such as PolynomialCategory(R, E, VarSet) has AbelianMonoid
    rightCategoryHasLeftCategory?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- case 1: the rightType is nil
      isNil?(rightType)$SyntaxHelper  => false
      -- case 2: the leftType is Type, we directly returns, this is an optimization
      isType?(leftType)$SyntaxHelper => true
      -- case 3: the two categories are equivalent
      rightType = leftType            => true
      -- case 4: rightType is a join syntax of categories and attributes
      isJoin?(rightType)$SyntaxHelper => rightJoinCategoriesHasLeftCategory?(leftType, leftEnv, rightType, rightEnv)
      -- case 5: rightType is a list of attribute wrapped as a CategoryAst
      -- for instance, this happens when we see the following sytnax: R: Ring with commutative("*") 
      (rightType::SpadAst) case CategoryAst => handleCategoryWithAttribute(leftType, leftEnv, rightType, rightEnv)
      -- case 6: rightType is a normal category
      foundInCategoryHierarchy?(leftType, leftEnv, rightType, rightEnv)

    -- convert formats between PrimitiveArray ConstructorCall and List Syntax
    convert(a: PrimitiveArray ConstructorCall): List Syntax ==
      [buildSyntax(name(constructor(a.i)), arguments(a.i)) for i in 0..(#a-1)]

    -- helper function for replacing the local slots
    replaceLocal(s: Syntax, oprs: List Syntax): Syntax ==
      empty? oprs => s
      s' := s
      for i in 1..#oprs repeat
        s' := replace(makeLocalNumberSlot(i)$SyntaxHelper, s', oprs.i)$SyntaxHelper
      s'
 
    -- Record domain constructor is not supported via functorData
    -- we manually generate functor data for it
    -- this function will be improved once necessary
    generateCategoryExtensionForRecord(): List Syntax ==
      [buildSyntax(makeSetCategory()$SyntaxHelper, [])]    

    -- this function takes in a domain dom, and returns a list of categories
    -- implemented by the domain
    getInstantiatedCategoryExtensionList(dom: Syntax): List Syntax ==
      isRecord?(dom)$SyntaxHelper => generateCategoryExtensionForRecord()
      ctor := getConstructor(dom)
      domCtor: DomainConstructor := toDomainConstructor(ctor)$SyntaxHelper
      ftorData : FunctorData := functorData(domCtor)
      domTemp : DomainTemplate := domainTemplate(ftorData)
      domCats : List Syntax := convert(categories(ftorData)$FunctorData)
      -- replace number slots in category extensions using elements in domain template
      l := [replace(c, domTemp)$SyntaxHelper for c in domCats]
      pars := getOperands(dom)
      -- further replace local# slots with the actual parameters of constructor dom
      [replaceLocal(e, pars) for e in l]

    -- this function checks domain rightType has category leftType
    -- e.g., this handles query such as Polynomial(R) has AbelianMonoid
    rightDomainHasLeftCategory?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      isType?(leftType)$SyntaxHelper => true  -- an optimization for saving query time
      categoryExtensionList := getInstantiatedCategoryExtensionList(rightType)
      member?(leftType, categoryExtensionList)

    -- this function typechecks each domain parameter against domain parameter type in the assumption 
    typeCheckDomainParameters(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      leftPars := getOperands(leftType)
      rightPars := getOperands(rightType)
      for leftPar in leftPars for rightPar in rightPars repeat
        not typeChecks?(leftPar, leftEnv, rightPar, rightEnv) => return false
      true

    -- this function checks whether an input/output domain of a reduction operator
    -- matches an input/output domain in the assumption operator
    domainVsDomain(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      not sameName?(leftType, rightType) => false
      typeCheckDomainParameters(leftType, leftEnv, rightType, rightEnv)

    -- this function checks whether the signature of a reduction operator satisfies 
    -- the type requirement specified in a user assumption
    -- here leftType is the input/output type of the binary operator from assumption
    -- rightType is the input/output type of the binary operator from extracted reduction
    typeChecks?(leftType: Syntax, leftEnv: VTB, rightType: Syntax, rightEnv: VTB): Boolean ==
      -- case 1: basic assumption vs a specific reduction operator, 
      -- i.e., input and output types are domains
      isDomain?(leftType)$CheckAssumption and isDomain?(rightType)$CheckAssumption =>
        domainVsDomain(leftType, leftEnv, rightType, rightEnv)

      -- case 2: generic assumption vs a specific reduction operator
      isTypeVariable?(leftType, leftEnv) and isDomain?(rightType)$CheckAssumption => 
        rightDomainHasLeftCategory?(leftEnv.leftType, leftEnv, rightType, rightEnv)

      -- case 3: generic assumption vs a generic reduction operator
      isTypeVariable?(leftType, leftEnv) and isTypeVariable?(rightType, rightEnv) =>
        rightCategoryHasLeftCategory?(leftEnv.leftType, leftEnv, rightEnv.rightType, rightEnv)
      false

    typeMatch?(op: TCR, rec: TCR): Boolean ==
      signatureFromAssumption := op.signature
      signatureFromReduction     := rec.signature
      for left in concat(source signatureFromAssumption, target signatureFromAssumption)_
      for right in concat(source signatureFromReduction, target signatureFromReduction) repeat
        not typeChecks?(left, op.tenv, right, rec.tenv) => return false
      true

    isInList?(rec: TCR, assocops: List TCR): Boolean ==
      for r in assocops repeat
        rec.funname = r.funname =>
          empty?(r.tenv) =>
            rec.signature = r.signature  => return true
          typeMatch?(r, rec) => return true
      false

    matchesOne?(rec: TCR, assocops: List TCR): Boolean ==
      empty?(rec.tenv) =>  isInList?(rec, assocops)  -- member? is buggy when there is a table in side a record
      for op in assocops repeat
        rec.funname = op.funname and typeMatch?(op, rec) => return true
      false

  --macro XREC   == Record(funname: Identifier, signature: Signature, usedin: Syntax, tenv: VTB)
  --macro YREC   == Record(loopcandidate: RepeatAst, signaturelist: List XREC)
  --macro ZREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, accumulations: List YREC)

    formatConverterTCR(rs: List OPREC): List TCR ==
      result : List TCR := []
      for r in rs repeat
        rec : TCR := [r.funname, r.signature, r.tenv]
        result := concat(result, rec)
      result

    isFullyParallelizable?(l: YREC, assocops: List OPREC): Boolean ==
      empty?(l.signaturelist) => false
      assocops' := formatConverterTCR assocops
      for f in l.signaturelist repeat
        rec : TCR := [f.funname, f.signature, f.tenv]
        not matchesOne?(rec, assocops') => return false
      true

    isPartiallyParallelizable?(l: YREC, assocops: List OPREC): Boolean ==
      empty?(l.signaturelist) => false
      assocops' := formatConverterTCR assocops
      for f in l.signaturelist repeat
        rec : TCR := [f.funname, f.signature, f.tenv]
        matchesOne?(rec, assocops') => return true
      false

    extractParallelizableReductionLoop(assocops: List OPREC, recs: List ZREC): Pair(List ZREC, List ZREC)==
      full :   List ZREC := []
      partial: List ZREC := []
      for rec in recs repeat
        recf : ZREC := [rec.ctorname, rec.funname, rec.signature, []]
        recp : ZREC := [rec.ctorname, rec.funname, rec.signature, []]
        lps := rec.accumulations
        for l in lps repeat
          isFullyParallelizable?(l, assocops)     => 
            ptotalcounter := ptotalcounter + 1
            recf.accumulations := concat(recf.accumulations, l)
          isPartiallyParallelizable?(l, assocops) => 
            pptotalcounter := pptotalcounter + 1
            recp.accumulations := concat(recp.accumulations, l)
        if not empty?(recf.accumulations) then
          full := concat(full, recf)
        if not empty?(recp.accumulations) then
          partial := concat(partial, recp)
      pair(full, partial)

  --macro REDU   == Record(reduceexp: Syntax, reduceop: Syntax, signature: Signature)
  --macro RREC   == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reductions: List REDU)

    getOperatorName(op: Syntax): Identifier ==
      compound? op =>
        opr := getOperator op 
        opr case Identifier and opr::Identifier = 'elt::Identifier => 
          (second getOperands op)::Identifier
        opr case Identifier and opr::Identifier = '_@::Identifier => 
          getOperatorName(first getOperands op)
        opr case Identifier and member?(char "#", entries(toString(op)$SyntaxHelper)) =>
          opr::Identifier
        print(op::Syntax::OutputForm)
        userError "unexpected operator syntax"
      op case String => (op::String::Symbol) pretend Identifier
      op::Identifier

    extractParallelizableReduceCall(assocops: List OPREC, recs: List RREC): List RREC ==
      result : List RREC := []
      assocops' := formatConverterTCR assocops
      for rec in recs repeat
        newrec : RREC := [rec.ctorname, rec.funname, rec.signature, []]
        for r in rec.reductions repeat
          rec : TCR := [getOperatorName(r.reduceop), r.signature, r.tenv]
          matchesOne?(rec, assocops') => 
            preductionFunctionCounter := preductionFunctionCounter + 1
            newrec.reductions := concat(newrec.reductions, r)
        not empty?(newrec.reductions) => result := concat(result, newrec)
      result

  --macro REDF   == Record(reduceform: Syntax, reduceop: Identifier, signature: Signature)
  --macro RFORM  == Record(ctorname: Identifier, funname: Identifier, signature: Signature, reduceforms: List REDF)

    extractParallelizableReduceForm(assocops: List OPREC, recs: List RFORM): List RFORM ==
      result : List RFORM := []
      assocops' := formatConverterTCR assocops
      for rec in recs repeat
        newrec : RFORM := [rec.ctorname, rec.funname, rec.signature, []]
        for r in rec.reduceforms repeat
          rec : TCR := [r.reduceop, r.signature, r.tenv]
          matchesOne?(rec, assocops') =>
            preductionFormCounter := preductionFormCounter + 1 
            newrec.reduceforms := concat(newrec.reduceforms, r) 
        not empty?(newrec.reduceforms) => result := concat(result, newrec)
      result

    printStatistics(option: Integer, collectAssociativeOperator?: Integer, associativeOperatorList: List OPREC): Void ==
      viewStatistics()
      if collectAssociativeOperator? = 0 then
        if (option = 2) or (option =3) then
          if (option = 2) then
            print("Affine control loop #:"::OutputForm)
          else
            print("Nested loop #:"::OutputForm)
          print(aclandnlcounter::OutputForm)
          print("Average loop depth:"::OutputForm)
          averageDepth : DoubleFloat := convert(reduce(_+$Integer, aclLoopDepths)/aclandnlcounter)$Fraction(Integer)        
          print(averageDepth::OutputForm)

      if collectAssociativeOperator? = 1 then 
        print("Associative Operators (by User):"::OutputForm)
        print(associativeOperatorList::OutputForm)
        if (option = 0) then
          print("Partial parallelizable loop #:"::OutputForm)
          print(pptotalcounter::OutputForm)
          print("Fully parallelizable loop #:"::OutputForm)
          print(ptotalcounter::OutputForm)    
        else --if (option = 1) then
          print("Parallelizable reduce function application#:"::OutputForm)
          print(preductionFunctionCounter::OutputForm)
          print("Parallelizable reduce form #:"::OutputForm)
          print(preductionFormCounter::OutputForm)
          
    -- parameter option:
    -- 0: extract reduction loops with functions used in the loop
    -- 1: extract reduce function and reduce forms.
    -- parameter collectAssociativeOperator?:
    -- 0: extract all the reduction whose operator is associative
    -- 1: opposite to 0
    analyze(option, collectAssociativeOperator?) == 
      --bugcounter := 0
      reductionCounter := 0
      programOption := option
      associativeOperatorList : List OPREC := []
      if collectAssociativeOperator? = 1 then
        -- building category extension database
        collectAllConstructorData()$CategoryExtensionCollection
        associativeOperatorList := collectAssociativeOperator()$CheckAssumption
      analyzeAllFiles()
      if programOption = 0 then
        writeZRecordToFile(analysisResultList, "reduce-loops")
        print("Results for reduction loops have been written into reduce-loops.txt"::OutputForm)
        if collectAssociativeOperator? = 1 then 
          r : Pair(List ZREC, List ZREC)  := extractParallelizableReductionLoop(associativeOperatorList, analysisResultList)
          parallelReductionLoops          := first r
          partiallyParallelReductionLoops := second r
          writeZRecordToFile(parallelReductionLoops, "parallel-reduce-loops")
          print("Results for fully parallelizable reduction loops have been written into parallel-reduce-loops.txt"::OutputForm)
          writeZRecordToFile(partiallyParallelReductionLoops, "partial-parallel-reduce-loops")
          print("Results for partial parallelizable reduction loops have been written into partial-parallel-reduce-loops.txt"::OutputForm)

      if programOption = 1 then
        writeRRecordToFile(reduceList, "reduce-functions")
        print("Results for reduce function applications have been written into reduce-functions.txt"::OutputForm)
        if collectAssociativeOperator? = 1 then 
          parallelReduceList := extractParallelizableReduceCall(associativeOperatorList, reduceList)
          writeRRecordToFile(parallelReduceList, "parallel-reduce-functions")
          print("Results for parallelizable reduce function applications have been written into parallel-reduce-functions.txt"::OutputForm)

        writeRFORMToFile(rformList, "reduce-forms")
        print("Results for reduction forms have been written into reduce-forms.txt"::OutputForm)
        if collectAssociativeOperator? = 1 then
          parallelReduceForms := extractParallelizableReduceForm(associativeOperatorList, rformList)
          writeRFORMToFile(parallelReduceForms, "parallel-reduce-forms")
          print("Results for parallelizable reduction forms have been written into reduce-forms.txt"::OutputForm)
      if programOption = 2 then
        writeARecordToFile(aclList, "acl-nests")
        print("ACL loop nests have been written into acl-nests.txt"::OutputForm)
      if programOption = 3 then
        writeARecordToFile(nlList, "loop-nests")
        print("All loop nests have been written into loop-nests.txt"::OutputForm)
      printStatistics(option, collectAssociativeOperator?, associativeOperatorList)
      true






