import SYNHELP
import ATRCOL

)abbrev package CEXCOL CategoryExtensionCollection
++ Author: Yue Li
++ Date Created: March 15, 2010
++ Date Last Updated: March 20, 2010
++ Description: 
++ This package provides library functions which traverse a category definition, and collect 
++ the category constructor data, storing them in a category constructor database.
CategoryExtensionCollection(): Public == Private where
  macro EXTP  == Pair(Syntax, List Syntax) -- (category extensios, predicate)
  macro LEXTP == List EXTP
  macro LAP   == LEXTP                     -- for attributes, i.e. conditional and unconditional
  macro LSP   == LEXTP                     -- for signatures, i.e. conditional and unconditional
  macro CEXTR == Record(catname: Identifier, catpars: List Identifier,_ 
                        partyps: List Syntax, declarations: LSP, extensions: LEXTP, attributes: LAP)
  macro CEXTDB == List CEXTR
  Public == with
    collectAllConstructorData: Integer
      ++ This function traverse all the spad file in some directory, 
      ++ if a spad file contains category definition, it further collects 
      ++ category constructor data, i.e., function declarations, attributes, category extensions, 
      ++ each element in each kind of data is associated with a predicate in disjunctive normal form
    getCategoryConstructorData: Identifier -> CEXTR
      ++ This function takes in a category name, and retrieves its category constructor data
    allConstructorData: CEXTDB
      ++ This function returns all the entries in the category contructor database
  Private == add
    makeUnknown: Syntax  == '_?::Identifier::Syntax
    makeTrue: Syntax     == 'true::Identifier::Syntax
    count : Integer := 0
    globalDatabase : CEXTDB := empty()
    dbrec: CEXTR := [makeUnknown(), [], [], [], [], []]
    constructorMacros: Table(Syntax, Syntax) := empty()
    allConstructorData == globalDatabase
    cleanUp(): Boolean ==
      count := 0
      true

    collectMacro(t: MacroAst): Boolean ==
      macroHead := head(t)$MacroAst
      macroBody := (body(t)$MacroAst)::Syntax
      macroName := (name(macroHead)$HeadAst)::Syntax
      constructorMacros.macroName := macroBody
      true

    macroExpansion2(s: Syntax): Syntax ==
      for m in keys constructorMacros repeat
        mac := constructorMacros.m
        sub := m
        s := replace(sub, s, mac)$SyntaxHelper
      s

    macroExpansion(s: Syntax): Syntax ==
      empty? constructorMacros => s
      s' := macroExpansion2(s)
      s' := macroExpansion2(s')
      s'

    getCtorKind(c: Identifier): ConstructorKind == 
      kind(retract(findConstructor(c)$Constructor)$(Maybe Constructor))$Constructor

    getCtorKindInString(c: Identifier): String ==
      k : ConstructorKind := getCtorKind(c)
      k = category$ConstructorKind =>  "Category"
      k = package$ConstructorKind  =>  "Package"
      "Domain"

    collectSingleCategoryExtension(s: Syntax): Integer ==
      dbrec.extensions := concat(dbrec.extensions, pair(macroExpansion(s), [makeTrue()]))
      count

    collectSingleCategoryExtensionWithPredicate(s: Syntax, pred: List Syntax): Integer ==
      dbrec.extensions := concat(dbrec.extensions, pair(macroExpansion(s), pred))
      count

    collectSignature(s: Syntax, pred: List Syntax): Integer ==
      dbrec.declarations := concat(dbrec.declarations, pair(macroExpansion(s), pred))
      count

    collectConditional: (Syntax, List Syntax) -> Integer

    collectAttribute(s: Syntax, pred: List Syntax): Integer ==
      op := getOperator(name(s::AttributeAst)::Syntax)
      att : Syntax := makeTrue()
      if op case Syntax then 
        att := op::Syntax
      if op case Identifier then 
        att := op::Identifier::Syntax
      member?(att, allAttributes()$AttributeCollection) =>
        dbrec.attributes := concat(dbrec.attributes, pair(att, pred))
        count
      dbrec.extensions := concat(dbrec.extensions, pair(macroExpansion(att), pred))
      count

    collectStatement(s: Syntax, pred: List Syntax): Integer ==
      s' := s::SpadAst
      isProgn?(s)$SyntaxHelper => 
        for e in getOperands(s) repeat
          collectStatement(e, pred)
        count
      s' case AttributeAst => collectAttribute(s, pred)
      s' case IfAst => collectConditional(s, pred)
      s' case SignatureAst => collectSignature(s, pred)
      print(s::OutputForm)
      userError "unexpected statement!"

    collectThenBranch(s: Syntax, pred: List Syntax): Integer ==
      collectStatement(s: Syntax, pred)

    collectElseBranch(s: Syntax, pred: List Syntax): Integer ==
      collectStatement(s: Syntax, pred)

    negateCondition(pred: Syntax): Syntax ==
      buildSyntax('not, [pred])

    collectConditional(s: Syntax, pred: List Syntax): Integer ==
      s' := s::SpadAst::IfAst
      cond := condition(s')::Syntax
      if hasThenBranch?(s')$SyntaxHelper then
        newpred : List Syntax := concat(pred, cond)
        collectThenBranch(thenBranch(s')::Syntax, newpred)
      if hasElseBranch?(s')$SyntaxHelper then
        newpred : List Syntax := concat(pred, negateCondition(cond))
        collectElseBranch(elseBranch(s')::Syntax, newpred)
      count

    collectEachInCAST(s: Syntax, pred: List Syntax): Integer ==
      s' := s::SpadAst
      s' case SignatureAst => collectSignature(s, pred)
      s' case IfAst        => collectConditional(s, pred)
      s' case AttributeAst => collectAttribute(s, pred)
      userError "unexpected syntax in CAST"

    collectCAST(s: Syntax): Integer ==
      for e in body(s::CategoryAst) repeat
        collectEachInCAST(e::Syntax, [makeTrue()])
      count

    collectJoin(s: Syntax): Integer ==
      not isJoin?(s)$SyntaxHelper => userError "not join ast!"
      exports : List TypeAst := categories(s::JoinAst)
      for e in exports repeat
        e' := e::Syntax::SpadAst
        e' case CategoryAst => collectCAST(e'::Syntax)
        collectSingleCategoryExtension(e'::Syntax)
      count

    collectAdd(s: Syntax): Integer ==
      not isAdd?(s)$SyntaxHelper => userError "not add ast!"
      j := base(s::AddAst)$AddAst::Syntax
      isJoin?(j)$SyntaxHelper => collectJoin(j)
      (j::SpadAst) case CategoryAst => collectCAST(j)    
      compound?(j) => collectSingleCategoryExtension(j)
      userError "unexpected syntax in add ast"

    -- collect exports of categories whose syntax contains macros such as Public == Private where..
    collectCategory2(s: Syntax, ctor: Identifier): Integer ==
      getCtorKindInString(ctor) ~= "Category" => count
      count := inc count
--      ctorPar' : List ParameterAst := parameters(head(mainExpression(s::WhereAst)$WhereAst::Syntax::DefinitionAst)$DefinitionAst)$HeadAst
--      ctorPar : List Identifier := [(e::Identifier) for e in ctorPar']
      ctorPar : List Identifier := parameters(head(mainExpression(s::WhereAst)$WhereAst::Syntax::DefinitionAst)$DefinitionAst)$HeadAst
      qual := qualifier(s::WhereAst)$WhereAst
      seq  := qual::Syntax::SequenceAst
      seqBody := body(seq)$SequenceAst
      b : List SpadAst
      for st in seqBody repeat
        if (st case MacroAst) then collectMacro(st::Syntax::MacroAst)
        if (st case ExitAst) then
          a := expression(st::Syntax::ExitAst)$ExitAst
          b := body(a::Syntax::CapsuleAst)$CapsuleAst
      for x in b repeat
        x' := x::Syntax
        id := getOperator(x')
        if (id case Identifier) then
          id' := id::Identifier
          if (id'::Symbol = 'add) then
            collectAdd(x')
            --collectJoin(base(x::Syntax::AddAst)$AddAst::Syntax)
          if (id'::Symbol = 'Join) then
            collectJoin(x')
      globalDatabase := concat(globalDatabase, dbrec)
      count

    -- collects loops from a typical category, i.e.,  Cats():Category == Cat with ... add..
    collectCategory(s: Syntax, ctor: Identifier): Integer == 
      getCtorKindInString(ctor) ~= "Category" => count
      cDef := (s::DefinitionAst)
      cBody := body(cDef)$DefinitionAst::Syntax
      isJoin?(cBody)$SyntaxHelper => 
        collectJoin(cBody)
        globalDatabase := concat(globalDatabase, dbrec)
        count
      isAdd?(cBody)$SyntaxHelper =>
        collectAdd(cBody)
        globalDatabase := concat(globalDatabase, dbrec)
        count
      (cBody::SpadAst) case CategoryAst => 
        collectCAST(cBody)
        globalDatabase := concat(globalDatabase, dbrec)
        count
      collectSingleCategoryExtension(cBody)
      globalDatabase := concat(globalDatabase, dbrec)
      count

    -- filter out the import statement before the category definition
    importFilter(l: List Syntax): Syntax ==
      for s in l repeat
        s' := s::SpadAst --case ImportAst => L_import := concat(L_import, s::ImportAst)
        s' case MacroAst => collectMacro(s::MacroAst)
        s' case DefinitionAst or s' case WhereAst => return s
      l.last

    fillCurrentDBRecSlot(x: Identifier, y: List Identifier, z: List Syntax): CEXTR == 
      dbrec := [x, y, z, [], [], []]

    lookatEach(l: List Syntax): Integer ==
      constructorMacros := empty()
      s := importFilter(l)
      sast := s::SpadAst
      -- the following category handles the one kind of category definition syntax
      sast case WhereAst => 
        mainexp := mainExpression(s::WhereAst)$WhereAst::Syntax::DefinitionAst
        ctorName : Identifier := name(head(mainexp)$DefinitionAst)$HeadAst
        --print((getCtorKindInString(ctorName))::OutputForm)
        ctorPar  := parameters(head(mainexp)$DefinitionAst)$HeadAst
        ctorSig  := signature(mainexp)$DefinitionAst
        ctorTps  := source(ctorSig)
        --updateGlobalConstructorInformation(sast, ctorName, ctorPar, ctorTps)
        -- caution!
        --ctorPar' : List Identifier := [(e::Identifier) for e in ctorPar]
        loadLib(ctorName::Symbol)$Lisp
        fillCurrentDBRecSlot(ctorName, ctorPar, ctorTps)
        collectCategory2(s, ctorName)

      -- the following case handles the next kind of category definition syntax
      sast case DefinitionAst => 
        ctorName : Identifier := name(head(sast::Syntax::DefinitionAst)$DefinitionAst)$HeadAst
        ctorPar  := parameters(head(sast::Syntax::DefinitionAst)$DefinitionAst)$HeadAst
        ctorSig  := signature(sast::Syntax::DefinitionAst)$DefinitionAst
        ctorTps  := source(ctorSig)         
        -- caution!
        --ctorPar' : List Identifier := [(e::Identifier) for e in ctorPar]
        loadLib(ctorName::Symbol)$Lisp
        fillCurrentDBRecSlot(ctorName, ctorPar, ctorTps)        
        sig := signature(sast::Syntax::DefinitionAst)$DefinitionAst
        tar := target(sig)$Signature
        if tar = buildSyntax('Category,[]) then
          collectCategory(s, ctorName)
        count
      count

    getAllFileName: List FileName ==
      sex := DIRECTORY("/users/yli/software/OA-latest/oa/bin/PARALLEL/example/*.spad")$Lisp
      sexLst := sex pretend List(FileName)
      sexLst

    sexpressionToString(s: FileName): String ==
      res := s::String

    collectAllConstructorData ==
      cleanUp()
      collectAttributes()$AttributeCollection
      sexls :List FileName := getAllFileName() 
      for s in sexls repeat
        fname := sexpressionToString(s)
        nm: List Syntax := parse(fname)$SpadParser
        lookatEach(nm)
      count

    getCategoryConstructorData(cname: Identifier): CEXTR ==
      for r in globalDatabase repeat
        r.catname = cname => return r
      print(cname::OutputForm)
      userError "category extension record not found!"





