)co operatorcats.spad

)abbrev package CHKASSMP CheckAssumption
++ Author: Yue Li
++ Date Created: November 23, 2009
++ Date Last Updated: Jan 24, 2011
++ Description: This package provides library function extracts
++ the knowledge from user assumptions, and store them in an 
++ internal format which can be understood by the reduction detector
CheckAssumption(): Public == Private where
  macro PROPTY == Record(propname: Identifier, propval: Syntax, proptype: Syntax)
  macro OPFUNR == Record(funname: Identifier, signature: Signature)
  macro OPCATS == Record(ctorname: Identifier, ctorpars: List Identifier,_
                         partypes: List Syntax,_
                         decls: List OPFUNR, hascats: List Syntax)     
  macro OPREC == Record(funname: Identifier, origin: Syntax, signature: Signature,_
                        tenv: Table(Syntax, Syntax))
  macro OPASMP == Record(catname: Identifier, parlist: List Syntax,_
                  funpars: List OPREC, assumptionbody: List PROPTY, forall?: Boolean)
  macro OPR == Record(funname: Identifier, origin: Syntax, signature: Signature,_
                      props: List PROPTY, tenv: Table(Syntax, Syntax))
  Public == with
    collectAssociativeOperator: List OPR 
      ++ collect all the associative operator assumed via user assumption
      ++ store their information in a database, those information 
      ++ is function name, signature, as well as values associated to it
      ++ such as the neutral element
    queryProperties: List OPASMP
      ++ returns all the properties for each operator which appears in user
      ++ assumptions
  Private == add
    import SyntaxHelper
    import SpadIrGenerator

    -- global list for storing constructor data of 
    -- each operator category
    operatorCategoryList   : List OPCATS := []

    -- global list for storing internal representation 
    -- of each user assumption
    operatorAssumptionList : List OPASMP := []

    queryProperties() == operatorAssumptionList

    -- global list storing the information of all the
    -- operators which are attached with associativity via assumption
    associativeOperatorList: List OPR  := []

    -- type environment used for typechecking an assumption
    typeEnvironment: Table(Syntax, Syntax) := empty()

    -- extract all the declarations in the export of 
    -- an operator category definition
    extractDeclarationList(ctor: Identifier): List OPFUNR ==
      result : List OPFUNR := []
      c := retract(findConstructor(ctor)$Constructor)$(Maybe Constructor)
      for f in operations c repeat
        fn := name f
        for fd in members f repeat
          sig := signature fd
          r : OPFUNR := [fn, sig]
          result := concat(result, r)
      result

    -- collect all the category extensions listed in
    -- a join ast
    collectJoins(joins: Syntax): List Syntax ==
      result : List Syntax := []
      compound? joins =>
        getOperator(joins)
        (op := getOperator(joins)) case Identifier
        (op := getOperator(joins)) case Identifier and_
        op::Identifier = 'Join::Identifier =>
          for cat in getOperands joins repeat
            not(cat::SpadAst case CategoryAst) => result := concat(result, cat)
          result        
        not(joins::SpadAst case CategoryAst) => 
          result := concat(result, joins)
      []

    -- traverses operator category hierarchy,
    -- collecting the constructor data of each category
    preprocOperatorCategories(): Void == 
      operatorCategoryList := []
      cats := parse("operatorcats.spad")$SpadParser
      for cat in cats repeat
        cat' := cat::DefinitionAst
        cname := name head cat'
        cpars : List Identifier := [id::Identifier for id in parameters head cat']
        csig := source signature cat'
        joins := (body cat')::Syntax
        extractDeclarationList cname
        collectJoins joins
        r: OPCATS := [cname, cpars, csig,_
                      extractDeclarationList cname, collectJoins joins]
        operatorCategoryList := concat(operatorCategoryList, r)

    -- obtain all the parameters of the category used in 
    -- an assumption head
    getParametersFromAssumption(a: WhereAst): List Syntax ==
      callform := first getOperands((mainExpression a)::Syntax)
      getOperands callform

    -- extract the operator category name from an user assumption syntax
    getOperatorCategoryNameFromAssumption(a: WhereAst): Identifier ==
      callform := first getOperands((mainExpression a)::Syntax)
      (opr := getOperator callform)  case Identifier => opr::Identifier
      userError "unexpected type of constructor name"

    -- given a category name, obtain the record storing 
    -- the constructor data of that category collected by our preprocessor
    retrieveCategoryRecord(ctorName: Identifier): OPCATS ==
      for r in operatorCategoryList repeat
        r.ctorname = ctorName => return r
      userError "can not find the category record!"

    -- given a constructor name, figure out the constructor kind
    -- using compiler's database
    getCtorKind(c: Identifier): ConstructorKind == 
      ctor := retract(findConstructor(c)$Constructor)$(Maybe Constructor)
      kind(ctor)$Constructor

    -- checks whether a syntax is a type variable
    isTypeT?(c: Syntax): Boolean ==  
      not compound? c and key?(c, typeEnvironment)

    -- check whether some domain has another category
    -- note that, this function is subject to change
    -- it can not handle the case where a category is parameterized with
    -- type variables 
    checkDomainHasCategory(dom: Syntax, cat: Syntax): Boolean ==
      expression := buildSyntax('has::Syntax::Identifier,[dom, cat])::InputForm
      retractIfCan(_
       (interpret(expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    -- check whether some category has another category
    -- note that, this function is subject to change
    -- it can not handle the case where a domain is parameterized with
    -- type variables 
    checkCategoryHasCategory(catl: Syntax, catr: Syntax): Boolean ==
      expression := buildSyntax('has::Syntax::Identifier, [catl, catr])::InputForm
      retractIfCan((interpret(_
        expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    -- instantiate a signature of an operator parameter with 
    -- the actual types or type variables    
    instantiateSignature(val: Syntax, var: Identifier,_
                    ptypes: List Syntax, index: Integer): List Syntax ==
      ptypesCopy := copy ptypes
      for i in index..#ptypes repeat
        ptypesCopy.i := replace(var::Syntax, ptypes.i, val)$SyntaxHelper
      ptypesCopy

    -- checks whether some operator is annotated with its domain
    isAnnotatedOperator?(op: Syntax): Pair(Boolean, List Syntax) ==
      compound? op =>
        opr := getOperator op 
        opr case Identifier and opr::Identifier = 'elt::Identifier => 
          pair(true, getOperands op)
        pair(false, [])
      pair(false, [])

    -- does type checking for operator parameter of an assumption
    -- where the operator's domain is annotated 
    checkAnnotatedOperatorParameter(tpanot: Syntax, fn: Identifier,_
                                    sig: Syntax): Pair(Boolean, Signature) ==
      sig' := mappingAstToSignature(sig::SpadAst::MappingAst)$SyntaxHelper
      resolveAnnotatedFunction(tpanot, source sig',_
                                 target sig', fn, typeEnvironment)$SpadIrGenerator

    -- does type checking for operator parameter of an assumption
    -- where the operator's domain is not annotated 
    checkUnannotatedOperatorParameter(fn: Identifier,_
                                      sig: Syntax): Pair(Boolean, Signature) ==
      sig' := mappingAstToSignature(sig::SpadAst::MappingAst)$SyntaxHelper
      for dom in concat(source sig', target sig') repeat
        first(t := resolveAnnotatedFunction(dom, source sig',_
          target sig', fn, typeEnvironment)$SpadIrGenerator) => return t
      pair(false, signature([makeUnknown()], makeUnknown())) 
 
    -- does type checking for operator parameter of an assumption
    -- where the operator's domain can be either annotated or not
    checkOperatorParameter(op: Syntax, tp: Syntax): Pair(Boolean, Signature) ==
      first(t := isAnnotatedOperator?(op)) => 
        checkAnnotatedOperatorParameter(first second t,_
                                       (second second t)::Identifier, tp)
      checkUnannotatedOperatorParameter(op::Identifier, tp)

    -- creates a record for storing the knowledge of the operator
    -- being attached with algebraic properties
    createFunctionRecord(f: Syntax, s: Signature): OPREC ==
      first(t := isAnnotatedOperator? f) => 
        [(second second t)::Identifier, first second t, s, copy typeEnvironment]
      [f::Identifier, makeUnknown(), s, copy typeEnvironment]

    -- checks whether a category uses type variables 
    -- in its parameters
    containTypeVar?(cat: Syntax): Boolean ==
      not compound? cat => isTypeT? cat
      for opr in getOperands cat repeat
        containTypeVar? opr  => return true
      false

    -- a global list for storing information of the operator
    -- being attached with algebraic property in a specific assumption
    funRecords: List OPREC := []

    -- a global list for storing name and type of each parameter
    -- of the category used in a specific assumption
    ctorParameters: List Syntax := []

    -- does typechecking for a mapping type, i.e., type of an operator used
    -- in some assumption
    typeCheckMappingType(tp: Syntax, par: Syntax): Void ==
      sig := mappingAstToSignature(tp::SpadAst::MappingAst)$SyntaxHelper
      first(t := checkOperatorParameter(par, tp)) =>
        rec := createFunctionRecord(par, sig)
        funRecords := concat(funRecords, rec)
        ctorParameters := concat(ctorParameters, (rec.funname)::Syntax)
      userError "the operator parameter can not be resolved!"

    -- checks whether a specific domain has some specific category
    domainHasCategory(dom: Syntax, cat: Syntax,_
                      ctorPars: List Identifier,_
                      ctorParTypesCopy: List Syntax, i: Integer): Void ==
      not checkDomainHasCategory(dom, cat) =>
        -- do instantiation using pars.i, ctorPars.i, ctorParTypesCopy
        --ctorParTypesCopy := instantiateSignature(dom, ctorPars.i,_
        --                                         ctorParTypesCopy, i)
        --ctorParameters := concat(ctorParameters, dom)
        print(dom::OutputForm)
        print(cat::OutputForm)
        userError "domain does not have the expected category"

    -- checks whether a category has some other category
    categoryHasCategory(typeVar: Syntax, lcat: Syntax, rcat: Syntax,_
                      ctorPars: List Identifier, ctorParTypesCopy: List Syntax,_
                      i: Integer): Void ==
      checkCategoryHasCategory(lcat, rcat) =>
        -- do instantiation using pars.i, ctorPars.i, ctorParTypesCopy
        ctorParTypesCopy := instantiateSignature(typeVar, ctorPars.i,_
                                                 ctorParTypesCopy, i)
        ctorParameters := concat(ctorParameters, typeVar)
      print(lcat::OutputForm)
      print(rcat::OutputForm)
      userError "category does not have the expected category"

    -- typechecks each parameter of the category used in an assumption
    -- by iterating the type of each parameter, and checks it against 
    -- the expected type as specified in the category definition
    typeCheckEachParameter(ctorParTypesCopy: List Syntax, pars: List Syntax,_
                           ctorPars: List Identifier): Void ==

      for i in 1..#ctorParTypesCopy repeat
        tp := ctorParTypesCopy.i
        tp::SpadAst case MappingAst =>
          typeCheckMappingType(tp, pars.i)
        (isCategory? tp) =>
          isDomain?(pars.i) =>
            if not containTypeVar?(pars.i) then
              domainHasCategory(pars.i, tp, ctorPars, ctorParTypesCopy, i)
            ctorParTypesCopy :=_
              instantiateSignature(pars.i, ctorPars.i, ctorParTypesCopy, i)
            ctorParameters := concat(ctorParameters, pars.i)
          isTypeT?(pars.i) =>
            k := pars.i
            tpOfT := typeEnvironment.k
            isCategory? tpOfT =>
              categoryHasCategory(pars.i, tpOfT, tp,_
                                  ctorPars, ctorParTypesCopy, i)
            userError "the type of T does not have kind category"
          print((pars.i)::OutputForm)
          userError "the input type does not have kind domain"
        userError "the expected type is neither a mapping or category"

    -- does typechecking for the category used in assumption
    -- against the type requirements extracted from the 
    -- operator category definition body
    checkConstructorCallForm(pars: List Syntax,_
                        ctorName: Identifier): Pair(List Syntax, List OPREC) ==
      operatorRecord := retrieveCategoryRecord(ctorName)
      ctorPars : List Identifier := operatorRecord.ctorpars
      ctorParTypes : List Syntax := operatorRecord.partypes
      funRecords := []
      ctorParameters := []
      typeCheckEachParameter(copy ctorParTypes, pars, ctorPars)
      pair(copy ctorParameters, copy funRecords)
    
    -- checks whether an assumption is a generic or basic assumption
    containForall?(a: WhereAst): Pair(Boolean, List Syntax) ==
      mainexp := (mainExpression a)::Syntax
      (fall := getOperator mainexp) case Syntax =>
        forall' := fall::Syntax
        assume  := first getOperands mainexp
        (fa := getOperator forall') case Identifier and_
        fa = 'forall::Identifier =>
          pair(true, [forall', assume])
        pair(false, [])
      pair(false, [])

    -- extract type information from the forall construct
    -- of some generic assumption
    updateForallTypeEnvironment(fall: Syntax): Void ==
      typeEnvironment := empty()
      for s in getOperands fall repeat
        s::SpadAst case ColonAst =>
          s' := s::SpadAst::ColonAst
          id := (lhs s')::Syntax
          tp := (rhs s')::Syntax
          typeEnvironment.id := tp

    -- extract properties from an assumption
    -- currently we can only handle value declarations 
    -- function definition is not well represented, infomation may be missing
    -- but we will fix that if function definition is needed in the future
    -- and definitely, I believe that will be needed
    extractProperties(b: Syntax): List PROPTY ==
      not((x := b::SpadAst) case DefinitionAst) => 
        userError "bug: unexpected type of the property body"
      b' := x::DefinitionAst
      id : Identifier := name(head b')
      not isElt?(s := body(x)::Syntax) => 
        userError "bug: the value of a property is not elt syntax"
      oprs : List Syntax := getOperands s
      t : Syntax := first oprs
      val: Syntax := second oprs
      r : PROPTY := [id, val, t]
      [r]

    -- does typechecking for a generic assumption
    -- after which, the knowledge of the operator being assumed
    -- is stored in a global database
    checkForallAssumption(a: WhereAst, h: List Syntax): Void ==
      fall := first h
      assume := second h
      updateForallTypeEnvironment(fall)
      pars := getOperands first getOperands assume
      aname := (getOperator first getOperands assume)::Identifier
      r := checkConstructorCallForm(pars, aname)
      rec : OPASMP := [aname, first r, second r,_
                      extractProperties((qualifier(a)$WhereAst)::Syntax), true]
      operatorAssumptionList := concat(operatorAssumptionList, rec)

    -- does typechecking on the parameters given to a category
    -- used in a basic assumption. The type requirements are extracted
    -- from the category definition defined in opcategory.spad
    checkAssumption(a: WhereAst): Void ==
      first(t := containForall? a) => 
        checkForallAssumption(a, second t)
      typeEnvironment := empty()
      pars := getParametersFromAssumption(a)
      aname := getOperatorCategoryNameFromAssumption(a)
      r := checkConstructorCallForm(pars, aname)
      rec : OPASMP := [aname, first r, second r,_
                      extractProperties((qualifier(a)$WhereAst)::Syntax), false]
      operatorAssumptionList := concat(operatorAssumptionList, rec)

    -- typechecks each assumption, after which knowledge from 
    -- each assumption is extracted and stored in a global 
    -- database
    preprocessAssumptions(): Void == 
      preprocOperatorCategories()
      operatorAssumptionList := []
      assumps := parse("usrassumptions.spad")$SpadParser
      for a in assumps repeat
        a' := a::WhereAst
        checkAssumption(a')

    -- build a AssociativeOperatorCategory with symbolic constants
    -- as its parameters
    buildAssociativeOperatorCategoryCall(fname: Identifier,_
                                         rtn: Syntax): Syntax ==  
      buildSyntax('AssociativeOperator::Identifier, [rtn, fname::Syntax])

    -- given a category, we instantiate all its constructor data with
    -- the actual parameters of the category, this helps us to 
    -- determine the category extensions of some category at compile
    -- time
    instantiateCategoryRecord(callform: Syntax): List Syntax ==
      cname := getOperator(callform)::Identifier
      pars := getOperands callform
      catrec :=_
        first [copy r for r in operatorCategoryList | r.ctorname = cname]
      constructorParameter := catrec.ctorpars
      hascatlist := catrec.hascats
      hascatlist' : List Syntax := copy hascatlist
      for i in 1..#pars repeat
        for j in 1..#hascatlist' repeat
          hascatlist'.j := replace((constructorParameter.i)::Syntax,_
                                    hascatlist'.j, pars.i)$SyntaxHelper
      hascatlist'

    -- collect all the categories that some category extends       
    collectAncestors(callform: Syntax): List Syntax ==
      result : List Syntax := []
      callform = buildSyntax('Type::Identifier, []) => 
        result := concat(result, callform)
      r' := instantiateCategoryRecord callform
      result := concat(result, r')
      for anc in r' repeat
        result := concat(result, collectAncestors anc)
      removeDuplicates result
    
    -- checks whether some algebraic oeprator category has
    -- AssociativeOperator category, the operator parameter 
    -- of the category can be generic operator, e.g., op: (T, T) -> T
    -- where T has AbelianMonoid
    hasAssociativeOperatorCategoryT?(callform: Syntax, op: OPREC): Boolean ==
      searchTarget :=_
        buildAssociativeOperatorCategoryCall(op.funname, target(op.signature))
      callform = searchTarget => true
      ancestors := collectAncestors callform
      member?(searchTarget, ancestors)

    -- checks whether some algebraic oeprator category has 
    -- AssociativeOperator category, this function is subject to change
    -- because it only supports category whose parameter is a specific 
    -- operator
    hasAssociativeOperatorCategory?(callform: Syntax, op: OPREC): Boolean ==
      right :=_
        buildAssociativeOperatorCategoryCall(op.funname, target(op.signature))
      left  := callform
      expression :=_
        buildSyntax('has::Syntax::Identifier, [left, right])::InputForm
      retractIfCan(_
        (interpret(expression)$InputForm))$AnyFunctions1(Boolean)::Boolean

    -- collect all the associative operators assumed by user
    collectAssociativeOperator() ==
      operatorCategoryList := empty()
      operatorAssumptionList := empty()
      associativeOperatorList := empty()
      preprocessAssumptions()
      for r in operatorAssumptionList repeat
        callform : Syntax := buildSyntax(r.catname, r.parlist)
        for op in r.funpars repeat
          rec : OPR := [op.funname, op.origin, op.signature,_
                                    r.assumptionbody, op.tenv]
          if r.forall? then
            hasAssociativeOperatorCategoryT?(callform, op) => 
              associativeOperatorList := concat(associativeOperatorList, rec)
          else
            hasAssociativeOperatorCategory?(callform, op) => 
              associativeOperatorList := concat(associativeOperatorList, rec)
      associativeOperatorList























