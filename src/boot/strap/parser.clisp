(PROCLAIM '(OPTIMIZE SPEED))
(IMPORT-MODULE "includer")

(IMPORT-MODULE "scanner")

(IMPORT-MODULE "ast")

(IN-PACKAGE "BOOTTRAN")

(PROVIDE "parser")

(DEFUN |bpFirstToken| ()
  (DECLARE (SPECIAL |$ttok| |$stok| |$inputStream|))
  (PROGN
   (SETQ |$stok|
           (COND
            ((NULL |$inputStream|)
             (|shoeTokConstruct| 'ERROR 'NOMORE (|shoeTokPosn| |$stok|)))
            (T (CAR |$inputStream|))))
   (SETQ |$ttok| (|shoeTokPart| |$stok|))
   T))

(DEFUN |bpFirstTok| ()
  (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$ttok| |$stok| |$inputStream|))
  (PROGN
   (SETQ |$stok|
           (COND
            ((NULL |$inputStream|)
             (|shoeTokConstruct| 'ERROR 'NOMORE (|shoeTokPosn| |$stok|)))
            (T (CAR |$inputStream|))))
   (SETQ |$ttok| (|shoeTokPart| |$stok|))
   (COND
    ((AND (PLUSP |$bpParenCount|) (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY))
     (COND ((EQ |$ttok| 'SETTAB) (SETQ |$bpCount| (+ |$bpCount| 1)) (|bpNext|))
           ((EQ |$ttok| 'BACKTAB) (SETQ |$bpCount| (- |$bpCount| 1))
            (|bpNext|))
           ((EQ |$ttok| 'BACKSET) (|bpNext|)) (T T)))
    (T T))))

(DEFUN |bpNext| ()
  (DECLARE (SPECIAL |$inputStream|))
  (PROGN (SETQ |$inputStream| (CDR |$inputStream|)) (|bpFirstTok|)))

(DEFUN |bpNextToken| ()
  (DECLARE (SPECIAL |$inputStream|))
  (PROGN (SETQ |$inputStream| (CDR |$inputStream|)) (|bpFirstToken|)))

(DEFUN |bpRequire| (|f|) (OR (APPLY |f| NIL) (|bpTrap|)))

(DEFUN |bpState| ()
  (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$stack| |$inputStream|))
  (LIST |$inputStream| |$stack| |$bpParenCount| |$bpCount|))

(DEFUN |bpRestore| (|x|)
  (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$stack| |$inputStream|))
  (PROGN
   (SETQ |$inputStream| (CAR |x|))
   (|bpFirstToken|)
   (SETQ |$stack| (CADR |x|))
   (SETQ |$bpParenCount| (CADDR |x|))
   (SETQ |$bpCount| (CADDDR |x|))
   T))

(DEFUN |bpPush| (|x|)
  (DECLARE (SPECIAL |$stack|))
  (SETQ |$stack| (CONS |x| |$stack|)))

(DEFUN |bpPushId| ()
  (DECLARE (SPECIAL |$stack| |$ttok|))
  (SETQ |$stack| (CONS (|bfReName| |$ttok|) |$stack|)))

(DEFUN |bpPop1| ()
  (LET* (|a|)
    (DECLARE (SPECIAL |$stack|))
    (PROGN (SETQ |a| (CAR |$stack|)) (SETQ |$stack| (CDR |$stack|)) |a|)))

(DEFUN |bpPop2| ()
  (LET* (|a|)
    (DECLARE (SPECIAL |$stack|))
    (PROGN (SETQ |a| (CADR |$stack|)) (RPLACD |$stack| (CDDR |$stack|)) |a|)))

(DEFUN |bpPop3| ()
  (LET* (|a|)
    (DECLARE (SPECIAL |$stack|))
    (PROGN
     (SETQ |a| (CADDR |$stack|))
     (RPLACD (CDR |$stack|) (CDDDR |$stack|))
     |a|)))

(DEFUN |bpIndentParenthesized| (|f|)
  (LET* (|a|)
    (DECLARE (SPECIAL |$inputStream| |$bpParenCount| |$stok|))
    (LET ((|$bpCount| 0))
      (DECLARE (SPECIAL |$bpCount|))
      (PROGN
       (SETQ |a| |$stok|)
       (COND
        ((|bpEqPeek| 'OPAREN) (SETQ |$bpParenCount| (+ |$bpParenCount| 1))
         (|bpNext|)
         (COND
          ((AND (APPLY |f| NIL) (|bpFirstTok|)
                (OR (|bpEqPeek| 'CPAREN) (|bpParenTrap| |a|)))
           (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpNextToken|)
           (COND ((EQL |$bpCount| 0) T)
                 (T
                  (SETQ |$inputStream|
                          (|append| (|bpAddTokens| |$bpCount|) |$inputStream|))
                  (|bpFirstToken|)
                  (COND ((EQL |$bpParenCount| 0) (|bpCancel|) T) (T T)))))
          ((|bpEqPeek| 'CPAREN) (|bpPush| (|bfTuple| NIL))
           (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpNextToken|) T)
          (T (|bpParenTrap| |a|))))
        (T NIL))))))

(DEFUN |bpParenthesized| (|f|)
  (LET* (|a|)
    (DECLARE (SPECIAL |$stok|))
    (PROGN
     (SETQ |a| |$stok|)
     (COND
      ((|bpEqKey| 'OPAREN)
       (COND
        ((AND (APPLY |f| NIL) (OR (|bpEqKey| 'CPAREN) (|bpParenTrap| |a|))) T)
        ((|bpEqKey| 'CPAREN) (|bpPush| (|bfTuple| NIL)) T)
        (T (|bpParenTrap| |a|))))
      (T NIL)))))

(DEFUN |bpBracket| (|f|)
  (LET* (|a|)
    (DECLARE (SPECIAL |$stok|))
    (PROGN
     (SETQ |a| |$stok|)
     (COND
      ((|bpEqKey| 'OBRACK)
       (COND
        ((AND (APPLY |f| NIL) (OR (|bpEqKey| 'CBRACK) (|bpBrackTrap| |a|)))
         (|bpPush| (|bfBracket| (|bpPop1|))))
        ((|bpEqKey| 'CBRACK) (|bpPush| NIL)) (T (|bpBrackTrap| |a|))))
      (T NIL)))))

(DEFUN |bpPileBracketed| (|f|)
  (COND
   ((|bpEqKey| 'SETTAB)
    (COND ((|bpEqKey| 'BACKTAB) T)
          ((AND (APPLY |f| NIL) (OR (|bpEqKey| 'BACKTAB) (|bpPileTrap|)))
           (|bpPush| (|bfPile| (|bpPop1|))))
          (T NIL)))
   (T NIL)))

(DEFUN |bpListof| (|f| |str1| |g|)
  (LET* (|a|)
    (DECLARE (SPECIAL |$stack|))
    (COND
     ((APPLY |f| NIL)
      (COND
       ((AND (|bpEqKey| |str1|) (|bpRequire| |f|)) (SETQ |a| |$stack|)
        (SETQ |$stack| NIL)
        (LOOP
         (COND ((NOT (AND (|bpEqKey| |str1|) (|bpRequire| |f|))) (RETURN NIL))
               (T 0)))
        (SETQ |$stack| (CONS (|reverse!| |$stack|) |a|))
        (|bpPush|
         (FUNCALL |g| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|))))))
       (T T)))
     (T NIL))))

(DEFUN |bpListofFun| (|f| |h| |g|)
  (LET* (|a|)
    (DECLARE (SPECIAL |$stack|))
    (COND
     ((APPLY |f| NIL)
      (COND
       ((AND (APPLY |h| NIL) (|bpRequire| |f|)) (SETQ |a| |$stack|)
        (SETQ |$stack| NIL)
        (LOOP
         (COND ((NOT (AND (APPLY |h| NIL) (|bpRequire| |f|))) (RETURN NIL))
               (T 0)))
        (SETQ |$stack| (CONS (|reverse!| |$stack|) |a|))
        (|bpPush|
         (FUNCALL |g| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|))))))
       (T T)))
     (T NIL))))

(DEFUN |bpList| (|f| |str1|)
  (LET* (|a|)
    (DECLARE (SPECIAL |$stack|))
    (COND
     ((APPLY |f| NIL)
      (COND
       ((AND (|bpEqKey| |str1|) (|bpRequire| |f|)) (SETQ |a| |$stack|)
        (SETQ |$stack| NIL)
        (LOOP
         (COND ((NOT (AND (|bpEqKey| |str1|) (|bpRequire| |f|))) (RETURN NIL))
               (T 0)))
        (SETQ |$stack| (CONS (|reverse!| |$stack|) |a|))
        (|bpPush| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|)))))
       (T (|bpPush| (LIST (|bpPop1|))))))
     (T (|bpPush| NIL)))))

(DEFUN |bpOneOrMore| (|f|)
  (LET* (|a|)
    (DECLARE (SPECIAL |$stack|))
    (COND
     ((APPLY |f| NIL) (SETQ |a| |$stack|) (SETQ |$stack| NIL)
      (LOOP (COND ((NOT (APPLY |f| NIL)) (RETURN NIL)) (T 0)))
      (SETQ |$stack| (CONS (|reverse!| |$stack|) |a|))
      (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))
     (T NIL))))

(DEFUN |bpAnyNo| (|s|)
  (PROGN (LOOP (COND ((NOT (APPLY |s| NIL)) (RETURN NIL)) (T 0))) T))

(DEFUN |bpAndOr| (|keyword| |p| |f|)
  (AND (|bpEqKey| |keyword|) (|bpRequire| |p|)
       (|bpPush| (FUNCALL |f| (|bpPop1|)))))

(DEFUN |bpConditional| (|f|)
  (COND
   ((AND (|bpEqKey| 'IF) (|bpRequire| #'|bpWhere|) (OR (|bpEqKey| 'BACKSET) T))
    (COND
     ((|bpEqKey| 'SETTAB)
      (COND
       ((|bpEqKey| 'THEN)
        (AND (|bpRequire| |f|) (|bpElse| |f|) (|bpEqKey| 'BACKTAB)))
       (T (|bpMissing| 'THEN))))
     ((|bpEqKey| 'THEN) (AND (|bpRequire| |f|) (|bpElse| |f|)))
     (T (|bpMissing| '|then|))))
   (T NIL)))

(DEFUN |bpElse| (|f|)
  (LET* (|a|)
    (PROGN
     (SETQ |a| (|bpState|))
     (COND
      ((|bpBacksetElse|)
       (AND (|bpRequire| |f|)
            (|bpPush| (|bfIf| (|bpPop3|) (|bpPop2|) (|bpPop1|)))))
      (T (|bpRestore| |a|)
       (|bpPush| (|bfIfThenOnly| (|bpPop2|) (|bpPop1|))))))))

(DEFUN |bpBacksetElse| ()
  (COND ((|bpEqKey| 'BACKSET) (|bpEqKey| 'ELSE)) (T (|bpEqKey| 'ELSE))))

(DEFUN |bpEqPeek| (|s|)
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY) (EQ |s| |$ttok|)))

(DEFUN |bpEqKey| (|s|)
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY) (EQ |s| |$ttok|) (|bpNext|)))

(DEFUN |bpEqKeyNextTok| (|s|)
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY) (EQ |s| |$ttok|)
       (|bpNextToken|)))

(DEFUN |bpPileTrap| () (|bpMissing| 'BACKTAB))

(DEFUN |bpBrackTrap| (|x|) (|bpMissingMate| '] |x|))

(DEFUN |bpParenTrap| (|x|) (|bpMissingMate| '|)| |x|))

(DEFUN |bpMissingMate| (|close| |open|)
  (PROGN
   (|bpSpecificErrorAtToken| |open| "possibly missing mate")
   (|bpMissing| |close|)))

(DEFUN |bpMissing| (|s|)
  (PROGN
   (|bpSpecificErrorHere| (CONCAT (PNAME |s|) " possibly missing"))
   (THROW :OPEN-AXIOM-CATCH-POINT
     (CONS :OPEN-AXIOM-CATCH-POINT (CONS '(|BootParserException|) 'TRAPPED)))))

(DEFUN |bpCompMissing| (|s|) (OR (|bpEqKey| |s|) (|bpMissing| |s|)))

(DEFUN |bpTrap| ()
  (PROGN
   (|bpGeneralErrorHere|)
   (THROW :OPEN-AXIOM-CATCH-POINT
     (CONS :OPEN-AXIOM-CATCH-POINT (CONS '(|BootParserException|) 'TRAPPED)))))

(DEFUN |bpRecoverTrap| ()
  (LET* (|pos2| |pos1|)
    (DECLARE (SPECIAL |$stok|))
    (PROGN
     (|bpFirstToken|)
     (SETQ |pos1| (|shoeTokPosn| |$stok|))
     (|bpMoveTo| 0)
     (SETQ |pos2| (|shoeTokPosn| |$stok|))
     (|bpIgnoredFromTo| |pos1| |pos2|)
     (|bpPush| (LIST (LIST "pile syntax error"))))))

(DEFUN |bpListAndRecover| (|f|)
  (LET* (|found| |c| |done| |b| |a|)
    (DECLARE (SPECIAL |$inputStream| |$stack|))
    (PROGN
     (SETQ |a| |$stack|)
     (SETQ |b| NIL)
     (SETQ |$stack| NIL)
     (SETQ |done| NIL)
     (SETQ |c| |$inputStream|)
     (LOOP
      (COND (|done| (RETURN NIL))
            (T
             (SETQ |found|
                     (LET ((#1=#:G719
                            (CATCH :OPEN-AXIOM-CATCH-POINT (APPLY |f| NIL))))
                       (COND
                        ((AND (CONSP #1#)
                              (EQUAL (CAR #1#) :OPEN-AXIOM-CATCH-POINT))
                         (COND
                          ((EQUAL (CAR #2=(CDR #1#)) '(|BootParserException|))
                           (LET ((|e| (CDR #2#)))
                             |e|))
                          (T (THROW :OPEN-AXIOM-CATCH-POINT #1#))))
                        (T #1#))))
             (COND
              ((EQ |found| 'TRAPPED) (SETQ |$inputStream| |c|)
               (|bpRecoverTrap|))
              ((NOT |found|) (SETQ |$inputStream| |c|) (|bpGeneralErrorHere|)
               (|bpRecoverTrap|)))
             (COND ((|bpEqKey| 'BACKSET) (SETQ |c| |$inputStream|))
                   ((OR (|bpEqPeek| 'BACKTAB) (NULL |$inputStream|))
                    (SETQ |done| T))
                   (T (SETQ |$inputStream| |c|) (|bpGeneralErrorHere|)
                    (|bpRecoverTrap|)
                    (COND
                     ((OR (|bpEqPeek| 'BACKTAB) (NULL |$inputStream|))
                      (SETQ |done| T))
                     (T (|bpNext|) (SETQ |c| |$inputStream|)))))
             (SETQ |b| (CONS (|bpPop1|) |b|)))))
     (SETQ |$stack| |a|)
     (|bpPush| (|reverse!| |b|)))))

(DEFUN |bpMoveTo| (|n|)
  (DECLARE (SPECIAL |$bpParenCount| |$bpCount| |$inputStream|))
  (COND ((NULL |$inputStream|) T)
        ((|bpEqPeek| 'BACKTAB)
         (COND ((EQL |n| 0) T)
               (T (|bpNextToken|) (SETQ |$bpCount| (- |$bpCount| 1))
                (|bpMoveTo| (- |n| 1)))))
        ((|bpEqPeek| 'BACKSET)
         (COND ((EQL |n| 0) T) (T (|bpNextToken|) (|bpMoveTo| |n|))))
        ((|bpEqPeek| 'SETTAB) (|bpNextToken|) (|bpMoveTo| (+ |n| 1)))
        ((|bpEqPeek| 'OPAREN) (|bpNextToken|)
         (SETQ |$bpParenCount| (+ |$bpParenCount| 1)) (|bpMoveTo| |n|))
        ((|bpEqPeek| 'CPAREN) (|bpNextToken|)
         (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpMoveTo| |n|))
        (T (|bpNextToken|) (|bpMoveTo| |n|))))

(DEFUN |bpQualifiedName| ()
  (DECLARE (SPECIAL |$stok|))
  (COND
   ((|bpEqPeek| 'COLON-COLON) (|bpNext|)
    (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'ID) (|bpPushId|) (|bpNext|)
         (|bpPush| (|bfColonColon| (|bpPop2|) (|bpPop1|)))))
   (T NIL)))

(DEFUN |bpName| ()
  (DECLARE (SPECIAL |$stok|))
  (COND
   ((AND (CONSP |$stok|) (EQ (CAR |$stok|) 'ID)) (|bpPushId|) (|bpNext|)
    (|bpAnyNo| #'|bpQualifiedName|))
   (T NIL)))

(DEFUN |bpConstTok| ()
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (COND
   ((|symbolMember?| (|shoeTokType| |$stok|) '(INTEGER FLOAT))
    (|bpPush| |$ttok|) (|bpNext|))
   ((AND (CONSP |$stok|) (EQ (CAR |$stok|) 'LISP))
    (AND (|bpPush| (|%Lisp| |$ttok|)) (|bpNext|)))
   ((AND (CONSP |$stok|) (EQ (CAR |$stok|) 'LISPEXP))
    (AND (|bpPush| |$ttok|) (|bpNext|)))
   ((AND (CONSP |$stok|) (EQ (CAR |$stok|) 'LINE))
    (AND (|bpPush| (LIST '+LINE |$ttok|)) (|bpNext|)))
   ((|bpEqPeek| 'QUOTE) (|bpNext|)
    (AND (|bpRequire| #'|bpSexp|) (|bpPush| (|bfSymbol| (|bpPop1|)))))
   (T (OR (|bpString|) (|bpFunction|)))))

(DEFUN |bpChar| ()
  (LET* (|ISTMP#1| |s| |a|)
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (COND
     ((AND (CONSP |$stok|) (EQ (CAR |$stok|) 'ID) (EQ |$ttok| '|char|))
      (SETQ |a| (|bpState|))
      (COND
       ((|bpApplication|) (SETQ |s| (|bpPop1|))
        (COND
         ((AND (CONSP |s|) (EQ (CAR |s|) '|char|)
               (PROGN
                (SETQ |ISTMP#1| (CDR |s|))
                (AND (CONSP |ISTMP#1|) (NULL (CDR |ISTMP#1|)))))
          (|bpPush| |s|))
         (T (|bpRestore| |a|) NIL)))
       (T NIL)))
     (T NIL))))

(DEFUN |bpExportItemTail| ()
  (OR
   (AND (|bpEqKey| 'BEC) (|bpRequire| #'|bpAssign|)
        (|bpPush| (|%Assignment| (|bpPop2|) (|bpPop1|))))
   (|bpSimpleDefinitionTail|)))

(DEFUN |bpExportItem| ()
  (LET* (|a|)
    (COND ((|bpEqPeek| 'STRUCTURE) (|bpStruct|))
          (T (SETQ |a| (|bpState|))
           (COND
            ((|bpName|)
             (COND
              ((|bpEqPeek| 'COLON) (|bpRestore| |a|)
               (|bpRequire| #'|bpSignature|) (OR (|bpExportItemTail|) T))
              (T (|bpRestore| |a|) (|bpTypeAliasDefition|))))
            (T NIL))))))

(DEFUN |bpExportItemList| () (|bpListAndRecover| #'|bpExportItem|))

(DEFUN |bpModuleInterface| ()
  (COND
   ((|bpEqKey| 'WHERE)
    (OR (|bpPileBracketed| #'|bpExportItemList|)
        (AND (|bpExportItem|) (|bpPush| (LIST (|bpPop1|)))) (|bpTrap|)))
   (T (|bpPush| NIL))))

(DEFUN |bpModuleExports| ()
  (COND ((|bpParenthesized| #'|bpIdList|) (|bpPush| (|bfUntuple| (|bpPop1|))))
        (T (|bpPush| NIL))))

(DEFUN |bpModule| ()
  (COND
   ((|bpEqKey| 'MODULE) (|bpRequire| #'|bpName|) (|bpModuleExports|)
    (|bpModuleInterface|)
    (|bpPush| (|%Module| (|bpPop3|) (|bpPop2|) (|bpPop1|))))
   (T NIL)))

(DEFUN |bpImport| ()
  (LET* (|a|)
    (COND
     ((|bpEqKey| 'IMPORT)
      (COND
       ((|bpEqKey| 'NAMESPACE)
        (OR
         (AND (|bpLeftAssoc| '(DOT) #'|bpName|)
              (|bpPush| (|%Import| (|bfNamespace| (|bpPop1|)))))
         (|bpTrap|)))
       (T (SETQ |a| (|bpState|)) (|bpRequire| #'|bpName|)
        (COND
         ((|bpEqPeek| 'COLON) (|bpRestore| |a|)
          (AND (|bpRequire| #'|bpSignature|) (OR (|bpEqKey| 'FOR) (|bpTrap|))
               (|bpRequire| #'|bpName|)
               (|bpPush| (|%ImportSignature| (|bpPop1|) (|bpPop1|)))))
         (T (|bpPush| (|%Import| (|bpPop1|))))))))
     (T NIL))))

(DEFUN |bpNamespace| ()
  (AND (|bpEqKey| 'NAMESPACE) (OR (|bpName|) (|bpDot|))
       (|bpPush| (|bfNamespace| (|bpPop1|)))))

(DEFUN |bpTypeAliasDefition| ()
  (AND (OR (|bpTerm| #'|bpIdList|) (|bpTrap|)) (|bpEqKey| 'TDEF) (|bpLogical|)
       (|bpPush| (|%TypeAlias| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpSignature| ()
  (AND (|bpName|) (|bpEqKey| 'COLON) (|bpRequire| #'|bpTyping|)
       (|bpPush| (|%Signature| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpSimpleMapping| ()
  (COND
   ((|bpApplication|)
    (AND (|bpEqKey| 'ARROW) (|bpRequire| #'|bpApplication|)
         (|bpPush| (|%Mapping| (|bpPop1|) (LIST (|bpPop1|)))))
    T)
   (T NIL)))

(DEFUN |bpArgtypeList| () (|bpTuple| #'|bpSimpleMapping|))

(DEFUN |bpMapping| ()
  (AND (|bpParenthesized| #'|bpArgtypeList|) (|bpEqKey| 'ARROW)
       (|bpApplication|)
       (|bpPush| (|%Mapping| (|bpPop1|) (|bfUntuple| (|bpPop1|))))))

(DEFUN |bpCancel| ()
  (LET* (|a|)
    (PROGN
     (SETQ |a| (|bpState|))
     (COND
      ((|bpEqKeyNextTok| 'SETTAB)
       (COND
        ((|bpCancel|)
         (COND ((|bpEqKeyNextTok| 'BACKTAB) T) (T (|bpRestore| |a|) NIL)))
        ((|bpEqKeyNextTok| 'BACKTAB) T) (T (|bpRestore| |a|) NIL)))
      (T NIL)))))

(DEFUN |bpAddTokens| (|n|)
  (DECLARE (SPECIAL |$stok|))
  (COND ((EQL |n| 0) NIL)
        ((PLUSP |n|)
         (CONS (|shoeTokConstruct| 'KEY 'SETTAB (|shoeTokPosn| |$stok|))
               (|bpAddTokens| (- |n| 1))))
        (T
         (CONS (|shoeTokConstruct| 'KEY 'BACKTAB (|shoeTokPosn| |$stok|))
               (|bpAddTokens| (+ |n| 1))))))

(DEFUN |bpExceptions| ()
  (OR (|bpEqPeek| 'DOT) (|bpEqPeek| 'QUOTE) (|bpEqPeek| 'OPAREN)
      (|bpEqPeek| 'CPAREN) (|bpEqPeek| 'SETTAB) (|bpEqPeek| 'BACKTAB)
      (|bpEqPeek| 'BACKSET)))

(DEFUN |bpSexpKey| ()
  (LET* (|a|)
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (COND
     ((AND (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY) (NOT (|bpExceptions|)))
      (SETQ |a| (GET |$ttok| 'SHOEINF))
      (COND ((NULL |a|) (AND (|bpPush| (|keywordId| |$ttok|)) (|bpNext|)))
            (T (AND (|bpPush| |a|) (|bpNext|)))))
     (T NIL))))

(DEFUN |bpAnyId| ()
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (OR
   (AND (|bpEqKey| 'MINUS)
        (OR (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'INTEGER)) (|bpTrap|))
        (|bpPush| (- |$ttok|)) (|bpNext|))
   (|bpSexpKey|)
   (AND (|symbolMember?| (|shoeTokType| |$stok|) '(ID INTEGER STRING FLOAT))
        (|bpPush| |$ttok|) (|bpNext|))))

(DEFUN |bpSexp| ()
  (OR (|bpAnyId|)
      (AND (|bpEqKey| 'QUOTE) (|bpRequire| #'|bpSexp|)
           (|bpPush| (|bfSymbol| (|bpPop1|))))
      (|bpIndentParenthesized| #'|bpSexp1|)))

(DEFUN |bpSexp1| ()
  (OR
   (AND (|bpFirstTok|) (|bpSexp|)
        (OR
         (AND (|bpEqKey| 'DOT) (|bpSexp|)
              (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))
         (AND (|bpSexp1|) (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))))
   (|bpPush| NIL)))

(DEFUN |bpPrimary1| ()
  (OR (|bpParenthesizedApplication|) (|bpDot|) (|bpConstTok|) (|bpConstruct|)
      (|bpCase|) (|bpStruct|) (|bpPDefinition|) (|bpBPileDefinition|)))

(DEFUN |bpParenthesizedApplication| ()
  (AND (|bpName|) (|bpAnyNo| #'|bpArgumentList|)))

(DEFUN |bpArgumentList| ()
  (AND (|bpPDefinition|) (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpPrimary| ()
  (AND (|bpFirstTok|) (OR (|bpPrimary1|) (|bpPrefixOperator|))))

(DEFUN |bpDot| () (AND (|bpEqKey| 'DOT) (|bpPush| (|bfDot|))))

(DEFUN |bpPrefixOperator| ()
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY) (GET |$ttok| 'SHOEPRE)
       (|bpPushId|) (|bpNext|)))

(DEFUN |bpInfixOperator| ()
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY) (GET |$ttok| 'SHOEINF)
       (|bpPushId|) (|bpNext|)))

(DEFUN |bpSelector| ()
  (AND (|bpEqKey| 'DOT)
       (OR (AND (|bpPrimary|) (|bpPush| (|bfElt| (|bpPop2|) (|bpPop1|))))
           (|bpPush| (|bfSuffixDot| (|bpPop1|))))))

(DEFUN |bpApplication| ()
  (OR
   (AND (|bpPrimary|) (|bpAnyNo| #'|bpSelector|)
        (OR
         (AND (|bpApplication|)
              (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|))))
         T))
   (|bpNamespace|)))

(DEFUN |bpTyping| ()
  (COND
   ((|bpEqKey| 'FORALL) (|bpRequire| #'|bpVariable|)
    (OR (AND (|bpDot|) (|bpPop1|)) (|bpTrap|)) (|bpRequire| #'|bpTyping|)
    (|bpPush| (|%Forall| (|bpPop2|) (|bpPop1|))))
   (T (OR (|bpMapping|) (|bpSimpleMapping|)))))

(DEFUN |bpTagged| ()
  (AND (|bpApplication|)
       (OR
        (AND (|bpEqKey| 'COLON) (|bpRequire| #'|bpTyping|)
             (|bpPush| (|bfTagged| (|bpPop2|) (|bpPop1|))))
        T)))

(DEFUN |bpExpt| () (|bpRightAssoc| '(POWER) #'|bpTagged|))

(DEFUN |bpInfKey| (|s|)
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (CONSP |$stok|) (EQ (CAR |$stok|) 'KEY) (|symbolMember?| |$ttok| |s|)
       (|bpPushId|) (|bpNext|)))

(DEFUN |bpInfGeneric| (|s|) (AND (|bpInfKey| |s|) (OR (|bpEqKey| 'BACKSET) T)))

(DEFUN |bpRightAssoc| (|o| |p|)
  (LET* (|a|)
    (PROGN
     (SETQ |a| (|bpState|))
     (COND
      ((APPLY |p| NIL)
       (LOOP
        (COND
         ((NOT
           (AND (|bpInfGeneric| |o|) (OR (|bpRightAssoc| |o| |p|) (|bpTrap|))))
          (RETURN NIL))
         (T (|bpPush| (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))))
       T)
      (T (|bpRestore| |a|) NIL)))))

(DEFUN |bpLeftAssoc| (|operations| |parser|)
  (COND
   ((APPLY |parser| NIL)
    (LOOP
     (COND
      ((NOT (AND (|bpInfGeneric| |operations|) (|bpRequire| |parser|)))
       (RETURN NIL))
      (T (|bpPush| (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))))
    T)
   (T NIL)))

(DEFUN |bpString| ()
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (EQ (|shoeTokType| |$stok|) 'STRING)
       (|bpPush| (|quote| (INTERN |$ttok|))) (|bpNext|)))

(DEFUN |bpFunction| ()
  (AND (|bpEqKey| 'FUNCTION) (|bpRequire| #'|bpPrimary1|)
       (|bpPush| (|bfFunction| (|bpPop1|)))))

(DEFUN |bpThetaName| ()
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (COND
   ((AND (CONSP |$stok|) (EQ (CAR |$stok|) 'ID) (GET |$ttok| 'SHOETHETA))
    (|bpPushId|) (|bpNext|))
   (T NIL)))

(DEFUN |bpReduceOperator| ()
  (OR (|bpInfixOperator|) (|bpString|) (|bpThetaName|)))

(DEFUN |bpReduce| ()
  (LET* (|a|)
    (PROGN
     (SETQ |a| (|bpState|))
     (COND
      ((AND (|bpReduceOperator|) (|bpEqKey| 'SLASH))
       (COND
        ((|bpEqPeek| 'OBRACK)
         (AND (|bpRequire| #'|bpDConstruct|)
              (|bpPush| (|bfReduceCollect| (|bpPop2|) (|bpPop1|)))))
        (T
         (AND (|bpRequire| #'|bpApplication|)
              (|bpPush| (|bfReduce| (|bpPop2|) (|bpPop1|)))))))
      (T (|bpRestore| |a|) NIL)))))

(DEFUN |bpTimes| () (OR (|bpReduce|) (|bpLeftAssoc| '(TIMES SLASH) #'|bpExpt|)))

(DEFUN |bpEuclid| () (|bpLeftAssoc| '(QUO REM) #'|bpTimes|))

(DEFUN |bpMinus| ()
  (OR
   (AND (|bpInfGeneric| '(MINUS)) (|bpRequire| #'|bpEuclid|)
        (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|))))
   (|bpEuclid|)))

(DEFUN |bpArith| () (|bpLeftAssoc| '(PLUS MINUS) #'|bpMinus|))

(DEFUN |bpIs| ()
  (AND (|bpArith|)
       (COND
        ((AND (|bpInfKey| '(IS ISNT)) (|bpRequire| #'|bpPattern|))
         (|bpPush| (|bfISApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))
        ((AND (|bpEqKey| 'HAS) (|bpRequire| #'|bpApplication|))
         (|bpPush| (|bfHas| (|bpPop2|) (|bpPop1|))))
        (T T))))

(DEFUN |bpBracketConstruct| (|f|)
  (AND (|bpBracket| |f|) (|bpPush| (|bfConstruct| (|bpPop1|)))))

(DEFUN |bpCompare| ()
  (OR
   (AND (|bpIs|)
        (OR
         (AND (|bpInfKey| '(SHOEEQ SHOENE LT LE GT GE IN))
              (|bpRequire| #'|bpIs|)
              (|bpPush| (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))
         T))
   (|bpLeave|) (|bpThrow|)))

(DEFUN |bpAnd| () (|bpLeftAssoc| '(AND) #'|bpCompare|))

(DEFUN |bpThrow| ()
  (COND
   ((AND (|bpEqKey| 'THROW) (|bpApplication|))
    (COND
     ((|bpEqKey| 'COLON) (|bpRequire| #'|bpApplication|)
      (|bpPush| (|%Pretend| (|bpPop2|) (|bpPop1|)))))
    (|bpPush| (|bfThrow| (|bpPop1|))))
   (T NIL)))

(DEFUN |bpTry| ()
  (LET* (|cs|)
    (COND
     ((|bpEqKey| 'TRY) (|bpAssign|) (SETQ |cs| NIL)
      (LOOP
       (COND ((NOT (|bpHandler| 'CATCH)) (RETURN NIL))
             (T (|bpCatchItem|) (SETQ |cs| (CONS (|bpPop1|) |cs|)))))
      (COND
       ((|bpHandler| 'FINALLY)
        (AND (|bpFinally|)
             (|bpPush|
              (|bfTry| (|bpPop2|) (|reverse!| (CONS (|bpPop1|) |cs|))))))
       ((NULL |cs|) (|bpTrap|))
       (T (|bpPush| (|bfTry| (|bpPop1|) (|reverse!| |cs|))))))
     (T NIL))))

(DEFUN |bpCatchItem| ()
  (AND (|bpRequire| #'|bpExceptionVariable|) (OR (|bpEqKey| 'EXIT) (|bpTrap|))
       (|bpRequire| #'|bpAssign|) (|bpPush| (|%Catch| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpExceptionVariable| ()
  (LET* (|t|)
    (DECLARE (SPECIAL |$stok|))
    (PROGN
     (SETQ |t| |$stok|)
     (OR
      (AND (|bpEqKey| 'OPAREN) (|bpRequire| #'|bpSignature|)
           (OR (|bpEqKey| 'CPAREN) (|bpMissing| |t|)))
      (|bpTrap|)))))

(DEFUN |bpFinally| ()
  (AND (|bpRequire| #'|bpAssign|) (|bpPush| (|%Finally| (|bpPop1|)))))

(DEFUN |bpHandler| (|key|)
  (LET* (|s|)
    (PROGN
     (SETQ |s| (|bpState|))
     (COND
      ((AND (OR (|bpEqKey| 'BACKSET) (|bpEqKey| 'SEMICOLON)) (|bpEqKey| |key|))
       T)
      (T (|bpRestore| |s|) NIL)))))

(DEFUN |bpLeave| ()
  (AND (|bpEqKey| 'LEAVE) (|bpRequire| #'|bpLogical|)
       (|bpPush| (|bfLeave| (|bpPop1|)))))

(DEFUN |bpDo| ()
  (COND
   ((|bpEqKey| 'IN) (|bpRequire| #'|bpNamespace|) (|bpRequire| #'|bpDo|)
    (|bpPush| (|bfAtScope| (|bpPop2|) (|bpPop1|))))
   (T
    (AND (|bpEqKey| 'DO) (|bpRequire| #'|bpAssign|)
         (|bpPush| (|bfDo| (|bpPop1|)))))))

(DEFUN |bpReturn| ()
  (OR
   (AND (|bpEqKey| 'RETURN) (|bpRequire| #'|bpAssign|)
        (|bpPush| (|bfReturnNoName| (|bpPop1|))))
   (|bpLeave|) (|bpThrow|) (|bpAnd|) (|bpDo|)))

(DEFUN |bpLogical| () (|bpLeftAssoc| '(OR) #'|bpReturn|))

(DEFUN |bpExpression| ()
  (OR
   (AND (|bpEqKey| 'COLON)
        (OR (AND (|bpLogical|) (|bpPush| (|bfApplication| 'COLON (|bpPop1|))))
            (|bpTrap|)))
   (|bpLogical|)))

(DEFUN |bpStatement| ()
  (OR (|bpConditional| #'|bpWhere|) (|bpLoop|) (|bpExpression|) (|bpTry|)))

(DEFUN |bpLoop| ()
  (OR
   (AND (|bpIterators|) (|bpCompMissing| 'REPEAT) (|bpRequire| #'|bpWhere|)
        (|bpPush| (|bfLp| (|bpPop2|) (|bpPop1|))))
   (AND (|bpEqKey| 'REPEAT) (|bpRequire| #'|bpLogical|)
        (|bpPush| (|bfLoop1| (|bpPop1|))))))

(DEFUN |bpSuchThat| () (|bpAndOr| 'BAR #'|bpWhere| #'|bfSuchthat|))

(DEFUN |bpWhile| () (|bpAndOr| 'WHILE #'|bpLogical| #'|bfWhile|))

(DEFUN |bpUntil| () (|bpAndOr| 'UNTIL #'|bpLogical| #'|bfUntil|))

(DEFUN |bpFormal| () (OR (|bpVariable|) (|bpDot|)))

(DEFUN |bpForIn| ()
  (AND (|bpEqKey| 'FOR) (|bpRequire| #'|bpFormal|) (|bpCompMissing| 'IN)
       (OR
        (AND (|bpRequire| #'|bpSeg|) (|bpEqKey| 'BY) (|bpRequire| #'|bpArith|)
             (|bpPush| (|bfForInBy| (|bpPop3|) (|bpPop2|) (|bpPop1|))))
        (|bpPush| (|bfForin| (|bpPop2|) (|bpPop1|))))))

(DEFUN |bpSeg| ()
  (AND (|bpArith|)
       (OR
        (AND (|bpEqKey| 'SEG)
             (OR
              (AND (|bpArith|) (|bpPush| (|bfSegment2| (|bpPop2|) (|bpPop1|))))
              (|bpPush| (|bfSegment1| (|bpPop1|)))))
        T)))

(DEFUN |bpIterator| () (OR (|bpForIn|) (|bpSuchThat|) (|bpWhile|) (|bpUntil|)))

(DEFUN |bpIteratorList| ()
  (AND (|bpOneOrMore| #'|bpIterator|) (|bpPush| (|bfIterators| (|bpPop1|)))))

(DEFUN |bpCrossBackSet| () (AND (|bpEqKey| 'CROSS) (OR (|bpEqKey| 'BACKSET) T)))

(DEFUN |bpIterators| ()
  (|bpListofFun| #'|bpIteratorList| #'|bpCrossBackSet| #'|bfCross|))

(DEFUN |bpAssign| ()
  (LET* (|a|)
    (PROGN
     (SETQ |a| (|bpState|))
     (COND
      ((|bpStatement|)
       (COND
        ((|bpEqPeek| 'BEC) (|bpRestore| |a|) (|bpRequire| #'|bpAssignment|))
        ((|bpEqPeek| 'GIVES) (|bpRestore| |a|) (|bpRequire| #'|bpLambda|))
        ((|bpEqPeek| 'LARROW) (|bpRestore| |a|) (|bpRequire| #'|bpKeyArg|))
        (T T)))
      (T (|bpRestore| |a|) NIL)))))

(DEFUN |bpAssignment| ()
  (AND (|bpAssignVariable|) (|bpEqKey| 'BEC) (|bpRequire| #'|bpAssign|)
       (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpLambda| ()
  (AND (|bpVariable|) (|bpEqKey| 'GIVES) (|bpRequire| #'|bpAssign|)
       (|bpPush| (|bfLambda| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpKeyArg| ()
  (AND (|bpName|) (|bpEqKey| 'LARROW) (|bpLogical|)
       (|bpPush| (|bfKeyArg| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpExit| ()
  (AND (|bpAssign|)
       (OR
        (AND (|bpEqKey| 'EXIT) (|bpRequire| #'|bpWhere|)
             (|bpPush| (|bfExit| (|bpPop2|) (|bpPop1|))))
        T)))

(DEFUN |bpDefinition| ()
  (LET* (|a|)
    (COND
     ((|bpEqKey| 'MACRO)
      (OR
       (AND (|bpName|) (|bpStoreName|) (|bpCompoundDefinitionTail| #'|%Macro|))
       (|bpTrap|)))
     (T (SETQ |a| (|bpState|))
      (COND
       ((|bpExit|)
        (COND ((|bpEqPeek| 'DEF) (|bpRestore| |a|) (|bpDef|))
              ((|bpEqPeek| 'TDEF) (|bpRestore| |a|) (|bpTypeAliasDefition|))
              (T T)))
       (T (|bpRestore| |a|) NIL))))))

(DEFUN |bpStoreName| ()
  (DECLARE (SPECIAL |$typings| |$wheredefs| |$op| |$stack|))
  (PROGN
   (SETQ |$op| (CAR |$stack|))
   (SETQ |$wheredefs| NIL)
   (SETQ |$typings| NIL)
   T))

(DEFUN |bpDef| ()
  (OR (AND (|bpName|) (|bpStoreName|) (|bpDefTail| #'|%Definition|))
      (AND (|bpNamespace|) (|bpSimpleDefinitionTail|))))

(DEFUN |bpDDef| () (AND (|bpName|) (|bpDefTail| #'|%Definition|)))

(DEFUN |bpSimpleDefinitionTail| ()
  (AND (|bpEqKey| 'DEF) (|bpRequire| #'|bpWhere|)
       (|bpPush| (|%ConstantDefinition| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpCompoundDefinitionTail| (|f|)
  (AND (|bpVariable|) (|bpEqKey| 'DEF) (|bpRequire| #'|bpWhere|)
       (|bpPush| (APPLY |f| (LIST (|bpPop3|) (|bpPop2|) (|bpPop1|))))))

(DEFUN |bpDefTail| (|f|)
  (OR (|bpSimpleDefinitionTail|) (|bpCompoundDefinitionTail| |f|)))

(DEFUN |bpWhere| ()
  (AND (|bpDefinition|)
       (OR
        (AND (|bpEqKey| 'WHERE) (|bpRequire| #'|bpDefinitionItem|)
             (|bpPush| (|bfWhere| (|bpPop1|) (|bpPop1|))))
        T)))

(DEFUN |bpDefinitionItem| ()
  (LET* (|a|)
    (PROGN
     (SETQ |a| (|bpState|))
     (COND ((|bpDDef|) T)
           (T (|bpRestore| |a|)
            (COND ((|bpBDefinitionPileItems|) T)
                  (T (|bpRestore| |a|)
                   (COND ((|bpPDefinitionItems|) T)
                         (T (|bpRestore| |a|) (|bpWhere|))))))))))

(DEFUN |bpDefinitionPileItems| ()
  (AND (|bpListAndRecover| #'|bpDefinitionItem|)
       (|bpPush| (|%Pile| (|bpPop1|)))))

(DEFUN |bpBDefinitionPileItems| ()
  (|bpPileBracketed| #'|bpDefinitionPileItems|))

(DEFUN |bpSemiColonDefinition| ()
  (|bpSemiListing| #'|bpDefinitionItem| #'|%Pile|))

(DEFUN |bpPDefinitionItems| () (|bpParenthesized| #'|bpSemiColonDefinition|))

(DEFUN |bpComma| () (OR (|bpModule|) (|bpImport|) (|bpTuple| #'|bpWhere|)))

(DEFUN |bpTuple| (|p|) (|bpListofFun| |p| #'|bpCommaBackSet| #'|bfTuple|))

(DEFUN |bpCommaBackSet| () (AND (|bpEqKey| 'COMMA) (OR (|bpEqKey| 'BACKSET) T)))

(DEFUN |bpSemiColon| () (|bpSemiListing| #'|bpComma| #'|bfSequence|))

(DEFUN |bpSemiListing| (|p| |f|) (|bpListofFun| |p| #'|bpSemiBackSet| |f|))

(DEFUN |bpSemiBackSet| ()
  (AND (|bpEqKey| 'SEMICOLON) (OR (|bpEqKey| 'BACKSET) T)))

(DEFUN |bpPDefinition| () (|bpIndentParenthesized| #'|bpSemiColon|))

(DEFUN |bpPileItems| ()
  (AND (|bpListAndRecover| #'|bpSemiColon|)
       (|bpPush| (|bfSequence| (|bpPop1|)))))

(DEFUN |bpBPileDefinition| () (|bpPileBracketed| #'|bpPileItems|))

(DEFUN |bpIteratorTail| () (AND (OR (|bpEqKey| 'REPEAT) T) (|bpIterators|)))

(DEFUN |bpConstruct| () (|bpBracket| #'|bpConstruction|))

(DEFUN |bpConstruction| ()
  (AND (|bpComma|)
       (OR
        (AND (|bpIteratorTail|) (|bpPush| (|bfCollect| (|bpPop2|) (|bpPop1|))))
        (|bpPush| (|bfTupleConstruct| (|bpPop1|))))))

(DEFUN |bpDConstruct| () (|bpBracket| #'|bpDConstruction|))

(DEFUN |bpDConstruction| ()
  (AND (|bpComma|)
       (OR
        (AND (|bpIteratorTail|)
             (|bpPush| (|bfDCollect| (|bpPop2|) (|bpPop1|))))
        (|bpPush| (|bfDTuple| (|bpPop1|))))))

(DEFUN |bpPattern| ()
  (OR (|bpBracketConstruct| #'|bpPatternL|) (|bpChar|) (|bpName|)
      (|bpConstTok|)))

(DEFUN |bpEqual| ()
  (AND (|bpEqKey| 'SHOEEQ) (OR (|bpApplication|) (|bpConstTok|) (|bpTrap|))
       (|bpPush| (|bfEqual| (|bpPop1|)))))

(DEFUN |bpRegularPatternItem| ()
  (OR (|bpEqual|) (|bpConstTok|) (|bpDot|)
      (AND (|bpName|)
           (OR
            (AND (|bpEqKey| 'BEC) (|bpRequire| #'|bpPattern|)
                 (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
            T))
      (|bpBracketConstruct| #'|bpPatternL|)))

(DEFUN |bpRegularPatternItemL| ()
  (AND (|bpRegularPatternItem|) (|bpPush| (LIST (|bpPop1|)))))

(DEFUN |bpRegularList| ()
  (|bpListof| #'|bpRegularPatternItemL| 'COMMA #'|bfAppend|))

(DEFUN |bpPatternColon| ()
  (AND (|bpEqKey| 'COLON) (|bpRequire| #'|bpRegularPatternItem|)
       (|bpPush| (LIST (|bfColon| (|bpPop1|))))))

(DEFUN |bpPatternL| ()
  (AND (|bpPatternList|) (|bpPush| (|bfTuple| (|bpPop1|)))))

(DEFUN |bpPatternList| ()
  (COND
   ((|bpRegularPatternItemL|)
    (LOOP
     (COND
      ((NOT
        (AND (|bpEqKey| 'COMMA)
             (OR (|bpRegularPatternItemL|)
                 (PROGN
                  (OR
                   (AND (|bpPatternTail|)
                        (|bpPush| (|append| (|bpPop2|) (|bpPop1|))))
                   (|bpTrap|))
                  NIL))))
       (RETURN NIL))
      (T (|bpPush| (|append| (|bpPop2|) (|bpPop1|))))))
    T)
   (T (|bpPatternTail|))))

(DEFUN |bpPatternTail| ()
  (AND (|bpPatternColon|)
       (OR
        (AND (|bpEqKey| 'COMMA) (|bpRequire| #'|bpRegularList|)
             (|bpPush| (|append| (|bpPop2|) (|bpPop1|))))
        T)))

(DEFUN |bpRegularBVItemTail| ()
  (OR
   (AND (|bpEqKey| 'COLON) (|bpRequire| #'|bpApplication|)
        (|bpPush| (|bfTagged| (|bpPop2|) (|bpPop1|))))
   (AND (|bpEqKey| 'BEC) (|bpRequire| #'|bpPattern|)
        (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
   (AND (|bpEqKey| 'IS) (|bpRequire| #'|bpPattern|)
        (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
   (AND (|bpEqKey| 'DEF) (|bpRequire| #'|bpApplication|)
        (|bpPush| (|%DefaultValue| (|bpPop2|) (|bpPop1|))))))

(DEFUN |bpRegularBVItem| ()
  (OR (|bpBVString|) (|bpConstTok|)
      (AND (|bpName|) (OR (|bpRegularBVItemTail|) T))
      (|bpBracketConstruct| #'|bpPatternL|)))

(DEFUN |bpBVString| ()
  (DECLARE (SPECIAL |$ttok| |$stok|))
  (AND (EQ (|shoeTokType| |$stok|) 'STRING)
       (|bpPush| (LIST 'BVQUOTE (INTERN |$ttok|))) (|bpNext|)))

(DEFUN |bpRegularBVItemL| ()
  (AND (|bpRegularBVItem|) (|bpPush| (LIST (|bpPop1|)))))

(DEFUN |bpColonName| ()
  (AND (|bpEqKey| 'COLON) (OR (|bpName|) (|bpBVString|) (|bpTrap|))))

(DEFUN |bpBoundVariablelist| ()
  (COND
   ((|bpRegularBVItemL|)
    (LOOP
     (COND
      ((NOT
        (AND (|bpEqKey| 'COMMA)
             (OR (|bpRegularBVItemL|)
                 (PROGN
                  (OR
                   (AND (|bpColonName|)
                        (|bpPush| (|bfColonAppend| (|bpPop2|) (|bpPop1|))))
                   (|bpTrap|))
                  NIL))))
       (RETURN NIL))
      (T (|bpPush| (|append| (|bpPop2|) (|bpPop1|))))))
    T)
   (T (AND (|bpColonName|) (|bpPush| (|bfColonAppend| NIL (|bpPop1|)))))))

(DEFUN |bpVariable| ()
  (OR
   (AND (|bpParenthesized| #'|bpBoundVariablelist|)
        (|bpPush| (|bfTupleIf| (|bpPop1|))))
   (|bpBracketConstruct| #'|bpPatternL|) (|bpName|) (|bpConstTok|)))

(DEFUN |bpAssignVariable| ()
  (OR (|bpBracketConstruct| #'|bpPatternL|) (|bpAssignLHS|)))

(DEFUN |bpAssignLHS| ()
  (COND ((NOT (|bpName|)) NIL)
        ((|bpEqKey| 'COLON) (|bpRequire| #'|bpApplication|)
         (|bpPush| (|bfLocal| (|bpPop2|) (|bpPop1|))))
        (T
         (AND (|bpArgumentList|)
              (OR (|bpEqPeek| 'DOT)
                  (AND (|bpEqPeek| 'BEC) (|bpPush| (|bfPlace| (|bpPop1|))))
                  (|bpTrap|)))
         (COND
          ((|bpEqKey| 'DOT)
           (AND (|bpList| #'|bpPrimary| 'DOT) (|bpChecknull|)
                (|bpPush| (|bfTuple| (CONS (|bpPop2|) (|bpPop1|))))))
          (T T)))))

(DEFUN |bpChecknull| ()
  (LET* (|a|)
    (PROGN
     (SETQ |a| (|bpPop1|))
     (COND ((NULL |a|) (|bpTrap|)) (T (|bpPush| |a|))))))

(DEFUN |bpStruct| ()
  (AND (|bpEqKey| 'STRUCTURE) (|bpRequire| #'|bpName|)
       (OR (|bpEqKey| 'DEF) (|bpTrap|)) (OR (|bpRecord|) (|bpTypeList|))
       (|bpPush| (|%Structure| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpRecord| ()
  (LET* (|s|)
    (PROGN
     (SETQ |s| (|bpState|))
     (COND
      ((AND (|bpName|) (EQ (|bpPop1|) '|Record|))
       (AND (OR (|bpParenthesized| #'|bpFieldList|) (|bpTrap|))
            (|bpGlobalAccessors|)
            (|bpPush| (|%Record| (|bfUntuple| (|bpPop2|)) (|bpPop1|)))))
      (T (|bpRestore| |s|) NIL)))))

(DEFUN |bpFieldList| () (|bpTuple| #'|bpSignature|))

(DEFUN |bpGlobalAccessors| ()
  (COND
   ((|bpEqKey| 'WITH)
    (OR (|bpPileBracketed| #'|bpAccessorDefinitionList|) (|bpTrap|)))
   (T (|bpPush| NIL))))

(DEFUN |bpAccessorDefinitionList| ()
  (|bpListAndRecover| #'|bpAccessorDefinition|))

(DEFUN |bpAccessorDefinition| ()
  (AND (|bpRequire| #'|bpName|) (OR (|bpEqKey| 'DEF) (|bpTrap|))
       (|bpRequire| #'|bpFieldSection|)
       (|bpPush| (|%AccessorDef| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpFieldSection| () (|bpParenthesized| #'|bpSelectField|))

(DEFUN |bpSelectField| () (AND (|bpEqKey| 'DOT) (|bpName|)))

(DEFUN |bpTypeList| ()
  (OR (|bpPileBracketed| #'|bpTypeItemList|)
      (AND (|bpTypeItem|) (|bpPush| (LIST (|bpPop1|))))))

(DEFUN |bpTypeItem| () (|bpTerm| #'|bpIdList|))

(DEFUN |bpTypeItemList| () (|bpListAndRecover| #'|bpTypeItem|))

(DEFUN |bpTerm| (|idListParser|)
  (OR
   (AND (|bpRequire| #'|bpName|)
        (OR
         (AND (|bpParenthesized| |idListParser|)
              (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))
         (AND (|bpName|) (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))))
   (|bpPush| (|bfNameOnly| (|bpPop1|)))))

(DEFUN |bpIdList| () (|bpTuple| #'|bpName|))

(DEFUN |bpCase| ()
  (AND (|bpEqKey| 'CASE) (|bpRequire| #'|bpWhere|)
       (OR (|bpEqKey| 'OF) (|bpMissing| 'OF)) (|bpPiledCaseItems|)))

(DEFUN |bpPiledCaseItems| ()
  (AND (|bpPileBracketed| #'|bpCaseItemList|)
       (|bpPush| (|bfCase| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpCaseItemList| () (|bpListAndRecover| #'|bpCaseItem|))

(DEFUN |bpCasePatternVar| () (OR (|bpName|) (|bpDot|)))

(DEFUN |bpCasePatternVarList| () (|bpTuple| #'|bpCasePatternVar|))

(DEFUN |bpCaseItem| ()
  (AND (OR (|bpTerm| #'|bpCasePatternVarList|) (|bpTrap|))
       (OR (|bpEqKey| 'EXIT) (|bpTrap|)) (|bpRequire| #'|bpWhere|)
       (|bpPush| (|bfCaseItem| (|bpPop2|) (|bpPop1|)))))

(DEFUN |bpOutItem| ()
  (LET* (|r| |ISTMP#2| |l| |ISTMP#1| |b|)
    (DECLARE (SPECIAL |$InteractiveMode|))
    (LET* ((|$op| NIL) (|$GenVarCounter| 0))
      (DECLARE (SPECIAL |$op| |$GenVarCounter|))
      (PROGN
       (|bpRequire| #'|bpComma|)
       (SETQ |b| (|bpPop1|))
       (|bpPush|
        (COND ((AND (CONSP |b|) (EQ (CAR |b|) '+LINE)) (LIST |b|))
              ((AND (CONSP |b|) (EQ (CAR |b|) 'L%T)
                    (PROGN
                     (SETQ |ISTMP#1| (CDR |b|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                           (SETQ |l| (CAR |ISTMP#1|))
                           (SETQ |ISTMP#2| (CDR |ISTMP#1|))
                           (AND (CONSP |ISTMP#2|) (NULL (CDR |ISTMP#2|))
                                (PROGN (SETQ |r| (CAR |ISTMP#2|)) T)))))
                    (SYMBOLP |l|))
               (COND (|$InteractiveMode| (LIST (LIST 'SETQ |l| |r|)))
                     (T (LIST (LIST 'DEFPARAMETER |l| |r|)))))
              (T (|translateToplevel| |b| NIL))))))))

