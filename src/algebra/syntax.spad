--Copyright (C) 2007, Gabriel Dos Reis.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical Algorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

)abbrev domain SYNTAX Syntax
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Updated: December 05, 2007
++ Description:  This domain provides a simple, general, and arguably 
++ complete representation of Spad programs as objects of a term algebra
++ built from ground terms of type boolean, integers, foats, symbols, 
++ and strings.  This domain differs from InputForm in that it represents
++ any entity from a Spad program, not just expressions.
++ Related Constructors: Boolean, Integer, Float, symbol, String, SExpression.
++ See Also: SExpression.
++ Fixme: Provide direct support for boolean values, arbritrary 
++        precision float point values.
Syntax(): Public == Private where
  Public ==> CoercibleTo(OutputForm) with
    convert: % -> SExpression
      ++ convert(s) returns the s-expression representation of a syntax.

    convert: SExpression -> %
      ++ convert(s) converts an s-expression to syntax.  Note, when `s'
      ++ is not an atom, it is expected that it designates a proper list,
      ++ e.g. a sequence of cons cell ending with nil.

    coerce: Integer -> %
      ++ coerce(i) injects the integer value `i' into the Syntax domain

    convert: % -> Integer
      ++ coerce(i) extracts the integer value `i' from the Syntax domain

    coerce: DoubleFloat -> %
      ++ coerce(f) injects the float value `f' into the Syntax domain

    convert: % -> DoubleFloat
      ++ convert(f) extracts the float value `f' from the Syntax domain

    coerce: Symbol -> %
      ++ coerce(s) injects the symbol `s' into the Syntax domain.

    convert: % -> Symbol
      ++ convert(s) extracts the symbol `s' from the Syntax domain.

    coerce: String -> %
      ++ coerce(s) injects the string value `s' into the syntax domain

    convert: % -> String
      ++ convert(s) extract the string value `s' from the syntax domain

    buildSyntax: (Symbol, List %) -> %
      ++ buildSyntax(op, [a1, ..., an]) builds a syntax object for op(a1,...,an).
  
    buildSyntax: (%, List %) -> %
      ++ buildSyntax(op, [a1, ..., an]) builds a syntax object for op(a1,...,an).

    nil?: % -> Boolean
      ++ nil?(s) is true when `s' is a syntax for the constant nil.

    getOperator: % -> Union(Integer, DoubleFloat, Symbol, String, %)
      ++ getOperator(x) returns the operator, or tag, of the syntax `x'.
      ++ The return value is itself a syntax if `x' really is an 
      ++ application of a function symbol as opposed to being an
      ++ atomic ground term.
 

    getOperands: % -> List %
      ++ getOperands(x) returns the list of operands to the operator in `x'.

    _case: (%, [|Integer|]) -> Boolean
      ++ x case Integer is true is x really is an Integer 

    _case: (%, [|DoubleFloat|]) -> Boolean
      ++ x case DoubleFloat is true is x really is a DoubleFloat

    _case: (%, [|Symbol|]) -> Boolean
      ++ x case Symbol is true is x really is a Symbol

    _case: (%, [|String|]) -> Boolean
      ++ x case String is true is x really is a String

  Private ==> SExpression add
    rep(x: %): SExpression ==
      x pretend SExpression

    per(x: SExpression): % ==
      x pretend %

    s case Integer ==
      integer? rep s

    s case DoubleFloat ==
      float? rep s

    s case String ==
      string? rep s

    s case Symbol ==
      symbol? rep s

    convert(x: %): SExpression ==
      rep x

    convert(x: SExpression): % ==
      per x

    coerce(i: Integer): % ==
      i pretend %

    convert(i: %): Integer ==
      i case Integer => i
      userError "invalid conversion target type"

    coerce(f: DoubleFloat): % ==
      f pretend %

    convert(f: %): DoubleFloat ==
      f case DoubleFloat => f
      userError "invalid conversion target type"

    coerce(s: Symbol): % ==
      s pretend %

    convert(s: %): Symbol ==
      s case Symbol => s
      userError "invalid conversion target type"

    coerce(s: String): % ==
      s pretend %

    convert(s: %): String ==
      s case String => s
      userError "invalid conversion target type"

    buildSyntax(s: Symbol, l: List %): % ==
      -- ??? ideally we should have overloaded operator `per' that convert
      -- from list of syntax to syntax.  But the compiler is at the 
      -- moment defective for non-exported overloaded operations.
      cons(s::%, l) pretend %

    buildSyntax(op: %, l: List %): % ==
      cons(op, l) pretend %

    nil? x ==
      null? rep x

    getOperator x ==
      atom? rep x => userError "atom as operand to getOperator"
      op := car rep x
      symbol? op => symbol op
      integer? op => integer op
      float? op => float op
      string? op => string op
      convert op

    getOperands x ==
      s := rep x
      atom? s => []
      [per t for t in destruct cdr s]
