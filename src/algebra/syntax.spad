--Copyright (C) 2007, Gabriel Dos Reis.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical Algorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


)abbrev domain SYNTAX Syntax
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Updated: November 12, 2007
++ Description:  This domain provides a simple, general, and arguably 
++ complete representation of Spad programs as objects of a term algebra
++ built from ground terms of type boolean, integers, foats, symbols, 
++ and strings.  This domain differs from InputForm in that it represents
++ any entity from a Spad program, not just expressions.
++ Related Constructors: Boolean, Integer, Float, symbol, String, SExpression.
++ See Also: SExpression.
++ Fixme: Provide direct support for boolean values, arbritrary 
++        precision float point values.
Syntax(): Public == Private where
  Public ==> CoercibleTo(OutputForm) with
    convert: % -> SExpression
      ++ convert(s) returns the s-expression representation of a syntax.

    convert: SExpression -> %
      ++ convert(s) converts an s-expression to syntax.

    convert: Integer -> %
      ++ convert(i) injects the integer value `i' into the syntax domain

    convert: DoubleFloat -> %
      ++ convert(f) injects the float value `f' into the syntax domain

    convert: Symbol -> %
      ++ convert(s) injects the symbol `s' into the syntax domain.

    convert: String -> %
      ++ convert(s) injects the string value `s' into the syntax domain

    buildSyntax: (Symbol, List %) -> %
      ++ buildSyntax(op, [a1, ..., an]) builds a syntax object for op(a1,...,an).
  
    getOperator: % -> Union(Integer, DoubleFloat, Symbol, String, %)
      ++ getOperator(x) returns the operator, or tag, of the syntax `x'.
      ++ The return value is itself a syntax if `x' really is an 
      ++ application of a function symbol as opposed to being an
      ++ atomic ground term.
 

    getOperands: % -> List %
      ++ getOperands(x) returns the list of operands to the operator in `x'.

  Private ==> SExpression add
    rep(x: %): SExpression ==
      x pretend SExpression

    per(x: SExpression): % ==
      x pretend %

    convert(x: %): SExpression ==
      rep x

    convert(x: SExpression): % ==
      per x

    convert(i: Integer): % ==
      per convert(i)$SExpression

    convert(f: DoubleFloat): % ==
      per convert(f)$SExpression

    convert(s: Symbol): % ==
      per convert(s)$SExpression

    convert(s: String): % ==
      per convert(s)$SExpression

    buildSyntax(s: Symbol, l: List %): % ==
      -- ??? ideally we should have overloaded operator `per' that convert
      -- from list of syntax to syntax.  But the compiler is at the 
      -- moment defective for non-exported operations.
      cons(convert(s)$%, l) pretend %

    getOperator x ==
      s := rep x
      symbol? s => symbol s
      integer? s => integer s
      float? s => float s
      string? s => string s
      convert(car s)

    getOperands x ==
      s := rep x
      atom? s => []
      [per t for t in destruct cdr s]
