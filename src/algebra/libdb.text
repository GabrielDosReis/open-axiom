acanonicalUnitNormal`0`x``cIntegerNumberSystem``
acanonical`0`x``dSingleInteger``\spad{canonical} means that mathematical equality is implied by data structure equality.
acanonicalsClosed`0`x``dSingleInteger``\spad{canonicalClosed} means two positives multiply to give positive.
amultiplicativeValuation`0`x``cIntegerNumberSystem``euclideanSize(a*b) returns \spad{euclideanSize(a)*euclideanSize(b)}.
anoetherian`0`x``dSingleInteger``\spad{noetherian} all ideals are finitely generated (in fact principal).
cIntegerNumberSystem`0`x`()->Category``INS`An \spad{IntegerNumberSystem} is a model for the integers.
dPlaneAlgebraicCurvePlot`0`x`()->Join(PlottablePlaneCurveCategory,etc)``ACPLOT`\indented{1}{Plot a NON-SINGULAR plane algebraic curve \spad{p}(\spad{x},{}\spad{y}) = 0.} Author: Clifton \spad{J}. Williamson Date Created: Fall 1988 Date Last Updated: 27 April 1990 Keywords: algebraic curve,{} non-singular,{} plot Examples: References:
dSingleInteger`0`x`()->Join(IntegerNumberSystem,etc)``SINT`SingleInteger is intended to support machine integer arithmetic.
o/\`2`x`(_$,_$)->_$`dSingleInteger``\spad{n} \spad{/\} \spad{m} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.
oAnd`2`x`(_$,_$)->_$`dSingleInteger``\spad{And(n,{}m)} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.
oNot`1`x`(_$)->_$`dSingleInteger``\spad{Not(n)} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.
oOr`2`x`(_$,_$)->_$`dSingleInteger``\spad{Or(n,{}m)} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.
o\/`2`x`(_$,_$)->_$`dSingleInteger``\spad{n} \spad{\/} \spad{m} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.
oaddmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{addmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a+b mod p}.
obase`0`x`()->_$`cIntegerNumberSystem``\spad{base()} returns the base for the operations of \spad{IntegerNumberSystem}.
obinomial`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
obit?`2`x`(S,S)->Boolean`xIntegerNumberSystem&(S)``
obit?`2`x`(_$,_$)->Boolean`cIntegerNumberSystem``\spad{bit?(n,{}i)} returns \spad{true} if and only if \spad{i}-th bit of \spad{n} is a 1.
ocharacteristic`0`x`()->NonNegativeInteger`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->DoubleFloat`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->Float`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->InputForm`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->Integer`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->Pattern(Integer)`xIntegerNumberSystem&(S)``
ocopy`1`x`(S)->S`xIntegerNumberSystem&(S)``
ocopy`1`x`(_$)->_$`cIntegerNumberSystem``\spad{copy(n)} gives a copy of \spad{n}.
odec`1`x`(_$)->_$`cIntegerNumberSystem``\spad{dec(x)} returns \spad{x - 1}.
odifferentiate`1`x`(S)->S`xIntegerNumberSystem&(S)``
odifferentiate`2`x`(S,NonNegativeInteger)->S`xIntegerNumberSystem&(S)``
oeuclideanSize`1`x`(S)->NonNegativeInteger`xIntegerNumberSystem&(S)``
oeven?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
oeven?`1`x`(_$)->Boolean`cIntegerNumberSystem``\spad{even?(n)} returns \spad{true} if and only if \spad{n} is even.
ofactor`1`x`(S)->Factored(S)`xIntegerNumberSystem&(S)``
ofactorial`1`x`(S)->S`xIntegerNumberSystem&(S)``
ohash`1`x`(_$)->_$`cIntegerNumberSystem``\spad{hash(n)} returns the hash code of \spad{n}.
oinc`1`x`(_$)->_$`cIntegerNumberSystem``\spad{inc(x)} returns \spad{x + 1}.
oinit`0`x`()->S`xIntegerNumberSystem&(S)``
oinvmod`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
oinvmod`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{invmod(a,{}b)},{} \spad{0<=a<b>1},{} \spad{(a,{}b)=1} means \spad{1/a mod b}.
olength`1`x`(_$)->_$`cIntegerNumberSystem``\spad{length(a)} length of \spad{a} in digits.
omakeSketch`5`x`(Polynomial(Integer),Symbol,Symbol,Segment(Fraction(Integer)),Segment(Fraction(Integer)))->_$`dPlaneAlgebraicCurvePlot``\spad{makeSketch(p,{}x,{}y,{}a..b,{}c..d)} creates an ACPLOT of the curve \spad{p = 0} in the region {\em a <= x <= b,{} c <= y <= d}. More specifically,{} 'makeSketch' plots a non-singular algebraic curve \spad{p = 0} in an rectangular region {\em xMin <= x <= xMax},{} {\em yMin <= y <= yMax}. The user inputs \spad{makeSketch(p,{}x,{}y,{}xMin..xMax,{}yMin..yMax----)}. Here \spad{p} is a polynomial in the variables \spad{x} and \spad{y} with integer coefficients (\spad{p} belongs to the domain \spad{Polynomial Integer}). The case where \spad{p} is a polynomial in only one of the variables is allowed. The variables \spad{x} and \spad{y} are input to specify the the coordinate axes. The horizontal axis is the \spad{x}-axis and the vertical axis is the \spad{y}-axis. The rational numbers xMin,{}...,{}yMax specify the boundaries of the region in which the --cu--rve is to be plotted.
omask`1`x`(S)->S`xIntegerNumberSystem&(S)``
omask`1`x`(_$)->_$`cIntegerNumberSystem``\spad{mask(n)} returns \spad{2**n-1} (an \spad{n} bit mask).
omax`0`x`()->_$`dSingleInteger``\spad{max()} returns the largest single integer.
omin`0`x`()->_$`dSingleInteger``\spad{min()} returns the smallest single integer.
omulmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{mulmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a*b mod p}.
onextItem`1`x`(S)->Union(S,"failed")`xIntegerNumberSystem&(S)``
oodd?`1`x`(_$)->Boolean`cIntegerNumberSystem``\spad{odd?(n)} returns \spad{true} if and only if \spad{n} is odd.
opatternMatch`3`x`(S,Pattern(Integer),PatternMatchResult(Integer,S))->PatternMatchResult(Integer,S)`xIntegerNumberSystem&(S)``
opermutation`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
opositive?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
opositiveRemainder`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{positiveRemainder(a,{}b)} (where \spad{b > 1}) yields \spad{r} where \spad{0 <= r < b} and \spad{r == a rem b}.
opowmod`3`x`(S,S,S)->S`xIntegerNumberSystem&(S)``
opowmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{powmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a**b mod p}.
oprime?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
orandom`0`x`()->_$`cIntegerNumberSystem``\spad{random()} creates a random element.
orandom`1`x`(_$)->_$`cIntegerNumberSystem``\spad{random(a)} creates a random element from 0 to \spad{n-1}.
orational?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
orational?`1`x`(_$)->Boolean`cIntegerNumberSystem``\spad{rational?(n)} tests if \spad{n} is a rational number (see \spadtype{Fraction Integer}).
orationalIfCan`1`x`(S)->Union(Fraction(Integer),"failed")`xIntegerNumberSystem&(S)``
orationalIfCan`1`x`(_$)->Union(Fraction(Integer),"failed")`cIntegerNumberSystem``\spad{rationalIfCan(n)} creates a rational number,{} or returns "failed" if this is not possible.
orational`1`x`(S)->Fraction(Integer)`xIntegerNumberSystem&(S)``
orational`1`x`(_$)->Fraction(Integer)`cIntegerNumberSystem``\spad{rational(n)} creates a rational number (see \spadtype{Fraction Integer})..
orealSolve`3`x`(List(Polynomial(Integer)),List(Symbol),Float)->List(List(Float))`pRealSolvePackage``\spad{realSolve(lp,{}lv,{}eps)} = compute the list of the real solutions of the list \spad{lp} of polynomials with integer coefficients with respect to the variables in \spad{lv},{} with precision \spad{eps}.
orefine`2`x`(_$,DoubleFloat)->_$`dPlaneAlgebraicCurvePlot``\spad{refine(p,{}x)} \undocumented{}
oretractIfCan`1`x`(S)->Union(Integer,"failed")`xIntegerNumberSystem&(S)``
oretract`1`x`(S)->Integer`xIntegerNumberSystem&(S)``
oshift`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{shift(a,{}i)} shift \spad{a} by \spad{i} digits.
osolve`2`x`(Polynomial(Fraction(Integer)),Float)->List(Float)`pRealSolvePackage``\spad{solve(p,{}eps)} finds the real zeroes of a univariate rational polynomial \spad{p} with precision \spad{eps}.
osolve`2`x`(Polynomial(Integer),Float)->List(Float)`pRealSolvePackage``\spad{solve(p,{}eps)} finds the real zeroes of a univariate integer polynomial \spad{p} with precision \spad{eps}.
osquareFree`1`x`(S)->Factored(S)`xIntegerNumberSystem&(S)``
osubmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{submod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a-b mod p}.
osymmetricRemainder`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
osymmetricRemainder`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{symmetricRemainder(a,{}b)} (where \spad{b > 1}) yields \spad{r} where \spad{ -b/2 <= r < b/2 }.
oxor`2`x`(_$,_$)->_$`dSingleInteger``\spad{xor(n,{}m)} returns the bit-by-bit logical {\em xor} of the single integers \spad{n} and \spad{m}.
o~`1`x`(_$)->_$`dSingleInteger``\spad{~ n} returns the bit-by-bit logical {\em not } of the single integer \spad{n}.
pRealSolvePackage`0`x`()->etc``REALSOLV`\indented{1}{This package provides numerical solutions of systems of polynomial} equations for use in ACPLOT.
xIntegerNumberSystem&`1`x`(IntegerNumberSystem)->etc`(S)`INS-`An \spad{IntegerNumberSystem} is a model for the integers.
