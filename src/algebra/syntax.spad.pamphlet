\documentclass{article}
\usepackage{axiom}

\author{Gabriel Dos~Reis}

\begin{document}

\begin{abstract}
\end{abstract}

\tableofcontents
\eject

\section{domain Syntax}

<<domain SYNTAX Syntax>>=
import UnionType
import SetCategory
import Boolean
import Integer
import DoubleFloat
import Symbol
import SExpression
)abbrev domain SYNTAX Syntax
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Updated: December 05, 2007
++ Description:  This domain provides a simple domain, general enough for
++ building complete representation of Spad programs as objects 
++ of a term algebra built from ground terms of type integers, foats, 
++ symbols, and strings.  
++ This domain differs from InputForm in that it represents
++ any entity in a Spad program, not just expressions.
++ Related Constructors: Boolean, Integer, Float, Symbol, String, SExpression.
++ See Also: SExpression, SetCategory.
++ The equality supported by this domain is structural.
++ Fixme: Provide direct support for boolean values, arbritrary 
++        precision float point values.
Syntax(): Public == Private where
  Public ==> Join(UnionType, SetCategory) with
    convert: % -> SExpression
      ++ convert(s) returns the s-expression representation of a syntax.

    convert: SExpression -> %
      ++ convert(s) converts an s-expression to Syntax.  Note, when `s'
      ++ is not an atom, it is expected that it designates a proper list,
      ++ e.g. a sequence of cons cells ending with nil.

    coerce: Integer -> %
      ++ coerce(i) injects the integer value `i' into the Syntax domain.
    coerce: % -> Integer
      ++ coerce(s) extracts and integer value from the syntax `s'
    autoCoerce: % -> Integer
      ++ autoCoerce(s) forcibly extracts an integer value from
      ++ the syntax `s'; no check performed.  To be called only
      ++ at the discretion of the compiler.

    coerce: DoubleFloat -> %
      ++ coerce(f) injects the float value `f' into the Syntax domain
    coerce: % -> DoubleFloat
      ++ coerce(s) extracts a float value from the syntax `s'.
    autoCoerce: % -> DoubleFloat
      ++ autoCoerce(s) forcibly extracts a float value from the syntax `s';
      ++ no check performed.  To be called only at the discretion of
      ++ the compiler

    coerce: Symbol -> %
      ++ coerce(s) injects the symbol `s' into the Syntax domain.
    coerce: % -> Symbol
      ++ coerce(s) extracts a symbol from the syntax `s'.
    autoCoerce: % -> Symbol
      ++ autoCoerce(s) forcibly extracts a symbo from the Syntax
      ++ domain `s'; no check performed.  To be called only at
      ++ at the discretion of the compiler.

    coerce: String -> %
      ++ coerce(s) injects the string value `s' into the syntax domain
    coerce: % -> String
      ++ coerce(s) extracts a string value from the syntax `s'.
    autoCoerce: % -> String
      ++ autoCoerce(s) forcibly extracts a string value from
      ++ the syntax `s'; no check performed.  To be called only at
      ++ the discretion of the compiler.

    buildSyntax: (Symbol, List %) -> %
      ++ buildSyntax(op, [a1, ..., an]) builds a syntax object 
      ++ for op(a1,...,an).
  
    buildSyntax: (%, List %) -> %
      ++ buildSyntax(op, [a1, ..., an]) builds a syntax object 
      ++ for op(a1,...,an).

    nil?: % -> Boolean
      ++ nil?(s) is true when `s' is a syntax for the constant nil.

    getOperator: % -> Union(Integer, DoubleFloat, Symbol, String, %)
      ++ getOperator(x) returns the operator, or tag, of the syntax `x'.
      ++ The value returned is itself a syntax if `x' really is an 
      ++ application of a function symbol as opposed to being an
      ++ atomic ground term.
 
    getOperands: % -> List %
      ++ getOperands(x) returns the list of operands to the operator in `x'.

    compound?: % -> Boolean
      ++ compound? x is true when `x' is not an atomic syntax.

    _case: (%, [|Integer|]) -> Boolean
      ++ x case Integer is true if `x' really is an Integer 

    _case: (%, [|DoubleFloat|]) -> Boolean
      ++ x case DoubleFloat is true if `x' really is a DoubleFloat

    _case: (%, [|Symbol|]) -> Boolean
      ++ x case Symbol is true if `x' really is a Symbol

    _case: (%, [|String|]) -> Boolean
      ++ x case String is true if `x' really is a String

  Private ==> SExpression add
    rep(x: %): SExpression ==
      x pretend SExpression

    per(x: SExpression): % ==
      x pretend %

    x = y ==
      EQUAL(x,y)$Lisp @ Boolean

    s case Integer ==
      integer? rep s

    s case DoubleFloat ==
      float? rep s

    s case String ==
      string? rep s

    s case Symbol ==
      symbol? rep s

    convert(x: %): SExpression ==
      rep x

    convert(x: SExpression): % ==
      per x

    coerce(i: Integer): % ==
      i pretend %

    autoCoerce(i: %): Integer ==                -- used for hard coercion
      i : Integer

    coerce(i: %): Integer ==
      i case Integer => i
      userError "invalid conversion target type"

    coerce(f: DoubleFloat): % ==
      f pretend %

    autoCoerce(f: %): DoubleFloat ==		-- used for hard coercion
      f : DoubleFloat

    coerce(f: %): DoubleFloat ==
      f case DoubleFloat => f
      userError "invalid conversion target type"

    coerce(s: Symbol): % ==
      s pretend %

    autoCoerce(s: %): Symbol ==                 -- used for hard coercion
      s : Symbol

    coerce(s: %): Symbol ==
      s case Symbol => s
      userError "invalid conversion target type"

    coerce(s: String): % ==
      s pretend %

    autoCoerce(s: %): String ==                 -- used for hard coercion
      s : String

    coerce(s: %): String ==
      s case String => s
      userError "invalid conversion target type"

    buildSyntax(s: Symbol, l: List %): % ==
      -- ??? ideally we should have overloaded operator `per' that convert
      -- from list of syntax to syntax.  But the compiler is at the 
      -- moment defective for non-exported overloaded operations.
      -- Furthermore, this direct call to `CONS' is currently necessary
      -- in order to have the Syntax domain compiled as early as possible
      -- in algebra boostrapping process.  It should be removed once
      -- the bootstrap process is improved.
      CONS(s,l)$Lisp @ %

    buildSyntax(op: %, l: List %): % ==
      CONS(op,l)$Lisp @ %

    nil? x ==
      null? rep x

    getOperator x ==
      atom? rep x => userError "atom as operand to getOperator"
      op := car rep x
      symbol? op => symbol op
      integer? op => integer op
      float? op => float op
      string? op => string op
      convert op
   
    compound? x ==
      pair? rep x

    getOperands x ==
      s := rep x
      atom? s => []
      [per t for t in destruct cdr s]
@


\section{domain ConstructorCall}

<<domain CTORCALL ConstructorCall>>=
import SetCategory
import Symbol
import List Syntax
)abbrev domain CTORCALL ConstructorCall
++ Author: Gabriel Dos Reis
++ Date Created: January 19, 2008
++ Date Last Updated: July 03, 2008
++ Description: This domains represents a syntax object that
++ designates a category, domain, or a package.
++ See Also: Syntax, Domain
ConstructorCall(): Public == Private where
  Public == SetCategory with
    constructorName: % -> Symbol
      ++ constructorName c returns the name of the constructor
    arguments: % -> List Syntax
      ++ arguments returns the list of syntax objects for the
      ++ arguments used to invoke the constructor.

  Private == add
    Rep == List Syntax

    constructorName x ==
      (first rep x)::Symbol

    arguments x ==
      rest rep x

    x = y ==
      rep x = rep y

    coerce x ==
      outputDomainConstructor(x)$Lisp
@

\section{The Signature domain}

<<domain SIG Signature>>=
import SetCategory
import CoercibleTo
import List
import Syntax
)abbrev domain SIG Signature
++ Author: Gabriel Dos Reis
++ Date Created: January 10, 2008
++ Date Last Updated: August 30, 2008
++ Description: This is the datatype for operation signatures as
++   used by the compiler and the interpreter.  Note that this domain
++   differs from SignatureAst.
++ See also: ConstructorCall, Domain.
Signature(): Public == Private where
  Public == SetCategory with
    signature: (List Syntax,Syntax) -> %
      ++ signature(s,t) constructs a Signature object with parameter
      ++ types indicaded by `s', and return type indicated by `t'.
    target: % -> Syntax
      ++ target(s) returns the target type of the signature `s'.
    source: % -> List Syntax
      ++ source(s) returns the list of parameter types of `s'.
  Private == add
    Rep == List Syntax
    signature(s,t) == per cons(t,s)
    target x == first rep x
    source x == rest rep x
    x = y == rep x = rep y
    coerce(x: %): OutputForm ==
      rarrow([s::OutputForm for s in source x]::OutputForm,
         target(x)::OutputForm)$OutputForm
@

\section{domain ElaboratedExpression}

<<domain ELABEXPR ElaboratedExpression>>=
import Boolean
import Symbol
import ConstructorCall
import List
import SExpression
)abbrev domain ELABEXPR ElaboratedExpression
++ Author: Gabriel Dos Reis
++ Date Created: January 19, 2008
++ Date Last Updated: January 20, 2008
++ Description: This domains an expresion as elaborated by the interpreter.
++ See Also: 
ElaboratedExpression(): Public == Private where
  Public ==> CoercibleTo OutputForm with
    type: % -> ConstructorCall
      ++ type(e) returns the type of the expression as computed by
      ++ the interpreter.
    constant?: % -> Boolean
      ++ constant?(e) returns true if `e' is a constant.
    getConstant: % -> Union(SExpression,"failed")
      ++ getConstant(e) retrieves the constant value of `e'e.
    variable?: % -> Boolean
      ++ variable?(e) returns true if `e' is a variable.
    getIdentifier: % -> Union(Symbol,"failed")
      ++ getIdentifier(e) retrieves the name of the variable `e'.
    callForm?: % -> Boolean
      ++ callForm?(e) is true when `e' is a call expression.
    getOperator: % -> Union(Symbol, "failed")
      ++ getOperator(e) retrieves the operator being invoked in `e',
      ++ when `e' is an expression.  
    getOperands: % -> Union(List %, "failed")
      ++ getOperands(e) returns the list of operands in `e', assuming it
      ++ is a call form.

  Private ==> add
    isAtomic(x: %): Boolean ==
      ATOM(x)$Lisp @ Boolean

    type x ==
      getMode(x)$Lisp @ ConstructorCall

    callForm? x ==
      CONSP(x)$Lisp @ Boolean

    getOperator x ==
      op: SExpression := getUnnameIfCan(x)$Lisp
      null? op => "failed"
      op pretend Symbol

    constant? x ==
      isAtomic x and 
        EQ(getUnnameIfCan(x)$Lisp, _$immediateDataSymbol$Lisp)$Lisp : Boolean

    getConstant x ==
      constant? x => getValue(x)$Lisp @ SExpression
      "failed"

    variable? x ==
      isAtomic x and not constant? x
   
    getIdentifier x ==
      variable? x => symbol (getUnname(x)$Lisp@SExpression)
      "failed"
@


\section{SpadAbstractSyntaxCategory}

<<category ASTCAT AbstractSyntaxCategory>>=
import SetCategory
import CoercibleTo Syntax
)abbrev category ASTCAT AbstractSyntaxCategory
++ Author: Gabriel Dos Reis
++ Date Created: July 5, 2008
++ Date Last Modified: July 5, 2008
++ Description: This is the category of Spad abstract syntax trees.
AbstractSyntaxCategory(): Category == 
    Join(SetCategory, CoercibleTo Syntax)
  add
    coerce(x: %): Syntax ==
      x pretend Syntax
    coerce(x: %): OutputForm ==
      x::Syntax::OutputForm 
@

\section{The SpadSyntaxCategory category}

<<category SASTCAT SpadSyntaxCategory>>=
)abbrev category SASTCAT SpadSyntaxCategory
++ Author: Gabriel Dos Reis
++ Date Created: July 5, 2008
++ Date Last Modified: September 3, 2008
++ Description: This is the category of Spad syntax objects.
SpadSyntaxCategory(): Category == AbstractSyntaxCategory
  add
    renderSyntax: Syntax -> OutputForm

    renderMapping(x: List Syntax): OutputForm ==
      src := [renderSyntax t for t in rest x]::List(OutputForm)::OutputForm
      tar := renderSyntax first x
      elt('MappingAst::OutputForm,
        ['source::OutputForm = src, 'target::OutputForm = tar])$OutputForm
     
    renderAttribute(x: Syntax): OutputForm ==
      elt('AttributeAst::OutputForm,
        ['name::OutputForm = renderSyntax x])$OutputForm

    renderImport(x: List Syntax): OutputForm ==
      ts := [renderSyntax t for t in x]::List(OutputForm)::OutputForm
      elt('ImportAst::OutputForm, ['imports::OutputForm = ts])$OutputForm

    renderSignature(x: List Syntax): OutputForm ==
      n := renderSyntax first x
      s := (last(x) : Signature)::OutputForm
      elt('SignatureAst::OutputForm,
        ['name::OutputForm = n, 'signature::OutputForm = s])$OutputForm

    renderIf(x: List Syntax): OutputForm ==
      c := renderSyntax first x
      t := renderSyntax second x
      e := renderSyntax third x
      elt('IfAst::OutputForm,
        ['condition::OutputForm = c, 'thenBranch::OutputForm = t,
           'elseBranch::OutputForm = e])$OutputForm

    renderRepeat(x: List Syntax): OutputForm ==
      its := [renderSyntax(x.i) for i in 1..(#x-1)]
               ::List(OutputForm)::OutputForm
      b := renderSyntax last x
      elt('RepeatAst::OutputForm,
        ['iterators::OutputForm = its, 'body::OutputForm = b])$OutputForm

    renderWhile(x: List Syntax): OutputForm ==
      elt('WhileAst::OutputForm,
        ['condition::OutputForm = renderSyntax first x])$OutputForm

    renderIn(x: List Syntax): OutputForm ==
      elt('InAst::OutputForm,
        ['iterationVar::OutputForm = renderSyntax first x,
           'sequence::OutputForm = renderSyntax last x])$OutputForm
     
    renderCollect(x: List Syntax): OutputForm ==
      its := [renderSyntax(x.i) for i in 1..(#x-1)]
               ::List(OutputForm)::OutputForm
      elt('CollectAst::OutputForm,
        ['iterators::OutputForm = its, 
           'body::OutputForm = renderSyntax last x])$OutputForm
   
    renderConstruct(x: List Syntax): OutputForm ==
      es := [renderSyntax t for t in x]::List(OutputForm)::OutputForm
      elt('ConstructAst::OutputForm,
        ['elements::OutputForm = es])$OutputForm

    renderControl(tag: Symbol, x: List Syntax): OutputForm ==
      elt(tag::OutputForm, 
        ['expression::OutputForm = renderSyntax value x])$OutputForm

    renderRestrictedExpr(tag: Symbol, x: List Syntax): OutputForm ==
      elt(tag::OutputForm,
        ['expression::OutputForm = renderSyntax first x,
           'target::OutputForm = renderSyntax second x])$OutputForm

    renderSegment(x: List Syntax): OutputForm ==
      es := [renderSyntax t for t in x]::List(OutputForm)::OutputForm
      elt('SegmentAst::OutputForm, ['bounds::OutputForm = es])$OutputForm

    renderSequence(x: List Syntax): OutputForm ==
      elts := [renderSyntax t for t in x]
      elt('SequenceAst::OutputForm,
        ['body::OutputForm = elts::OutputForm, 
          'last::OutputForm = last elts])$OutputForm

    renderLet(x: List Syntax): OutputForm ==
      elt('LetAst::OutputForm, 
        ['lhs::OutputForm = renderSyntax first x,
           'rhs::OutputForm = renderSyntax second x])$OutputForm

    renderSuchThat(x: List Syntax): OutputForm ==
      elt('SuchThatAst::OutputForm, 
        ['predicate::OutputForm = renderSyntax first x])$OutputForm

    renderColon(x: List Syntax): OutputForm ==
      elt('ColonAst::OutputForm,
        ['lhs::OutputForm = renderSyntax first x, 
           'rhs::OutputForm = renderSyntax second x])$OutputForm

    renderCapsule(x: List Syntax): OutputForm ==
      elt('CapsuleAst::OutputForm,
        ['body::OutputForm = 
          [renderSyntax s for s in x]::List(OutputForm)::OutputForm])

    renderBinaryExpr(op: Symbol, args: List Syntax): OutputForm ==
      elt(op::OutputForm,
        ['lhs::OutputForm = renderSyntax first args,
          'rhs::OutputForm = renderSyntax second args])$OutputForm

    renderCategory(x: List Syntax): OutputForm ==
      elt('CategoryAst::OutputForm,
        ['kind::OutputForm = renderSyntax first x,
          'body::OutputForm = 
            [renderSyntax s for s in x]::List(OutputForm)::OutputForm])

    renderDefinition(x: List Syntax): OutputForm ==
      elt('DefinitionAst::OutputForm,
        ['head::OutputForm = renderSyntax first x,
          'signature::OutputForm = renderSyntax second x,
            'body::OutputForm = renderSyntax last x])$OutputForm

    renderMacro(x: List Syntax): OutputForm ==
      elt('MacroAst::OutputForm,
        ['head::OutputForm = renderSyntax first x,
          'body::OutputForm = renderSyntax last x])$OutputForm

    renderSyntax x ==
      compound? x =>
        op := getOperator x
        args := getOperands x
        op = 'Mapping => renderMapping args
        op = 'ATTRIBUTE or op = '%Attribute => renderAttribute value args
        op = 'IMPORT or op = '%Import => renderImport args
        op = 'SIGNATURE or op = '%Signature => renderSignature args
        op = 'IF => renderIf args
        op = 'REPEAT => renderRepeat args
        op = 'WHILE => renderWhile args
        op = 'IN => renderIn args
        op = 'COLLECT => renderCollect args
        op = 'construct => renderConstruct args
        op = '_exit => renderControl('ExitAst,args)
        op = '_return => renderControl('ReturnAst,args)
        op = '_:_: => renderRestrictedExpr('CoerceAst,args)
        op = '_pretend => renderRestrictedExpr('PretendAst,args)
        op = '_@ => renderRestrictedExpr('RestrictAst,args)
        op = 'SEGMENT => renderSegment args
        op = 'SEQ => renderSequence args
        op = '%LET => renderLet args
        op = '_| => renderSuchThat args
        op = '_: => renderColon args
        op = 'CAPSULE => renderCapsule args
        op = '_case => renderBinaryExpr('CaseAst, args)
        op = '_has => renderBinaryExpr('HasAst, args)
        op = '_is => renderBinaryExpr('IsAst, args)
        op = 'CATEGORY => renderCategory args
        op = 'DEF => renderDefinition args
        op = 'MDEF => renderMacro args
        x::OutputForm
      x::OutputForm

    coerce(x: %): OutputForm ==
      renderSyntax(x::Syntax)
@

\subsection{The Exports of SpadAst}

<<category SPADXPT SpadAstExports>>=
)abbrev category SPADXPT SpadAstExports
++ Author: Gabriel Dos Reis
++ Date Created: September 20, 2008
++ Date Last Modified: September 21, 2008
++ Description: This category describes the exported
++   signatures of the SpadAst domain.
SpadAstExports(): Category == Join(SpadSyntaxCategory, UnionType) with
   _case: (%, ImportAst()) -> Boolean
    ++ s case ImportAst holds if `s' represents an `import' statement.
  autoCoerce: % -> ImportAst()
    ++ autoCoerce(s) returns the ImportAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, DefinitionAst()) -> Boolean
    ++ s case DefinitionAst holds if `s' represents a definition.
  autoCoerce: % -> DefinitionAst()
    ++ autoCoerce(s) returns the DefinitionAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, MacroAst()) -> Boolean
    ++ s case MacroAst holds if `s' represents a macro definition.
  autoCoerce: % -> MacroAst()
    ++ autoCoerce(s) returns the MacroAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, WhereAst()) -> Boolean
    ++ s case WhereAst holds if `s' represents an expression with
    ++ local definitions.
  autoCoerce: % -> WhereAst()
    ++ autoCoerce(s) returns the WhereAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, CategoryAst()) -> Boolean
    ++ s case CategoryAst holds if `s' represents an unnamed category.
  autoCoerce: % -> CategoryAst()
    ++ autoCoerce(s) returns the CategoryAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, CapsuleAst()) -> Boolean
    ++ s case CapsuleAst holds if `s' represents a domain capsule.
  autoCoerce: % -> CapsuleAst()
    ++ autoCoerce(s) returns the CapsuleAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, SignatureAst()) -> Boolean
    ++ s case SignatureAst holds if `s' represents a signature export.
  autoCoerce: % -> SignatureAst()
    ++ autoCoerce(s) returns the SignatureAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, AttributeAst()) -> Boolean
    ++ s case AttributeAst holds if `s' represents an attribute.
  autoCoerce: % -> AttributeAst()
    ++ autoCoerce(s) returns the AttributeAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, MappingAst()) -> Boolean
    ++ s case MappingAst holds if `s' represents a mapping type.
  autoCoerce: % -> MappingAst()
    ++ autoCoerce(s) returns the MappingAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, IfAst()) -> Boolean
    ++ s case IfAst holds if `s' represents an if-statement.
  autoCoerce: % -> IfAst()
    ++ autoCoerce(s) returns the IfAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, RepeatAst()) -> Boolean
    ++ s case RepeatAst holds if `s' represents an repeat-loop.
  autoCoerce: % -> RepeatAst()
    ++ autoCoerce(s) returns the RepeatAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, WhileAst()) -> Boolean
    ++ s case WhileAst holds if `s' represents a while-iterator
  autoCoerce: % -> WhileAst()
    ++ autoCoerce(s) returns the WhileAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, InAst()) -> Boolean
    ++ s case InAst holds if `s' represents a in-iterator
  autoCoerce: % -> InAst()
    ++ autoCoerce(s) returns the InAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, CollectAst()) -> Boolean
    ++ s case CollectAst holds if `s' represents a list-comprehension.
  autoCoerce: % -> CollectAst()
    ++ autoCoerce(s) returns the CollectAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, ConstructAst()) -> Boolean
    ++ s case ConstructAst holds if `s' represents a list-expression.
  autoCoerce: % -> ConstructAst()
    ++ autoCoerce(s) returns the ConstructAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, ExitAst()) -> Boolean
    ++ s case ExitAst holds if `s' represents an exit-expression.
  autoCoerce: % -> ExitAst()
    ++ autoCoerce(s) returns the ExitAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, ReturnAst()) -> Boolean
    ++ s case ReturnAst holds if `s' represents a return-statement.
  autoCoerce: % -> ReurnAst()
    ++ autoCoerce(s) returns the ReturnAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, CoerceAst()) -> Boolean
    ++ s case ReturnAst holds if `s' represents a coerce-expression.
  autoCoerce: % -> CoerceAst()
    ++ autoCoerce(s) returns the CoerceAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, PretendAst()) -> Boolean
    ++ s case PretendAst holds if `s' represents a pretend-expression.
  autoCoerce: % -> PretendAst()
    ++ autoCoerce(s) returns the PretendAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, RestrictAst()) -> Boolean
    ++ s case RestrictAst holds if `s' represents a restrict-expression.
  autoCoerce: % -> RestrictAst()
    ++ autoCoerce(s) returns the RestrictAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, SegmentAst()) -> Boolean
    ++ s case SegmentAst holds if `s' represents a segment-expression.
  autoCoerce: % -> SegmentAst()
    ++ autoCoerce(s) returns the SegmentAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, SequenceAst()) -> Boolean
    ++ s case SequenceAst holds if `s' represents a sequence-of-statements.
  autoCoerce: % -> SequenceAst()
    ++ autoCoerce(s) returns the SequenceAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, LetAst()) -> Boolean
    ++ s case LetAst holds if `s' represents an assignment-expression.
  autoCoerce: % -> LetAst()
    ++ autoCoerce(s) returns the LetAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, SuchThatAst()) -> Boolean
    ++ s case SuchThatAst holds if `s' represents a qualified-expression.
  autoCoerce: % -> SuchThatAst()
    ++ autoCoerce(s) returns the SuchThatAst view of `s'.  Left at the
    ++ discretion of the compiler.

   _case: (%, ColonAst()) -> Boolean
    ++ s case ColonAst holds if `s' represents a colon-expression.
  autoCoerce: % -> ColonAst()
    ++ autoCoerce(s) returns the ColoonAst view of `s'.  Left at the
    ++ discretion of the compiler.
 
   _case: (%, CaseAst()) -> Boolean
    ++ s case CaseAst holds if `s' represents a case-expression.
  autoCoerce: % -> CaseAst()
    ++ autoCoerce(s) returns the CaseAst view of `s'.  Left at the
    ++ discretion of the compiler.
 
   _case: (%, HasAst()) -> Boolean
    ++ s case HasAst holds if `s' represents a has-expression.
  autoCoerce: % -> HasAst()
    ++ autoCoerce(s) returns the HasAst view of `s'.  Left at the
    ++ discretion of the compiler.
 
   _case: (%, IsAst()) -> Boolean
    ++ s case IsAst holds if `s' represents an is-expression.
  autoCoerce: % -> IsAst()
    ++ autoCoerce(s) returns the IsAst view of `s'.  Left at the
    ++ discretion of the compiler.

@


\subsection{The Literal domain}

<<domain LITERAL Literal>>=
)abbrev domain LITERAL Literal
++ Author: Gabriel Dos Reis
++ Date Created: July 5, 2008
++ Date Last Modified: September 1, 2008
++ Description: This domain represents AST for Spad literals.
Literal(T: SetCategory): Public == Private where
  Public == Join(SpadSyntaxCategory, CoercibleTo T)
  Private == add
    Rep == T
    coerce(x: %): T == rep x
    coerce(x: %): OutputForm == x::T::OutputForm
    
@

\subsection{The Identifier domain}

<<domain IDENT Identifier>>=
++ Author: Gabriel Dos Reis
++ Date Created: July 5, 2008
++ Date Last Modified: September 1, 2008
++ Description: This domain represents identifer AST.
)abbrev domain IDENT Identifier
Identifier(): Public == Private where
  Public == Join(SpadSyntaxCategory, CoercibleTo Symbol)
  Private == add
    Rep == Symbol
    coerce(x: %): Symbol == rep x
    coerce(x: %): OutputForm == x::Symbol::OutputForm

@


\subsection{The HeadAst domain}

<<domain HEADAST HeadAst>>=
import AbstractSyntaxCategory
import Symbol
import List Symbol
)abbrev domain HEADAST HeadAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 3, 2008
++ Description: This domain represents the header of a definition.
HeadAst(): Public == Private where
  Public == SpadSyntaxCategory with
    headAst: (Identifier,List Identifier) -> %
      ++ headAst(f,[x1,..,xn]) constructs a function definition header.
    name: % -> Identifier
      ++ name(h) returns the name of the operation defined defined.
    parameters: % -> List Identifier
      ++ parameters(h) gives the parameters specified in the
      ++ definition header `h'.
  Private == add
    Rep == List Identifier
    headAst(op,args) == per cons(op,args)
    name h == first rep h
    parameters h == rest rep h

@

\subsection{The TypeAst domain}

<<domain TYPEAST TypeAst>>=
import AbstractSyntaxCategory
import Syntax
)abbrev domain TYPEAST TypeAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 28, 2008
++ Description: This domain represents a type AST.
TypeAst(): Public == Private where
  Public == SpadSyntaxCategory with
    coerce: Syntax -> %
      ++ s::TypeAst injects `s' into the TypeAst domain.
  Private == add
    Rep == Syntax
    coerce(x: Syntax): % == per x

@

\subsection{The ImportAst domain}

<<domain IMPTAST ImportAst>>=
import List
import TypeAst
)abbrev domain IMPTAST ImportAst
)abbrev domain TYPEAST TypeAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 28, 2008
++ Description: This domain represents an `import' of types.
ImportAst(): Public == Private where
  Public == SpadSyntaxCategory with
    coerce: List TypeAst -> %
      ++ ts::ImportAst constructs an ImportAst for the list if types `ts'.
    imports: % -> List TypeAst
      ++ imports(x) returns the list of imported types.
  Private == add
    import Pair
    Rep == Pair(Symbol, List TypeAst)
    coerce(ts: List TypeAst): % == per pair('import,ts)
    imports x == second rep x

@

\subsection{The MappingAst domain}

<<domain MAPPAST MappingAst>>=
)abbrev domain MAPPAST MappingAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 28, 2008
++ Description: This domain represents a mapping type AST.  A mapping AST
++   is a syntactic description of a function type, e.g. its result 
++   type and the list of its argument types.
MappingAst(): Public == Private where
  Public == Join(SpadSyntaxCategory, CoercibleTo TypeAst) with
    coerce: Signature -> %
      ++ sig::MappingAst builds a MappingAst from the Signature `sig'.
    mappingAst: (List TypeAst, TypeAst) -> %
      ++ mappingAst(s,t) builds the mapping AST s -> t
    source: % -> List TypeAst
      ++ source(s) returns the parameter type AST list of `s'.
    target: % -> TypeAst
      ++ target(s) returns the result type AST for `s'.
  Private == add
    import Pair
    Rep == Pair(Symbol,Signature)
    coerce(sig: Signature): % == per pair('Mapping,sig)
    mappingAst(s,t) == 
      per pair('Mapping,cons(t,s) : Signature)
    source x == source(second rep x)$Signature : List(TypeAst)
    target x == target(second rep x)$Signature : TypeAst
    coerce(x: %): TypeAst == x : TypeAst

@

\subsection{The SignatureAst domain}

<<domain SIGAST SignatureAst>>=
)abbrev domain SIGAST SignatureAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 28, 2008
++ Description: This domain represents a signature AST.  A signature AST
++   is a description of an exported operation, e.g. its name, result
++   type, and the list of its argument types.
SignatureAst(): Public == Private where
  Public ==  SpadSyntaxCategory with
    signatureAst: (Identifier, Signature) -> %
      ++ signatureAst(n,s,t) builds the signature AST n: s -> t
    name: % -> Symbol
      ++ name(s) returns the name of the signature `s'.
    signature: % -> Signature
      ++ signature(s) returns AST of the declared signature for `s'.
  Private == add
    import List
    Rep == Pair(Symbol, Pair(Symbol,List Signature))
    signatureAst(n,sig) == 
      per pair('SIGNATURE,pair(n,[sig]))
    name x == first second rep x
    signature x == value second second rep x

@


\subsection{The AttributeAst domain}

<<domain ATTRAST AttributeAst>>=
)abbrev domain ATTRAST AttributeAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents the syntax of an attribute in
++   a category expression.
AttributeAst(): Public == Private where
  Public ==  SpadSyntaxCategory with
    name: % -> Syntax
      ++ name(a) returns the name of the attribute `a'.  Note, this
      ++ name may be domain name, not just an identifier. 
  Private == add
    Rep == Pair(Symbol,Syntax)
    name x == second rep x

@

\subsection{The JoinAst domain}

<<domain JOINAST JoinAst>>=
)abbrev domain JOINAST JoinAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents the join of categories ASTs.
JoinAst(): Public == Private where
  Public == Join(SpadSyntaxCategory, CoercibleTo TypeAst) with
    coerce: List TypeAst -> %
      ++ ts::JoinAst construct the AST for a join of the types `ts'.
    categories: % -> List TypeAst
      ++ catehories(x) returns the types in the join `x'.
  Private == add
    Rep == Pair(Symbol, List TypeAst)
    categories x == second rep x
    coerce(cats: List TypeAst): % == per pair('Join,cats)
    coerce(x: %): TypeAst == x : TypeAst

@


\subsection{The IfAst domain}

<<domain IFAST IfAst>>=
)abbrev domain IFAST IfAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents AST for conditional expressions.
IfAst(): Public == Private where
  Public == SpadSyntaxCategory with
    condition: % -> Syntax
      ++ condition(e) returns the condition of the if-expression `e'.
    thenBranch: % -> Syntax
      ++ thenBranch(e) returns the `then-branch' of `e'.
    elseBranch: % -> Syntax
      ++ thenBranch(e) returns the `else-branch' of `e'.
  Private == add
    Rep == List Syntax
    condition x == second rep x
    thenBranch x == third rep x
    elseBranch x == last rep x
@


\subsection{The RepeatAst domain}

<<domain RPTAST RepeatAst>>=
)abbrev domain RPTAST RepeatAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents the `repeat' iterator syntax.
RepeatAst(): Public == Private where
  Public == SpadSyntaxCategory with
    iterators: % -> List Syntax
      ++ iterators(e) returns the list of iterators controlling the loop `e'.
    body: % -> Syntax
      ++ body(e) returns the body of the loop `e'.
  Private == add
    Rep == List Syntax
    iterators x == 
      s := rep x
      s.(2..(#s - 1))

    body x == last rep x
  
@

\subsection{The WhileAst domain}

<<domain WHILEAST WhileAst>>=
)abbrev domain WHILEAST WhileAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents the `while' iterator syntax.
WhileAst(): Public == Private where
  Public == SpadSyntaxCategory with
    condition: % -> Syntax
      ++ condition(i) returns the condition of the while iterator `i'.
  Private == add
    Rep == Pair(Symbol,Syntax)
    condition x == second rep x

@

\subsection{The InAst domain}

<<domain INAST InAst>>=
)abbrev domain INAST InAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents the `in' iterator syntax.
InAst(): Public == Private where
  Public == SpadSyntaxCategory with
    iterationVar: % -> Symbol
      ++ iterationVar(i) returns the name of the iterating 
      ++ variable of the `in' iterator 'i'
    sequence: % -> Syntax
      ++ sequence(i) returns the sequence expression being 
      ++ iterated over by `i'.
  Private == add
    Rep == List Syntax
    iterationVar x == (second rep x)::Symbol
    sequence x == last rep x
@

\subsection{The CollectAst domain}

<<domain CLLCTAST CollectAst>>=
)abbrev domain CLLCTAST CollectAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents list comprehension syntax.
CollectAst(): Public == Private where
  Public == SpadSyntaxCategory with
    iterators: % -> List Syntax
      ++ iterators(e) returns the list of the iterators of
      ++ the list comprehension `e'.
    body: % -> Syntax
      ++ body(e) return the expression being
      ++ collected by the list comprehension `e'.
  Private == add
    Rep == List Syntax
    body x == last rep x
    iterators x ==
      s := rep x
      s.(2..(#s -1))

@


\subsection{The ReduceAst domain}

<<domain RDUCEAST ReduceAst>>=
)abbrev domain RDUCEAST ReduceAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents list reduction syntax.
ReduceAst(): Public == Private where
  Public == SpadSyntaxCategory with
    operator: % -> Syntax
      ++ operator(e) returns the magma operation being applied.
    body: % -> Syntax
      ++ body(e) return the list of expressions being redcued.
  Private == add
    Rep == List Syntax
    operator x == second rep x
    body x == third rep x

@

\subsection{The ConstructAst domain}

<<domain LSTAST ConstructAst>>=
)abbrev domain LSTAST ConstructAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents `literal sequence' syntax.
ConstructAst(): Public == Private where
  Public == SpadSyntaxCategory with
    elements: % -> List Syntax
      ++ elements(e) returns the list of expressions in the
      ++ `literal' list `e'.
  Private == add
    import Pair
    Rep == Pair(Symbol, List Syntax)
    elements x == second rep x

@


\subsection{The ExitAst domain}

<<domain EXITAST ExitAst>>=
)abbrev domain EXITAST ExitAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents exit expressions.
ExitAst(): Public == Private where
  Public == SpadSyntaxCategory with
    expression: % -> Syntax
      ++ expression(e) returns the exit expression of `e'.
    level: % -> Integer
      ++ level(e) returns the nesting exit level of `e'
  Private == add
    Rep == List Syntax
    expression x == third rep x
    level x == (second rep x) : Integer
@


\subsection{The ReturnAst domain}

<<domain RETAST ReturnAst>>=
)abbrev domain RETAST ReturnAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents `return' expressions.
ReturnAst(): Public == Private where
  Public == SpadSyntaxCategory with
    expression: % -> Syntax
      ++ expression(e) returns the expression returned by `e'.
  Private == add
    import Pair
    Rep == Pair(Symbol,Syntax)
    expression x == second rep x

@

\subsection{The SequenceAst domain}

<<domain SEQAST SequenceAst>>=
)abbrev domain SEQAST SequenceAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents a block of expressions.
SequenceAst(): Public == Private where
  Public == SpadSyntaxCategory with
    body: % -> List Syntax
      ++ body(e) returns the list of expressions in the sequence
      ++ of instruction `e'.
    last: % -> Syntax
      ++ last(e) returns the last instruction in `e'.
  Private == add
    import Pair
    Rep == Pair(Symbol,List Syntax)
    body x == second rep x
    last x == last(second rep x)$List(Syntax)
@

\subsection{The LetAst domain}

<<domain LETAST LetAst>>=
import Syntax
import List
)abbrev domain LETAST LetAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents assignment expressions.
LetAst(): Public == Private where
  Public == SpadSyntaxCategory with
    lhs: % -> Syntax
      ++ lhs(e) returns the left hand side of the assignment expression `e'.
    rhs: % -> Syntax
      ++ rhs(e) returns the right hand side of the assignment expression `e'.
  Private == add
    Rep == List Syntax
    lhs x == second rep x
    rhs x == third rep x

@

\subsection{The PretendAst domain}

<<domain PRTDAST PretendAst>>=
)abbrev domain PRTDAST PretendAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents `pretend' expressions.
PretendAst(): Public == Private where
  Public == SpadSyntaxCategory with
    expression: % -> Syntax
      ++ expression(e) returns the expression being converted.
    target: % -> TypeAst
      ++ target(e) returns the target type of the conversion..
  Private == add
    Rep == List Syntax
    expression x == second rep x
    target x == (third rep x) : TypeAst

@

\subsection{The CoerceAst domain}

<<domain CRCEAST CoercedAst>>=
)abbrev domain CRCEAST CoerceAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents `coerce' expressions.
CoerceAst(): Public == Private where
  Public == SpadSyntaxCategory with
    expression: % -> Syntax
      ++ expression(e) returns the expression being converted.
    target: % -> TypeAst
      ++ target(e) returns the target type of the conversion..
  Private == add
    Rep == List Syntax
    expression x == second rep x
    target x == (third rep x) : TypeAst

@


\subsection{The RestrictAst domain}

<<domain RSTRCAST RestrictAst>>=
)abbrev domain RSTRCAST RestrictAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents `restrict' expressions.
RestrictAst(): Public == Private where
  Public == SpadSyntaxCategory with
    expression: % -> Syntax
      ++ expression(e) returns the expression being converted.
    target: % -> TypeAst
      ++ target(e) returns the target type of the conversion..
  Private == add
    Rep == List Syntax
    expression x == second rep x
    target x == (third rep x) : TypeAst

@

\subsection{The CallAst domain}

<<domain CALLAST CallAst>>=
import Syntax
import List
)abbrev domain CALLAST CallAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: August 30, 2008
++ Description: This domain represents calls.
CallAst(): Public == Private where
  Public == SpadSyntaxCategory with
    operator: % -> Syntax
      ++ operation(e) returns the operation being called in `e'.
    operands: % -> List Syntax
      ++ arguments(e) returns the argument list used in the call `e'.
  Private == add
    Rep == List Syntax
    operator x == first rep x
    operands x == rest rep x

@

\subsection{The SegmentAst domain}

<<domain SEGAST SegmentAst>>=
)abbrev domain SEGAST SegmentAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents segement expressions.
SegmentAst(): Public == Private where
  Public == SpadSyntaxCategory with
    bounds: % -> List Syntax
      ++ bounds(s) returns the bounds of the segment `s'.  If
      ++ `s' designates an infinite interval, then the returns
      ++ list a singleton list.
  Private == add
    Rep == List Syntax
    bounds x == rest rep x

@


\subsection{The SuchThatAst domain}

<<domain SUCHTAST SuchThatAst>>=
)abbrev domain SUCHTAST SuchThatAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents the filter iterator syntax.
SuchThatAst(): Public == Private where
  Public == SpadSyntaxCategory with
    predicate: % -> Syntax
      ++ predicate(e) returns the syntax object for the predicate
      ++ in the filter iterator syntax `e'.
  Private == add
    Rep == List Syntax
    predicate e == second rep x
@

\subsection{The ColonAst domain}

<<domain COLONAST ColonAst>>=
)abbrev domain COLONAST ColonAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents type specification 
++   for an identifier or expression.
ColonAst(): Public == Private where
  Public == SpadSyntaxCategory with
    lhs: % -> Syntax
      ++ lhs(e) returns the left hand side of the colon expression `e'.
    rhs: % -> TypeAst
      ++ rhs(e) returns the right hand side of the colon expression `e'.
  Private == add
    Rep == List Syntax
    lhs x == second rep x
    rhs x == (third rep x) : TypeAst
@

\subsection{The AddAst domain}

<<domain ADDAST AddAst>>=
)abbrev domain ADDAST AddAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents the syntax for an add-expression.
AddAst(): Public == Private where
  Public == SpadSyntaxCategory with
    base: % -> Syntax
      ++ base(d) returns the base domain(s) of the add-domain expression.
    body: % -> Syntax
      ++ base(d) returns the actual body of the add-domain expression `d'.
  Private == add
    Rep == List Syntax
    base x == second rep x
    body x == third rep x
@


\subsection{The CapsuleAst domain}

<<domain CAPSLAST CapsuleAst>>=
)abbrev domain CAPSLAST CapsuleAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents the capsule of a domain definition.
CapsuleAst(): Public == Private where
  Public == SpadSyntaxCategory with
    body: % -> List Syntax
      ++ body(c) returns the list of top level expressions appearing in `c'.
  Private == add
    Rep == Pair(Symbol, List Syntax)
    body x == second rep x
@

\subsection{The CaseAst domain}

<<domain CASEAST CaseAst>>=
)abbrev domain CASEAST CaseAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents a `case' expression.
CaseAst(): Public == Private where
  Public == SpadSyntaxCategory with
    lhs: % -> Syntax
      ++ lhs(e) returns the left hand side of the case expression `e'.
    rhs: % -> Syntax
      ++ rhs(e) returns the right hand side of the case expression `e'.
  Private == add
    Rep == List Syntax
    lhs x == second rep x
    rhs x == third rep x
@


\subsection{The HasAst domain}

<<domain HASAST HasAst>>=
)abbrev domain HASAST HasAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents a `has' expression.
HasAst(): Public == Private where
  Public == SpadSyntaxCategory with
    lhs: % -> Syntax
      ++ lhs(e) returns the left hand side of the has expression `e'.
    rhs: % -> Syntax
      ++ rhs(e) returns the right hand side of the case expression `e'.
  Private == add
    Rep == List Syntax
    lhs x == second rep x
    rhs x == third rep x
@

\subsection{The IsAst domain}

<<domain ISAST IsAst>>=
)abbrev domain ISAST IsAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents a `has' expression.
IsAst(): Public == Private where
  Public == SpadSyntaxCategory with
    lhs: % -> Syntax
      ++ lhs(e) returns the left hand side of the is expression `e'.
    rhs: % -> Syntax
      ++ rhs(e) returns the right hand side of the is expression `e'.
  Private == add
    Rep == List Syntax
    lhs x == second rep x
    rhs x == third rep x
@

\subsection{The CategoryAst domain}

<<domain CATAST CategoryAst>>=
)abbrev domain CATAST CategoryAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 17, 2008
++ Description: This domain represents the unnamed category defined
++   by a list of exported signatures
CategoryAst(): Public == Private where
  Public == SpadSyntaxCategory with
    kind: % -> Symbol
      ++ kind(c) returns the kind of unnamed category, either
      ++ 'domain' or 'package'.
    body: % -> List Syntax
      ++ body(c) returns the list of exports in category syntax `c'.
  Private == add
    Rep == List Syntax
    kind x == second rep x
    body x == rest rest rep x
@

\subsection{The WhereAst domain}

<<domain WHEREAST WhereAst>>=
)abbrev domain WHEREAST WhereAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 18, 2008
++ Description: This domain represents the syntax of a `where' expression.
WhereAst(): Public == Private where
  Public == SpadSyntaxCategory with
    mainExpression: % -> Syntax
      ++ mainExpression(e) returns the main expression of the 
      ++ `where' expression `e'.
    qualifier: % -> Syntax
      ++ qualifier(e) returns the qualifier of the expression `e'.
  Private == add
    Rep == List Syntax
    mainExpression x == second rep x
    qualifier x == third rep x
@

\subsection{The CommaAst domain}

<<domain COMMAAST CommaAst>>=
)abbrev domain COMMAAST CommaAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 18, 2008
++ Description: This domain represents the syntax of a comma-separated
++   list of expressions.
CommaAst(): Public == Private where
  Public == SpadSyntaxCategory with
    body: % -> List Syntax
      ++ body(e) returns the list of expressions making up `e'.
  Private == add
    Rep == List Syntax
    body x == rest rep x
@


\subsection{The QuasiquoteAst domain}

<<domain QQUTAST QuasiquoteAst>>=
)abbrev domain QQUTAST QuasiquoteAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 18, 2008
++ Description: This domain represents the syntax of a quasiquote
++   expression.
QuasiquoteAst(): Public == Private where
  Public == SpadSyntaxCategory with
    expression: % -> Syntax
      ++ expression(e) returns the syntax for the expression being quoted.
  Private == add
    Rep == List Syntax
    expression x == second rep x
@


\subsection{The DefinitionAst domain}

<<domain DEFAST DefinitionAst>>=
)abbrev domain DEFAST DefinitionAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 18, 2008
++ Description: This domain represents the syntax of a definition.
DefinitionAst(): Public == Private where
  Public == SpadSyntaxCategory with
    head: % -> List Identifier
      ++ head(d) returns the head of the definition `d'.  This is a 
      ++ list of identifiers starting with the name of the operation
      ++ followed by the name of the parameters, if any.
    signature: % -> Signature
      ++ signature(d) returns the signature of the operation being
      ++ defined.  Note that this list may be partial in that it
      ++ contains only the types actually specified in the definition.
    body: % -> Syntax
      ++ body(d) returns the right hand side of the definition `d'.
  Private == add
    Rep == List Syntax
    head x == (second rep x) : List Identifier
    signature x == (third rep x) : Signature
    body x == last rep x

@


\subsection{The MacroAst domain}

<<domain MACROAST MacroAst>>=
)abbrev domain MACROAST MacroAst
++ Author: Gabriel Dos Reis
++ Date Created: November 10, 2007
++ Date Last Modified: September 18, 2008
++ Description: This domain represents the syntax of a macro definition.
MacroAst(): Public == Private where
  Public == SpadSyntaxCategory with
    head: % -> List Identifier
      ++ head(m) returns the head of the macro definition `m'.  This is a 
      ++ list of identifiers starting with the name of the macro
      ++ followed by the name of the parameters, if any.
    body: % -> Syntax
      ++ body(m) returns the right hand side of the definition `m'.
  Private == add
    Rep == List Syntax
    head x == (second rep x) : List Identifier
    body x == last rep x

@


\section{License}

<<license>>=
--Copyright (C) 2007-2008, Gabriel Dos Reis.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical Algorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@

<<*>>=
<<license>>
<<domain SYNTAX Syntax>>
<<domain SIG Signature>>
<<domain CTORCALL ConstructorCall>>
<<domain ELABEXPR ElaboratedExpression>>

<<category ASTCAT AbstractSyntaxCategory>>
<<category SASTCAT SpadSyntaxCategory>>
<<category SPADXPT SpadAstExports>>

<<domain LITERAL Literal>>
<<domain HEADAST HeadAst>>
<<domain TYPEAST TypeAst>>
<<domain ATTRAST AttributeAst>>
<<domain IMPTAST ImportAst>>
<<domain MAPPAST MappingAst>>
<<domain SIGAST SignatureAst>>
<<domain JOINAST JoinAst>>

<<domain IFAST IfAst>>
<<domain RPTAST RepeatAst>>
<<domain WHILEAST WhileAst>>
<<domain INAST InAst>>
<<domain CLLCTAST CollectAst>>
<<domain LSTAST ConstructAst>>
<<domain EXITAST ExitAst>>
<<domain RETAST ReturnAst>>
<<domain SEGAST SegmentAst>>
<<domain SEQAST SequenceAst>>
<<domain PRTDAST PretendAst>>
<<domain CRCEAST CoercedAst>>
<<domain RSTRCAST RestrictAst>>
<<domain LETAST LetAst>>

<<domain RDUCEAST ReduceAst>>
<<domain SUCHTAST SuchThatAst>>
<<domain COLONAST ColonAst>>
<<domain ADDAST AddAst>>
<<domain CAPSLAST CapsuleAst>>
<<domain CASEAST CaseAst>>
<<domain HASAST HasAst>>
<<domain ISAST IsAst>>
<<domain CATAST CategoryAst>>
<<domain WHEREAST WhereAst>>
<<domain COMMAAST CommaAst>>
<<domain QQUTAST QuasiquoteAst>>
<<domain DEFAST DefinitionAst>>
<<domain MACROAST MacroAst>>

@

\end{document}
