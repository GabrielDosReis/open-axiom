%% Oh Emacs, this is a -*- Makefile -*-, so give me tabs.
\documentclass{article}
\usepackage{axiom}

\title{\File{src/interp/Makefile} Pamphlet}
\author{Timothy Daly \and Gabriel Dos~Reis}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents
\eject

\section{The Environment}

We define 3 directories for this build. The first two are
the traditional {\bf IN}, which is where the source pamphlets are,
and {\bf OUT} which is where we will put the binaries.

In this case the {\bf IN} files are usually written in Boot \cite{2}.
These will be compiled in a \Tool{bootsys} image to translate from
Boot to Common Lisp. 

\subsection{Documentation}

The dvi files will be generated from the pamphlet files in the
final ship \File{doc/src/} directory. Since they are system independent 
but machine generated and part of the final ship they will exist 
in the [[\$(axiom_target_docdir)/src/interp/]] directory.

<<environment>>=
IN=$(srcdir)
DOC=$(axiom_target_docdir)/src/interp
BOOK=$(axiom_target_docdir)
@


\subsection{Autloload}

In order to minimize the size of the OpenAxiom image at load time
we put some of the compiled files into a separate directory
that will be autoloaded on demand. This directory of code
will be shipped with the final system and so it belongs in
the [[$(axiom_targetdir)]] subtree.
<<environment>>=
AUTO=$(axiom_targetdir)/autoload

autoload_objects =

@


\subsection{Initial Lisp image}

We need a raw Lisp image --- running on the build platform ---
that we can use as a base to construct
the other images. This is called {\bf LISPSYS} and is located in the
build platform sub-directory.
<<environment>>=
# Build platform-dependent Lisp image, at the base of other
# derived Lisp images (interpsys, AXIOMsys)
LISPSYS= $(axiom_build_bindir)/lisp

@

\subsection{Boot translator}

Most of the interpreter is written in the Boot programming language. 
Thus we need a program to translate Boot to Common
Lisp.  That program is called the {\bf BOOTSYS} image (because the
translator is written in {\bf boot} and needs to translate
itself to bootstrap the system).  This image is assumed to
have been built (on the build platform) by a previous step in the
make process.
<<environment>>=
BOOTSYS= $(axiom_target_bindir)/bootsys -- --syslib=$(axiom_target_libdir)

@


The {\bf SAVESYS} image is copied to the [[$(axiom_target_bindir)]]
subdirectory and becomes the axiom executable image.  Technically, that is
not right because the host plaform may not be the same as the build
platform.  However, we don't yet support cross compilation, so that
is alright for the time being.
<<environment>>=
SAVESYS= interpsys$(EXEEXT)
AXIOMSYS= $(axiom_target_bindir)/AXIOMsys$(EXEEXT)

@


\subsection{The Spad interpreter and compiler}

<<environment>>=
OBJS=	types.$(FASLEXT)	sys-os.$(FASLEXT) \
	vmlisp.$(FASLEXT)	hash.$(FASLEXT)	\
	diagnostics.$(FASLEXT)	sys-driver.$(FASLEXT) \
	sys-utility.$(FASLEXT)  macros.$(FASLEXT)	\
	unlisp.$(FASLEXT)	\
	astr.$(FASLEXT)	bits.$(FASLEXT)	\
	alql.$(FASLEXT)	buildom.$(FASLEXT)	\
	cattable.$(FASLEXT)				\
	cformat.$(FASLEXT)	cfuns.$(FASLEXT)	\
	clam.$(FASLEXT)	clammed.$(FASLEXT)	\
	comp.$(FASLEXT)	        foam_l.$(FASLEXT) \
	compat.$(FASLEXT)	compress.$(FASLEXT)	\
	cparse.$(FASLEXT)	cstream.$(FASLEXT)	\
	database.$(FASLEXT)	\
	debug.$(FASLEXT)	dq.$(FASLEXT)		\
	fname.$(FASLEXT)	format.$(FASLEXT)	\
	g-boot.$(FASLEXT)	g-cndata.$(FASLEXT)	\
	g-error.$(FASLEXT)	g-opt.$(FASLEXT)	\
	g-timer.$(FASLEXT)	g-util.$(FASLEXT)	\
	ggreater.$(FASLEXT)				\
	hypertex.$(FASLEXT)	i-analy.$(FASLEXT)	\
	i-object.$(FASLEXT)				\
	i-code.$(FASLEXT)	i-coerce.$(FASLEXT)	\
	i-coerfn.$(FASLEXT)	i-eval.$(FASLEXT)	\
	i-funsel.$(FASLEXT)	\
	i-intern.$(FASLEXT)	i-map.$(FASLEXT)	\
	i-output.$(FASLEXT)	i-resolv.$(FASLEXT)	\
	i-spec1.$(FASLEXT)				\
	i-spec2.$(FASLEXT)	i-syscmd.$(FASLEXT)	\
	i-toplev.$(FASLEXT)	i-util.$(FASLEXT)	\
	incl.$(FASLEXT)	int-top.$(FASLEXT)	\
	intfile.$(FASLEXT)				\
	lisplib.$(FASLEXT)	macex.$(FASLEXT)	\
	match.$(FASLEXT)				\
	monitor.$(FASLEXT)	msg.$(FASLEXT)		\
	msgdb.$(FASLEXT)	\
	newaux.$(FASLEXT)	newfort.$(FASLEXT)	\
	nlib.$(FASLEXT)	nrunfast.$(FASLEXT)	\
	nrungo.$(FASLEXT)	nrunopt.$(FASLEXT)	\
	osyscmd.$(FASLEXT)	\
	packtran.$(FASLEXT)	pathname.$(FASLEXT)	\
	pf2sex.$(FASLEXT)	pile.$(FASLEXT)	\
	posit.$(FASLEXT)	property.$(FASLEXT)	\
	ptrees.$(FASLEXT)	spad-parser.$(FASLEXT) \
	record.$(FASLEXT)				\
	rulesets.$(FASLEXT)	\
	scan.$(FASLEXT)	serror.$(FASLEXT)	\
	server.$(FASLEXT)				\
	setvars.$(FASLEXT)	\
	sfsfun-l.$(FASLEXT)	sfsfun.$(FASLEXT)	\
	simpbool.$(FASLEXT)	slam.$(FASLEXT)	\
	spad.$(FASLEXT)	\
	spaderror.$(FASLEXT)				\
	template.$(FASLEXT)	termrw.$(FASLEXT)	\
	trace.$(FASLEXT)	\
	union.$(FASLEXT)       daase.$(FASLEXT)  	\
	fortcall.$(FASLEXT) \
	$(OPOBJS) \
	$(OCOBJS) \
	$(BROBJS) i-parser.$(FASLEXT)

interpsys_modules = $(patsubst %.$(FASLEXT), "%", $(OBJS))
@

Before we save the {\bf SAVESYS} image we need to run some
initialization code. These files perform initialization
for various parts of the system. The {\bf patches.lisp} \cite{5}
file contains last-minute changes to various functions and
constants.
<<environment>>=
INOBJS=	setvart.$(FASLEXT)\
        interop.$(FASLEXT)     \
        patches.$(FASLEXT)

IN_modules = $(patsubst %.$(FASLEXT), "%", $(INOBJS))

@

Certain functions do not need to be in the running system.
If the running image never calls the compiler or does not
use the hypertex browser we will never call the functions
in these files. The code that calls these functions in the
running system will autoload the appropriate files the
first time they are called. Loading the files overwrites
the autoload function call and re-calls the function. 
Any subsequent calls will run the compiled code.

The {\bf OPOBJS} list contains files from the old parser. The use of
``old'' is something of a subtle concept as there were several
generations of ``old'' and all meaning of the term is lost.

Notice that the object file [[def.$(FASLEXT)]] appears on both the
[[OPBJS]] and [[TRANOBJS]] lists.  In normal situation, parsing 
precedes translation; consequently the file [[def]] is loaded by the 
parser, so that it does not need to be reloaded by the translator. 
However, it may theoretically be that a translation could happen without 
prior parsing (in case someone types in a parse tree for SPAD code).  
Consequently, it must be ensured that [[def.]] is still loaded in that
configuration.  In the long term, the autoload machinery need
rethinking.

<<environment>>=
# These are autloaded old parser files
OPOBJS=	parsing.$(FASLEXT)	bootlex.$(FASLEXT)	\
        def.$(FASLEXT)	\
	fnewmeta.$(FASLEXT)	metalex.$(FASLEXT)	\
	parse.$(FASLEXT)	postpar.$(FASLEXT)	\
	preparse.$(FASLEXT)

autoload_objects += $(OPBJS)
@

The {\bf OCOBJS} list contains files from the old compiler. Again,
``old'' is meaningless. These files should probably be autoloaded.
<<environment>>=
OCOBJS=	apply.$(FASLEXT)	c-doc.$(FASLEXT)	\
	c-util.$(FASLEXT)	profile.$(FASLEXT)	\
	category.$(FASLEXT)	compiler.$(FASLEXT)	\
	define.$(FASLEXT)	functor.$(FASLEXT)	\
	info.$(FASLEXT)	iterator.$(FASLEXT)	\
	modemap.$(FASLEXT)	nruncomp.$(FASLEXT)	\
	package.$(FASLEXT)	htcheck.$(FASLEXT)

autoload_objects += $(OCOBJS)

@

The {\bf BROBJS} list contains files only used by the hypertex
browser. These files should probably be autoloaded.
<<environment>>=
BROBJS=	bc-matrix.$(FASLEXT)				\
	bc-misc.$(FASLEXT)	bc-solve.$(FASLEXT)	\
	bc-util.$(FASLEXT)				\
	ht-util.$(FASLEXT)	htsetvar.$(FASLEXT)	\
	ht-root.$(FASLEXT)	\
	br-con.$(FASLEXT)	\
	br-data.$(FASLEXT)	showimp.$(FASLEXT)    \
	br-op1.$(FASLEXT)	br-op2.$(FASLEXT)	\
	br-search.$(FASLEXT)	br-util.$(FASLEXT)	\
	topics.$(FASLEXT)     br-prof.$(FASLEXT)    \
	br-saturn.$(FASLEXT)

autoload_objects += $(BFOBJS)

@

The {\bf TRANOBJS} list contains files used by Spad to Aldor convertor.
The files probably are also used by the {\bf boot}
to Common Lisp translator and are probably never used by anyone
but the developers.

When a user requests converting a file from Spad to Aldor the
function
[[spad2AsTranslatorAutoloadOnceTrigger]] is called triggering
load of this group of files. Loading [[$TRANOBJS]] in turn replaces
many compiler functions by versions contain in this files.
 These files should probably be autoloaded
(at least [[${AUTO}/wi1.$(FASLEXT)]] and [[${AUTO}/wi2.$(FASLEXT)]]
(which replace compiler functions) {\em must} be autoloaded).
<<environment>>=
TRANOBJS= ${AUTO}/wi1.$(FASLEXT) ${AUTO}/wi2.$(FASLEXT) ${AUTO}/pspad1.$(FASLEXT) \
	  ${AUTO}/pspad2.$(FASLEXT) ${AUTO}/mark.$(FASLEXT) ${AUTO}/nspadaux.$(FASLEXT) \
	  ${AUTO}/def.$(FASLEXT)

autoload_objects += $(TRANOBJS)

@

The {\bf ASCOMP} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files should probably be autoloaded.
<<environment>>=
ASCOMP= hashcode.$(FASLEXT) as.$(FASLEXT) \
	foam_l.$(FASLEXT) axext_l.$(FASLEXT)

AS_modules = $(patsubst %.$(FASLEXT), "%", $(ASCOMP))

@

The {\bf ASAUTO} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files are autoloaded as needed.
<<environment>>=
ASAUTO= ${AUTO}/ax.$(FASLEXT)

autoload_objects += $(ASAUTO)
@

OpenAxiom versions are given as a string of the form:
"Sunday September 21, 2003 at 20:38:05 "
which describe the day, date, and time of the build.
This is used for reporting bugs. It is only partially useful
in identifying which source code was used. Ideally we could create
a tar file of all of the date/time stamps of all of the source files
and use the MD5 hash of that file as the version stamp. Ultimately
though, this would be chasing the elusive "perfect information" idea.

A new variable [[boot::*build-version*]] is set here and used by the
[[yearweek]] function to display the version number of the OpenAxiom build.
This information is set by hand in the top level Makefile.
<<environment>>=
TIMESTAMP=$(axiom_targetdir)/timestamp
YEARWEEK=(progn (defconstant boot::timestamp "${TIMESTAMP}") \
                (setq boot::*build-version* "$(PACKAGE_STRING)") \
                (boot::yearweek))

@

The {\bf .PRECIOUS} setting will keep make from deleting these
images if the build is stopped. Since once they are built they
are likely to be useable we don't need to redo the work if they
exist.
<<environment>>=

.PRECIOUS:	${SAVESYS}
.PRECIOUS:	${AXIOMSYS}

@

\section{The warm.data file}

This is a file of commands that will be loaded into interpsys
at the last minute. It execute functions that will likely be
used in a running system so all of the required routines will
be in the lisp image thus minimizing their startup time.
<<warm.data.stanza>>=
../algebra/warm.data: $(srcdir)/Makefile.pamphlet
	@ echo 2 building warm.data
	$(axiom_build_document) --tangle=warm.data --output=$@ $<

@

<<warm.data>>=
(in-package "BOOT")
(defparameter |$topicHash| (make-hash-table))
(setf (gethash '|basic| |$topicHash|) 2)
(setf (gethash '|algebraic| |$topicHash|) 4)
(setf (gethash '|miscellaneous| |$topicHash|) 13)
(setf (gethash '|extraction| |$topicHash|) 6)
(setf (gethash '|conversion| |$topicHash|) 7)
(setf (gethash '|hidden| |$topicHash|) 3)
(setf (gethash '|extended| |$topicHash|) 1)
(setf (gethash '|destructive| |$topicHash|) 5)
(setf (gethash '|transformation| |$topicHash|) 10)
(setf (gethash '|hyperbolic| |$topicHash|) 12)
(setf (gethash '|construct| |$topicHash|) 9)
(setf (gethash '|predicate| |$topicHash|) 8)
(setf (gethash '|trignometric| |$topicHash|) 11)

@

\section{UNUSED}

These files were in the interp distribution from NAG but have
no purpose at the moment. This belief is no doubt due to my
lack of understanding. Rather than erase them they are documented
here for future reference. 
<<environment>>=
UNUSED= ${DOC}/construc.lisp.dvi \
	${DOC}/domain.lisp.dvi 	${DOC}/guess.boot.dvi \
	${DOC}/interp-fix.boot.dvi \
	${DOC}/nhyper.boot.dvi ${DOC}/pf2atree.boot.dvi \
	${DOC}/redefs.boot.dvi 	${DOC}/word.boot.dvi 

@


\section{Building SAVESYS and AXIOMSYS}

GCL likes to tell you when it has replaced a function call by a 
tail-recursive call. This happens when the last form in a function
is a call to the same function. In general, we don't care so we set
compiler::*suppress-compiler-notes* to true in order to reduce the noise.

Notice that when OpenAxiom uses GCL as the Lisp platform, it is usually not 
a good idea to mess with GCL's internal variables.  In particular, GCL
has its own idea about what to do with [[si::*system-directory*]], which 
should not be set here just because we happen to save an GCL-based image.
Doing otherwise causes havoc.

<<savesys>>=
makeint.lisp:	${OBJS} util.$(FASLEXT) \
		sys-driver.$(FASLEXT) \
	        ${OUTINTERP} obey.$(FASLEXT) \
		database.date ${INOBJS} ${ASCOMP} ${ASAUTO} \
		${TRANOBJS} \
		$(axiom_targetdir)/algebra/exposed.$(FASLEXT) \
		$(axiom_src_docdir)/msgs/s2-us.msgs \
	        ../algebra/warm.data
	@ echo 5 invoking make in `pwd` with parms:
	@rm -f makeint.lisp
	$(mkinstalldirs) $(axiom_target_datadir)/msgs
	$(INSTALL_DATA) $(axiom_src_docdir)/msgs/s2-us.msgs \
		 $(axiom_target_datadir)/msgs
	@ echo '(|importModule| "sys-driver")' >> makeint.lisp
	@ echo '(|importModule| "vmlisp")' >> makeint.lisp
	@ echo '(|importModule| "hash")' >> makeint.lisp
	@ echo '#+:GCL (gbc t)' >> makeint.lisp
	@ echo '(|importModule| "util")' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ touch ${TIMESTAMP}
	@ echo '${YEARWEEK}' >> makeint.lisp
	@ echo '(boot::build-interpsys (append (quote ($(interpsys_modules))) (quote ($(AS_modules))) (quote ($(IN_modules))))  (quote ($(patsubst %, "%", ${TRANOBJS}))) (quote ($(patsubst %, "%", ${ASAUTO}))))' >> makeint.lisp
	@ echo '(boot::set-restart-hook)' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ echo '(load "../algebra/warm.data")' >> makeint.lisp
	@ echo '(boot::|clearClams|)' >> makeint.lisp
	@ echo '(load "obey")' >> makeint.lisp
	@ echo '#+:akcl (setq compiler::*suppress-compiler-notes* t)' >> makeint.lisp
	@ echo '#+:akcl (si::gbc-time 0)' >> makeint.lisp
	@ echo '#+:GCL (gbc t)' >> makeint.lisp

${SAVESYS}: makeint.lisp
	$(BOOTSYS) -- --system="$(AXIOM)/" \
		--sysalg="$(axiom_src_datadir)/algebra/" \
		--make --output=$@ --main="BOOT::|restart|" \
		--load-directory=. makeint.lisp
	@ echo 6 ${SAVESYS} created
	$(mkinstalldirs) $(axiom_target_bindir)
@

\section{Building SAVESYS and AXIOMSYS}

We want to cache database data in the final image, so we dump it only
after databases are build.
Note that having dependency on databases is not enough, since databases
are re-generated after leaving \File{interp/} directory.

<<axiomsys>>=
.PHONY: all-axiomsys

all-axiomsys: ${AXIOMSYS}

${AXIOMSYS}: makeint.lisp
	$(BOOTSYS) -- \
		--system="$(AXIOM)/" \
		--sysalg="$(axiom_targetdir)/algebra/" \
		--make --output=$@ --main="BOOT::|restart|" \
		--load-directory=. makeint.lisp
	@ echo 6a ${AXIOMSYS} created
@

\section{The Interpreter files}

\subsection{DVI files from pmaphlet files}

<<DVI from pamphlet>>=
$(axiom_build_texdir)/diagrams.tex: $(axiom_src_docdir)/diagrams.tex
	$(INSTALL_DATA) $< $@
@

\section{The databases}

\begin{verbatim}
 autoload dependencies

 if you are adding a file which is to be autoloaded the following step
 information is useful:
  there are 2 cases:
   1) adding files to currently autoloaded parts
      (as of 2/92: browser old parser and old compiler)
   2) adding new files
   case 1:
     a) you have to add the file to the list of files currently there
        (e.g. see BROBJS above)
     b) add an autolaod rule
        (e.g. ${AUTO}/parsing.$(FASLEXT): parsing.$(FASLEXT))
     c) edit util.lisp to add the 'external' function (those that
        should trigger the autoload
   case 2:
     build-interpsys (in util.lisp) needs an extra argument for the
     new autoload things and several functions in util.lisp need hacking.

 database.date is a marker file used to force a rebuild of interpsys if the
 database is rebuilt (src/algebra/Makefile).

\end{verbatim}
<<databases>>=
exposed.lsp: $(axiom_src_algdir)/exposed.lsp.pamphlet
	@ echo 615 making exposed.lsp from $(axiom_src_algdir)/exposed.lsp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<

$(axiom_targetdir)/algebra/exposed.$(FASLEXT) : exposed.lsp ${LISPSYS}
	@ echo 616 making $@ from exposed.lsp
	$(mkinstalldirs) $(axiom_targetdir)/algebra
	$(BOOTSYS) --compile --output=$@ --load-directory=. $<

database.date:
	@ echo 617 the database was updated...remaking interpsys
	@ touch database.date

@

\section{The Makefile}
<<*>>=

subdir = src/interp/

<<environment>>

.SUFFIXES:
.SUFFIXES: .boot .clisp .lisp .pamphlet

.PHONY: all all-ax all-interpsys all-axiomsys

all: all-ax

all-ax: stamp
	@echo finished $(srcdir)

stamp: $(AUTO) remove-stamp build-images
	$(STAMP) stamp

.PHONY: remove-stamp
remove-stamp:
	-rm -f stamp

.PHONY: build-images
build-images: remove-stamp all-interpsys

all-interpsys:
	$(mkinstalldirs) $(AUTO)
	$(MAKE) $(SAVESYS)

all-axiomsys: all-interpsys
	$(MAKE) $(AXIOMSYS)

mostlyclean-local:
	@rm -f *.fn *.data *.$(FASLEXT) *.lib

clean-local: mostlyclean-local
	@rm -f *.clisp *.lsp

distclean-local: clean-local

<<savesys>>
<<axiomsys>>
<<databases>>

## Copy FASLs that are autoloaded to the autoload directory.
.PREVIOUS: $(AUTO)/%.$(FASLEXT)

$(AUTO)/%.$(FASLEXT): %.$(FASLEXT)
	$(INSTALL) $< $@

%.$(FASLEXT): %.boot
	$(BOOTSYS) --compile --output=$@ --load-directory=. $<

%.$(FASLEXT): %.lisp
	$(BOOTSYS) --compile --output=$@ --load-directory=. $<

## Translation to Fortran
fortcall.$(FASLEXT): sys-macros.$(FASLEXT)

## HyperDoc
topics.$(FASLEXT): macros.$(FASLEXT)
alql.$(FASLEXT): br-search.$(FASLEXT)
br-search.$(FASLEXT): bc-util.$(FASLEXT)
br-saturn.$(FASLEXT): bc-util.$(FASLEXT)
br-op2.$(FASLEXT): br-op1.$(FASLEXT)
br-op1.$(FASLEXT): bc-util.$(FASLEXT)
br-con.$(FASLEXT): bc-util.$(FASLEXT)
br-prof.$(FASLEXT): bc-util.$(FASLEXT)
br-data.$(FASLEXT): bc-util.$(FASLEXT)
br-util.$(FASLEXT): bc-util.$(FASLEXT)
bc-solve.$(FASLEXT): bc-matrix.$(FASLEXT)
bc-matrix.$(FASLEXT): bc-util.$(FASLEXT)
bc-misc.$(FASLEXT): bc-util.$(FASLEXT)
bc-util.$(FASLEXT): ht-util.$(FASLEXT)
ht-root.$(FASLEXT): ht-util.$(FASLEXT)
htcheck.$(FASLEXT): sys-driver.$(FASLEXT) macros.$(FASLEXT)
ht-util.$(FASLEXT): macros.$(FASLEXT)
htsetvar.$(FASLEXT): macros.$(FASLEXT)
hypertex.$(FASLEXT): types.$(FASLEXT)

## OpenAxiom's interpreter.
patches.$(FASLEXT): macros.$(FASLEXT) g-timer.$(FASLEXT) sys-driver.$(FASLEXT)
setvars.$(FASLEXT): macros.$(FASLEXT) debug.$(FASLEXT)
profile.$(FASLEXT): macros.$(FASLEXT)
rulesets.$(FASLEXT): vmlisp.$(FASLEXT)
osyscmd.$(FASLEXT): int-top.$(FASLEXT)
int-top.$(FASLEXT): incl.$(FASLEXT) i-toplev.$(FASLEXT) unlisp.$(FASLEXT)
i-toplev.$(FASLEXT): i-analy.$(FASLEXT)
i-syscmd.$(FASLEXT): i-object.$(FASLEXT)
i-output.$(FASLEXT): sys-macros.$(FASLEXT)
i-spec2.$(FASLEXT): i-spec1.$(FASLEXT)
i-spec1.$(FASLEXT): i-analy.$(FASLEXT)
i-funsel.$(FASLEXT): i-coerfn.$(FASLEXT)
i-map.$(FASLEXT): i-object.$(FASLEXT)
i-eval.$(FASLEXT): i-analy.$(FASLEXT)
i-coerfn.$(FASLEXT): i-coerce.$(FASLEXT)
i-coerce.$(FASLEXT): i-analy.$(FASLEXT) i-resolv.$(FASLEXT)
i-resolv.$(FASLEXT): i-object.$(FASLEXT)
i-analy.$(FASLEXT): i-object.$(FASLEXT)
i-intern.$(FASLEXT): i-object.$(FASLEXT) ptrees.$(FASLEXT)
i-code.$(FASLEXT): i-object.$(FASLEXT)
i-object.$(FASLEXT): g-util.$(FASLEXT)
i-util.$(FASLEXT): g-util.$(FASLEXT)
format.$(FASLEXT): macros.$(FASLEXT)
match.$(FASLEXT): sys-macros.$(FASLEXT)
record.$(FASLEXT): nlib.$(FASLEXT) pathname.$(FASLEXT)
setvart.$(FASLEXT): macros.$(FASLEXT)

## OpenAxiom's compiler
wi2.$(FASLEXT): macros.$(FASLEXT) define.$(FASLEXT)
wi1.$(FASLEXT): macros.$(FASLEXT)
apply.$(FASLEXT): compiler.$(FASLEXT)
compiler.$(FASLEXT): c-util.$(FASLEXT) modemap.$(FASLEXT) \
		pathname.$(FASLEXT) define.$(FASLEXT) iterator.$(FASLEXT)
nrunopt.$(FASLEXT): c-util.$(FASLEXT)
nrunfast.$(FASLEXT): c-util.$(FASLEXT)
nruncomp.$(FASLEXT): c-util.$(FASLEXT)
nrungo.$(FASLEXT): c-util.$(FASLEXT)
template.$(FASLEXT): c-util.$(FASLEXT)
iterator.$(FASLEXT): g-util.$(FASLEXT)
define.$(FASLEXT): cattable.$(FASLEXT) category.$(FASLEXT) c-util.$(FASLEXT)
package.$(FASLEXT): clam.$(FASLEXT)
database.$(FASLEXT): clam.$(FASLEXT) nlib.$(FASLEXT) \
		cattable.$(FASLEXT) compat.$(FASLEXT) g-cndata.$(FASLEXT)
functor.$(FASLEXT): category.$(FASLEXT) c-util.$(FASLEXT)
category.$(FASLEXT): g-util.$(FASLEXT)
cattable.$(FASLEXT): simpbool.$(FASLEXT) g-util.$(FASLEXT)
compat.$(FASLEXT): pathname.$(FASLEXT)
simpbool.$(FASLEXT): macros.$(FASLEXT)
newfort.$(FASLEXT): macros.$(FASLEXT)
lisplib.$(FASLEXT): nlib.$(FASLEXT) c-util.$(FASLEXT) debug.$(FASLEXT)
interop.$(FASLEXT): interop.boot c-util.$(FASLEXT)
c-doc.$(FASLEXT): c-util.$(FASLEXT)

## Interface with the Aldor compiler.
ax.$(FASLEXT): as.$(FASLEXT)
as.$(FASLEXT): macros.$(FASLEXT)
server.$(FASLEXT): macros.$(FASLEXT)

##
## OpenAxiom's front-end consists of two parts:
##    (a) the interprerter's parser -- also referred to as new parser
##    (b) the compiler parser -- also referred to as parser
##
## The new parser component is always included in a running OpenAxiom
## image.  However the old parser component is so called `autoloaded'.
## While in theory that should work, in practice it turns out that 
## people tend to override functions in the autoload part, correcting
## bugs only there.  The consequence is that the same function will
## bahave very differently based on the history of the seesion.  Ideal
## recipe for creating heisenbugs.
##

## The old parser component roughtly is:
##
spad-parser.$(FASLEXT): parse.$(FASLEXT)
mark.$(FASLEXT): macros.$(FASLEXT)
parse.$(FASLEXT): metalex.$(FASLEXT) postpar.$(FASLEXT)
packtran.$(FASLEXT): sys-macros.$(FASLEXT)
postpar.$(FASLEXT): macros.$(FASLEXT)
bootlex.$(FASLEXT): preparse.$(FASLEXT) def.$(FASLEXT) \
			nlib.$(FASLEXT) sys-globals.$(FASLEXT)
newaux.$(FASLEXT): macros.$(FASLEXT)
def.$(FASLEXT): macros.$(FASLEXT)
comp.$(FASLEXT): macros.$(FASLEXT)
preparse.$(FASLEXT): fnewmeta.$(FASLEXT)
fnewmeta.$(FASLEXT): parsing.$(FASLEXT)
parsing.$(FASLEXT): metalex.$(FASLEXT)
metalex.$(FASLEXT): macros.$(FASLEXT)
nlib.$(FASLEXT): macros.$(FASLEXT)
macros.$(FASLEXT): sys-macros.$(FASLEXT) sys-utility.$(FASLEXT)

## The new parser component roughtly is:
##   astr.boot dq.boot incl.boot pile.boot ptrees.boot
##   posit.boot cparse.boot format.boot cstream.boot
##
i-parser.$(FASLEXT): cparse.$(FASLEXT) pf2sex.$(FASLEXT)
pf2sex.$(FASLEXT): ptrees.$(FASLEXT)
cparse.$(FASLEXT): ptrees.$(FASLEXT)
macex.$(FASLEXT): ptrees.$(FASLEXT)
ptrees.$(FASLEXT): posit.$(FASLEXT) serror.$(FASLEXT)
pile.$(FASLEXT): scan.$(FASLEXT)
scan.$(FASLEXT): incl.$(FASLEXT) bits.$(FASLEXT) dq.$(FASLEXT)
incl.$(FASLEXT): cstream.$(FASLEXT) cformat.$(FASLEXT)
cformat.$(FASLEXT): unlisp.$(FASLEXT) posit.$(FASLEXT)
serror.$(FASLEXT): posit.$(FASLEXT)
unlisp.$(FASLEXT): sys-macros.$(FASLEXT)
posit.$(FASLEXT): sys-macros.$(FASLEXT) astr.$(FASLEXT)
intfile.$(FASLEXT): cstream.$(FASLEXT)
cstream.$(FASLEXT): sys-macros.$(FASLEXT)
astr.$(FASLEXT): vmlisp.$(FASLEXT)
bits.$(FASLEXT): boot-pkg.$(FASLEXT)
dq.$(FASLEXT): types.$(FASLEXT)

## General support and utilities.
cfuns.$(FASLEXT): boot-pkg.$(FASLEXT)
obey.$(FASLEXT): macros.$(FASLEXT)
daase.$(FASLEXT): macros.$(FASLEXT) foam_l.$(FASLEXT)
spaderror.$(FASLEXT): macros.$(FASLEXT)
debug.$(FASLEXT): macros.$(FASLEXT) parsing.$(FASLEXT)
spad.$(FASLEXT): bootlex.$(FASLEXT) postpar.$(FASLEXT) debug.$(FASLEXT)
monitor.$(FASLEXT): macros.$(FASLEXT)
property.$(FASLEXT): sys-macros.$(FASLEXT)
nspadaux.$(FASLEXT): sys-macros.$(FASLEXT)
sfsfun-l.$(FASLEXT): sys-macros.$(FASLEXT)
trace.$(FASLEXT): debug.$(FASLEXT)
termrw.$(FASLEXT): macros.$(FASLEXT)
showimp.$(FASLEXT): macros.$(FASLEXT)
sfsfun.$(FASLEXT): macros.$(FASLEXT)
modemap.$(FASLEXT): c-util.$(FASLEXT) info.$(FASLEXT)
info.$(FASLEXT): g-util.$(FASLEXT)
slam.$(FASLEXT): g-timer.$(FASLEXT)
clammed.$(FASLEXT): g-timer.$(FASLEXT)
clam.$(FASLEXT): g-timer.$(FASLEXT)
g-opt.$(FASLEXT): def.$(FASLEXT)
g-timer.$(FASLEXT): macros.$(FASLEXT) g-util.$(FASLEXT)
msgdb.$(FASLEXT): g-util.$(FASLEXT)
g-boot.$(FASLEXT): def.$(FASLEXT) g-util.$(FASLEXT)
g-error.$(FASLEXT): diagnostics.$(FASLEXT) g-util.$(FASLEXT)
c-util.$(FASLEXT): g-util.$(FASLEXT)
pathname.$(FASLEXT): nlib.$(FASLEXT)
hashcode.$(FASLEXT): g-util.$(FASLEXT)
pspad2.$(FASLEXT): pspad1.$(FASLEXT)
pspad1.$(FASLEXT): macros.$(FASLEXT)
g-util.$(FASLEXT): macros.$(FASLEXT) sys-utility.$(FASLEXT)
g-cndata.$(FASLEXT): sys-macros.$(FASLEXT)
compress.$(FASLEXT): sys-macros.$(FASLEXT)
msg.$(FASLEXT): sys-macros.$(FASLEXT) astr.$(FASLEXT)
util.$(FASLEXT): parsing.$(FASLEXT)
fname.$(FASLEXT): macros.$(FASLEXT)
sys-macros.$(FASLEXT): diagnostics.$(FASLEXT) union.$(FASLEXT)
buildom.$(FASLEXT): buildom.boot sys-macros.$(FASLEXT)
diagnostics.$(FASLEXT): sys-globals.$(FASLEXT) vmlisp.$(FASLEXT)
sys-driver.$(FASLEXT): sys-driver.boot types.$(FASLEXT)
sys-globals.$(FASLEXT): sys-constants.$(FASLEXT) hash.$(FASLEXT)
sys-constants.$(FASLEXT): types.$(FASLEXT)
hash.$(FASLEXT): types.$(FASLEXT)
union.$(FASLEXT): vmlisp.$(FASLEXT)
ggreater.$(FASLEXT): vmlisp.$(FASLEXT)
axext_l.$(FASLEXT): foam_l.$(FASLEXT)
foam_l.$(FASLEXT): vmlisp.$(FASLEXT)
sys-utility.$(FASLEXT): vmlisp.$(FASLEXT) sys-os.$(FASLEXT)
vmlisp.$(FASLEXT): types.$(FASLEXT) sys-globals.$(FASLEXT)
sys-os.$(FASLEXT): types.$(FASLEXT) cfuns.$(FASLEXT) 
types.$(FASLEXT): boot-pkg.$(FASLEXT)
boot-pkg.$(FASLEXT): boot-pkg.lisp

<<warm.data.stanza>>

<<DVI from pamphlet>>

@

\end{document}
