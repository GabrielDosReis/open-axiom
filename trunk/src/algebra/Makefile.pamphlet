%% Oh Emacs, this is a -*- Makefile -*-, so give me tabs.
\documentclass{article}
\usepackage{axiom}

\title{\$SPAD/src/algebra Makefile}
\author{Timothy Daly \and Gabriel Dos~Reis}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}
\eject

\tableofcontents
\eject

\section{Adding new algebra}

This is a complex process by its very nature. Developers and Maintainers
who undertake the process need to understand quite a lot of detail. The
ultimate steps to add algebra are tedious but simple. Note that only
algebra code that gets shipped with the system needs to undergo this
process. User code can be compiled once the distributed algebra exists
and does not need either this Makefile or this installation process.

NOTE: If you add new algebra to this file you must also update

\File{src/algebra/exposed.lsp.pamphlet}

otherwise the new algebra won't be loaded by the interpreter when needed.

Since understanding is the key to making correct changes to this file
I'll work on explaining the details of why things need to exist. 

The first idea that you need to understand is the overall process
of adding algebra code. Lets assume that you have a brand new spad
file, called \File{foo.spad} containing a simple domain [[BAR]]. The
steps in the process of adding this file are:
\begin{enumerate}
\item Find out where the algebra code lives in the lattice.

You do this by 
\begin{enumerate}
\item starting a new interpsys session
\item collecting all the names of the algebra files BAR requires
\item determining which layer each of the required files resides
\item determine the highest layer (e.g. 14) that contains the required files
\end{enumerate}

\item insert the documentation into the next layer (e.g. 15)
\item insert the [[\${OUT}/BAR.$(FASLEXT)]] file into the layer's file list
\end{enumerate}

\section{Rebuilding the algebra from scratch}

Compile order is important. Here we try to define the ordered lattice
of spad file dependencies. However this is, in reality, a graph rather
than a lattice. In order to break cycles in this graph we explicitly
cache a few of the intermediate generated lisp code for certain files.
These are marked throughout (both here and in the various pamphlet
files) with the word {\bf BOOTSTRAP}.

If we take a cycle such as [[RING]] we discover that in order to
compile the spad code we must load the compiled definition of [[RING]].
In this case we must compile the cached lisp code before we try to 
compile the spad file.

It is highly recommended that you try to become a developer of Axiom
and read the archived mailing lists before you decide to change a
cached file. In the fullness of time we will rewrite the whole algebra
structure into a proper lattice if possible. Alternatively we'll
reimplement the compiler to handle graphs. Or deeply adopt the
extensible domains. Whatever we do will be much discussed (and cause
much disgust) around the campfire. If you come up with a brilliant
plan that gets adopted we'll even inscribe your name on a log and add
it to the fire.

In the code that follows we find the categories, packages and domains
that compile with no dependencies and call this set ``layer 0''. Next
we find the categories, packages and domains that will compile using
only ``layer 0'' code and call this ``layer 1''. We walk up the
lattice in this fashion adding layers. Note that at layer 3 this
process runs into cycles and we create the ``layer 3 bootstrap''
stanzas before continuing upward.

\section{The Algebra Lattice Layers}

\subsection{Layer 0 Bootstrap}

\subsubsection{Completed spad files}

\begin{verbatim}
si.spad.pamphlet (INS SINT)
\end{verbatim}

Note well that none of the algebra stanzas should include these
files in the preconditions otherwise we have an infinite compile
loop. These files are originally bootstrapped from lisp code
when we build the system for the first time but they are
forcibly recompiled at the end of the build so they reflect
current code (just in case someone changes the spad code but
does not re-cache the generated lisp). If you add these files
as preconditions (note that they are all in the \File{strap/}
directory rather than the {\bf OUT} directory like everything
else) then the final recompile will invalidate all of the
rest of the algebra targets which will get rebuilt again causing
these targets to be out of date. The rest of the loop is left
up to the student.

The bootstrap process works because first we ask for the compiled
lisp code stanzas (the \File{strap/BAR.$(FASLEXT)} files), THEN we ask for
the final algebra code stanzas (the [[\${OUT}/BAR.$(FASLEXT)]] files). This
is a very subtle point so think it through carefully. Notice that
this is the only layer calling for \File{strap/} files. All other 
layers call for [[\${OUT}]] files. If you break this the world
will no longer compile so don't change it if you don't understand it.

\begin{verbatim}
LAYER0BOOTSTRAP=${OUT}/XPR.$(FASLEXT) 
\end{verbatim}

<<layer0 bootstrap>>=
# The list of objects necessary to bootstrap the whole algebra library.
axiom_algebra_layer_strap = \
	$(addprefix strap/,$(axiom_algebra_bootstrap))

axiom_algebra_layer_strap_objects = \
	$(addsuffix .$(FASLEXT),$(axiom_algebra_layer_strap))

@
<<layer0 copy>>=

axiom_algebra_bootstrap = \
  ABELGRP  ABELGRP- ABELMON  ABELMON- \
  ABELSG   ABELSG-  ALAGG    BOOLEAN  \
  CABMON   CHAR     CLAGG    CLAGG-   \
  COMRING  DFLOAT   DIFRING  DIFRING- \
  DIVRING  DIVRING- ENTIRER           \
           EUCDOM   EUCDOM-  FFIELDC  \
  FFIELDC- FPS      FPS-     GCDDOM   \
  GCDDOM-  HOAGG    HOAGG-   ILIST    \
  INS      INS-     INT      INTDOM   \
  INTDOM-  ISTRING  LIST     LNAGG    \
  LNAGG-   LSAGG    LSAGG-   MONOID   \
  MONOID-  MTSCAT   NNI      OINTDOM  \
  ORDRING  ORDRING- OUTFORM  PI       \
           POLYCAT  POLYCAT-          \
           QFCAT    QFCAT-   RCAGG    \
  RCAGG-            RING     RING-    \
  RNG      RNS      RNS-     SETAGG   \
  SETAGG-                    SINT     \
  STAGG    STAGG-   SYMBOL            \
           UFD      UFD-              \
                    URAGG    URAGG-   \
  VECTOR

axiom_algebra_bootstrap_last_layer = \
           DFLOAT                     \
  DIVRING  DIVRING-                   \
           EUCDOM   EUCDOM-  FFIELDC  \
  FFIELDC- FPS      FPS-              \
  INS      INS-     INT               \
           MTSCAT   NNI               \
                    OUTFORM  PI       \
           POLYCAT  POLYCAT-          \
           QFCAT    QFCAT-            \
           RNS      RNS-              \
                             SINT     \
                    SYMBOL            \
  VECTOR


axiom_algebra_bootstrap_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_bootstrap))

axiom_algebra_bootstrap_last_layer_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT), $(axiom_algebra_bootstrap_last_layer)))

@

\subsection{Layer 0}

<<layer0>>=

$(OUT)/IEVALAB.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/EVALAB.$(FASLEXT): $(OUT)/IEVALAB.$(FASLEXT)
$(OUT)/ELTAB.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)

$(OUT)/UTYPE.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/AHYP.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/PRIMCAT.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/ATTREG.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/CONDUIT.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/CFCAT.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)



$(OUT)/AGG.$(FASLEXT) $(OUT)/AGG-.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/ELTAGG.$(FASLEXT): $(OUT)/AGG.$(FASLEXT) $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/IXAGG.$(FASLEXT): $(OUT)/ELTAGG.$(FASLEXT) $(OUT)/EVALAB.$(FASLEXT)
$(OUT)/RCAGG.$(FASLEXT): $(OUT)/EVALAB.$(FASLEXT) $(OUT)/SETCAT.$(FASLEXT) \
	$(OUT)/AGG.$(FASLEXT)
$(OUT)/QUAGG.$(FASLEXT): $(OUT)/BGAGG.$(FASLEXT)
$(OUT)/SKAGG.$(FASLEXT): $(OUT)/BGAGG.$(FASLEXT)
$(OUT)/DQAGG.$(FASLEXT): $(OUT)/QUAGG.$(FASLEXT) $(OUT)/SKAGG.$(FASLEXT)
$(OUT)/PRQAGG.$(FASLEXT): $(OUT)/BGAGG.$(FASLEXT)
#$(OUT)/DLAGG.$(FASLEXT): $(OUT)/RCAGG.$(FASLEXT)
#$(OUT)/URAGG.$(FASLEXT): $(OUT)/RCAGG.$(FASLEXT)
#$(OUT)/BRAGG.$(FASLEXT): $(OUT)/RCAGG.$(FASLEXT)
$(OUT)/FLAGG.$(FASLEXT): $(OUT)/BMODULE.$(FASLEXT) $(OUT)/PID.$(FASLEXT) \
	$(OUT)/OAGROUP.$(FASLEXT) $(OUT)/RETRACT.$(FASLEXT) \
	$(OUT)/LINEXP.$(FASLEXT) $(OUT)/PATMAB.$(FASLEXT) \
	$(OUT)/REAL.$(FASLEXT) $(OUT)/CHARZ.$(FASLEXT)
$(OUT)/A1AGG.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT) $(OUT)/LOGIC.$(FASLEXT) \
	$(OUT)/FLAGG.$(FASLEXT) $(OUT)/LOGIC-.$(FASLEXT)
$(OUT)/SRAGG.$(FASLEXT): $(OUT)/A1AGG.$(FASLEXT)
$(OUT)/ISTRING.$(FASLEXT): $(OUT)/SRAGG.$(FASLEXT)
$(OUT)/STAGG.$(FASLEXT): $(OUT)/URAGG.$(FASLEXT) $(OUT)/LNAGG.$(FASLEXT)
$(OUT)/SETAGG.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT) $(OUT)/CLAGG.$(FASLEXT)
$(OUT)/STRICAT.$(FASLEXT): $(OUT)/SRAGG.$(FASLEXT)
$(OUT)/STRING.$(FASLEXT): $(OUT)/STRICAT.$(FASLEXT) $(OUT)/ORDFIN.$(FASLEXT)
$(OUT)/DIOPS.$(FASLEXT): $(OUT)/STRING.$(FASLEXT)
$(OUT)/DIAGG.$(FASLEXT): $(OUT)/DIOPS.$(FASLEXT)
$(OUT)/KDAGG.$(FASLEXT): $(OUT)/DIAGG.$(FASLEXT)
$(OUT)/TBAGG.$(FASLEXT): $(OUT)/KDAGG.$(FASLEXT)
$(OUT)/ALAGG.$(FASLEXT): $(OUT)/TBAGG.$(FASLEXT)
$(OUT)/ILIST.$(FASLEXT): $(OUT)/LSAGG.$(FASLEXT)
$(OUT)/LIST.$(FASLEXT): $(OUT)/ILIST.$(FASLEXT)

$(OUT)/MSYSCMD.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)

$(OUT)/KOERCE.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/KRCFROM.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)

$(OUT)/KONVERT.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/KVTFROM.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)

$(OUT)/RETRACT.$(FASLEXT): $(OUT)/KRCFROM.$(FASLEXT)

$(OUT)/BASTYPE.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/SETCAT.$(FASLEXT) $(OUT)/SETCAT-.$(FASLEXT): $(OUT)/BASTYPE.$(FASLEXT)

$(OUT)/FINITE.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/ORDSET.$(FASLEXT) $(OUT)/ORDSET-.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/FILECAT.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/SEXCAT.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/STEP.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/PATMAB.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/REAL.$(FASLEXT): $(OUT)/KONVERT.$(FASLEXT)

$(OUT)/LOGIC.$(FASLEXT): $(OUT)/BASTYPE.$(FASLEXT)


$(OUT)/SGROUP.$(FASLEXT) $(OUT)/SGROUP-.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/ABELSG.$(FASLEXT) $(OUT)/ABELSG-.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/LMODULE.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/RMODULE.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/BMODULE.$(FASLEXT): $(OUT)/LMODULE.$(FASLEXT) \
	$(OUT)/RMODULE.$(FASLEXT) $(OUT)/SGROUP.$(FASLEXT)
$(OUT)/MODULE.$(FASLEXT): $(OUT)/BMODULE.$(FASLEXT)
$(OUT)/ALGEBRA.$(FASLEXT): $(OUT)/MODULE.$(FASLEXT)
$(OUT)/OAGROUP.$(FASLEXT): $(OUT)/OCAMON.$(FASLEXT)
$(OUT)/OCAMON.$(FASLEXT): $(OUT)/OAMON.$(FASLEXT)
$(OUT)/OAMON.$(FASLEXT): $(OUT)/OASGP.$(FASLEXT)
$(OUT)/OASGP.$(FASLEXT): $(OUT)/ORDSET.$(FASLEXT) $(OUT)/ABELSG.$(FASLEXT)
$(OUT)/RNG.$(FASLEXT): $(OUT)/SGROUP.$(FASLEXT)

$(OUT)/CTORKIND.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/IOMODE.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)

$(OUT)/REF.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT) $(OUT)/IDENT.$(FASLEXT)
$(OUT)/PRINT.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/RTVALUE.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)

axiom_algebra_layer_0 = \
  AHYP     ATTREG   CFCAT    ELTAB    KOERCE   KONVERT  \
  KRCFROM  KVTFROM  IEVALAB  IEVALAB- EVALAB   EVALAB-  \
  RETRACT  RETRACT- SETCAT   SETCAT-                    \
  MSYSCMD  FINITE   OM       OMCONN   OMDEV    OUT      \
  PRIMCAT  PRINT    PTRANFN  SPFCAT   TYPE     UTYPE    \
  BMODULE           BASTYPE  BASTYPE- STEP     LMODULE  \
  RMODULE  ALGEBRA  ALGEBRA- SGROUP   SGROUP-  ABELSG   \
  ABELSG-  ORDSET   ORDSET-  OASGP    FILECAT  SEXCAT   \
  MODULE   MODULE-  PID      OAGROUP  OCAMON   OAMON    \
  RNG      ORDFIN                                       \
  MKBCFUNC MKRECORD MKUCFUNC DROPT1   PLOT1    ITFUN2   \
  ITFUN3   STREAM1  STREAM2  STREAM3  ANY1     SEGBIND2 \
  COMBOPC  EQ2      NONE1    CONDUIT  IOMODE   CTORKIND \
  AGG      AGG-     ELTAGG   ELTAGG-  IXAGG    IXAGG-   \
  BGAGG    BGAGG-   BRAGG    BRAGG-   ELAGG    ELAGG-   \
  DLAGG    DQAGG    QUAGG    SKAGG    PRQAGG   ALAGG    \
  FLAGG    FLAGG-   URAGG    URAGG-   LNAGG    LNAGG-   \
  A1AGG    A1AGG-   LSAGG    LSAGG-   SRAGG    SRAGG-   \
  FSAGG    FSAGG-   STAGG    STAGG-   CLAGG    CLAGG-   \
  RCAGG    RCAGG-   SETAGG   SETAGG-  HOAGG    HOAGG-   \
  TBAGG    TBAGG-   KDAGG    KDAGG-   DIAGG    DIAGG-   \
  DIOPS    DIOPS-   STRING   STRICAT  ISTRING  ILIST    \
  LIST                                                  \
  LINEXP   PATMAB   REAL     CHARZ    LOGIC    LOGIC-   \
  RTVALUE

axiom_algebra_layer_0_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_0))

axiom_algebra_layer_0_objects = \
	$(addprefix $(OUT)/, \
           $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_0)))
@

\subsection{Layer 1}

<<layer1>>=

$(OUT)/HOMOTOP.$(FASLEXT): $(OUT)/KOERCE.$(FASLEXT) $(OUT)/KRCFROM.$(FASLEXT)
$(OUT)/ITUPLE.$(FASLEXT): $(OUT)/KOERCE.$(FASLEXT)
$(OUT)/PATAB.$(FASLEXT): $(OUT)/KOERCE.$(FASLEXT)
$(OUT)/PPCURVE.$(FASLEXT): $(OUT)/KOERCE.$(FASLEXT)
$(OUT)/PSCURVE.$(FASLEXT): $(OUT)/KOERCE.$(FASLEXT)

$(OUT)/IEVALAB.$(FASLEXT) $(OUT)/IEVALAB-.$(FASLEXT): \
	$(OUT)/SETCAT.$(FASLEXT)
$(OUT)/EVALAB.$(FASLEXT) $(OUT)/EVALAB-.$(FASLEXT): \
	$(OUT)/IEVALAB.$(FASLEXT)

$(OUT)/PROPLOG.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)

$(OUT)/MAYBE.$(FASLEXT): $(OUT)/KOERCE.$(FASLEXT) $(OUT)/RETRACT.$(FASLEXT)

$(OUT)/BYTEORD.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)

$(OUT)/RING.$(FASLEXT): $(OUT)/RNG.$(FASLEXT) $(OUT)/MONOID.$(FASLEXT) \
	$(OUT)/LMODULE.$(FASLEXT) $(OUT)/KOERCE.$(FASLEXT)
$(OUT)/MONOID.$(FASLEXT): $(OUT)/SGROUP.$(FASLEXT)
$(OUT)/ABELGRP.$(FASLEXT): $(OUT)/CABMON.$(FASLEXT)
$(OUT)/ABELMON.$(FASLEXT): $(OUT)/ABELSG.$(FASLEXT)
$(OUT)/ORDRING.$(FASLEXT): $(OUT)/OAGROUP.$(FASLEXT) $(OUT)/RING.$(FASLEXT) \
	$(OUT)/MONOID.$(FASLEXT)
$(OUT)/COMRING.$(FASLEXT): $(OUT)/RING.$(FASLEXT) $(OUT)/BMODULE.$(FASLEXT)
$(OUT)/DIFRING.$(FASLEXT): $(OUT)/RING.$(FASLEXT)
$(OUT)/ENTIRER.$(FASLEXT): $(OUT)/RING.$(FASLEXT) $(OUT)/BMODULE.$(FASLEXT)
$(OUT)/INTDOM.$(FASLEXT): $(OUT)/COMRING.$(FASLEXT) $(OUT)/ALGEBRA.$(FASLEXT) \
	$(OUT)/ENTIRER.$(FASLEXT) $(OUT)/FIELD.$(FASLEXT)
$(OUT)/OINTDOM.$(FASLEXT): $(OUT)/INTDOM.$(FASLEXT) $(OUT)/ORDRING.$(FASLEXT)
$(OUT)/GCDDOM.$(FASLEXT): $(OUT)/INTDOM.$(FASLEXT)
$(OUT)/UFD.$(FASLEXT): $(OUT)/GCDDOM.$(FASLEXT) $(OUT)/ES.$(FASLEXT)
$(OUT)/ES.$(FASLEXT): $(OUT)/RING.$(FASLEXT) $(OUT)/CACHSET.$(FASLEXT) \
	$(OUT)/REF.$(FASLEXT) $(OUT)/ALIST.$(FASLEXT) \
	$(OUT)/PATAB.$(FASLEXT)
$(OUT)/CACHSET.$(FASLEXT): $(OUT)/ORDSET.$(FASLEXT)
$(OUT)/ALIST.$(FASLEXT): $(OUT)/ALAGG.$(FASLEXT)
$(OUT)/PATAB.$(FASLEXT): $(OUT)/TYPE.$(FASLEXT)
$(OUT)/BOOLEAN.$(FASLEXT): $(OUT)/PROPLOG.$(FASLEXT)
$(OUT)/ES.$(FASLEXT): $(OUT)/PRIMARR.$(FASLEXT)
$(OUT)/VECTCAT.$(FASLEXT): $(OUT)/RADCAT.$(FASLEXT)
$(OUT)/IARRAY1.$(FASLEXT): $(OUT)/PRIMARR.$(FASLEXT)
$(OUT)/PROPERTY.$(FASLEXT): $(OUT)/IDENT.$(FASLEXT)
$(OUT)/BINDING.$(FASLEXT): $(OUT)/PROPERTY.$(FASLEXT)

axiom_algebra_layer_1 = \
  ABELGRP  ABELGRP- ABELMON  ABELMON- FORTCAT   ITUPLE   \
  CABMON   MONOID   MONOID-  RING     RING-     COMRING  \
  DIFRING  DIFRING- ENTIRER  INTDOM   INTDOM-   OINTDOM  \
  GCDDOM   GCDDOM-  UFD      UFD-     ES        ES-      \
  PATAB    PPCURVE  PSCURVE  CACHSET  RESLATC   REF      \
  IDENT    SEGCAT   BINDING  ALIST    BOOLEAN   PRIMARR  \
  ORDRING  ORDRING-          FEVALAB  FEVALAB-           \
  OSGROUP  MAYBE    DATAARY  PROPLOG  HOMOTOP   BYTEORD  \
  FIELD    FIELD-   VECTCAT  VECTCAT- IARRAY1            \
  PROPERTY

axiom_algebra_layer_1_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_1))

axiom_algebra_layer_1_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_1)))
@

\subsection{Layer 2}

<<layer2>>=
axiom_algebra_layer_2 = \
  SYNTAX  INTRET   SEGXCAT CONTOUR  LIST3   MKFUNC   \
          KTVLOGIC FNCAT

$(OUT)/FNCAT.$(FASLEXT): $(OUT)/HOMOTOP.$(FASLEXT) $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/SYNTAX.$(FASLEXT): $(OUT)/IDENT.$(FASLEXT)
$(OUT/KTVLOGIC.$(FASLEXT): $(OUT)/PROPLOG.$(FASLEXT)


axiom_algebra_layer_2_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_2))

axiom_algebra_layer_2_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_2)))
@

\subsection{Layer 3}

<<layer3>>=
axiom_algebra_layer_3 = \
   GRDEF     SCOPE    MAPHACK1 MAPHACK2 MAPHACK3 MAPPKG1  \
   MAPPKG2   MAPPKG3  INTBIT   MONAD    MONAD-   


$(OUT)/MONAD.$(FASLEXT): $(OUT)/SETCAT.$(FASLEXT)
$(OUT)/SCOPE.$(FASLEXT): $(OUT)/BINDING.$(FASLEXT)

axiom_algebra_layer_3_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_3))

axiom_algebra_layer_3_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_3)))
@

\subsubsection{Completed spad files}

<<layer4>>=

$(OUT)/ENV.$(FASLEXT): $(OUT)/SCOPE.$(FASLEXT)


axiom_algebra_layer_4 = \
  ANON              COMM     COMPPROP ESCONT1  EXIT     \
  FAMONC   FORMULA1 IDPC              NONE     NUMINT   \
  ODECAT            OMENC    ONECOMP2 OPTCAT            \
  PALETTE  PARPCURV PARPC2   PARSCURV PARSC2   PARSURF  \
  PARSU2            PATRES2  PATTERN1 PDECAT            \
  REPSQ    REPDB    RFDIST   RIDIST   SPACEC   SPLNODE  \
  SUCH     TEX1     UDVO     YSTREAM  PAIR     ENV      \
  ATRIG    ATRIG-   GROUP    GROUP-   LALG     LALG- 


axiom_algebra_layer_4_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_4))

axiom_algebra_layer_4_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_4)))
@

\subsection{Layer 5}

<<layer5>>=
axiom_algebra_layer_5 = \
           CHARNZ            DVARCAT  DVARCAT- ELEMFUN  \
  ELEMFUN- ESTOOLS2 FCOMP    FPATMAB  IDPAM    IDPO     \
  INCRMAPS KERNEL2           MODMONOM MONADWU  MONADWU- \
  MRF2     NARNG    NARNG-   NSUP2    ODVAR    OPQUERY  \
           ORDMON   PATMATCH PERMCAT  PDRING   PDRING-  \
  SDVAR    SUP2     TRIGCAT  TRIGCAT- ULS2     UP2      \
  ELABEXPR 

axiom_algebra_layer_5_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_5))

axiom_algebra_layer_5_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_5)))
@

\subsection{Layer6}

<<layer6>>=

$(OUT)/CHARPOL.$(FASLEXT): $(OUT)/SETCAT-.$(FASLEXT)

axiom_algebra_layer_6 = \
                   AUTOMOR  CARTEN2 CHARPOL  COMPLEX2 \
  DIFEXT  DIFEXT-  ES1      ES2     GRMOD    GRMOD-   \
  HYPCAT  HYPCAT-           MODRING NASRING  NASRING- \
  SORTPAK ZMOD                                        \
                   OAMONS   BYTE    SYSINT   SYSNNI

axiom_algebra_layer_6_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_6))
axiom_algebra_layer_6_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_6)))
@

\subsection{Layer7}

\begin{verbatim}
\end{verbatim}

<<layer7>>=
axiom_algebra_layer_7 = \
  BTCAT   BTCAT-                    FMCAT   IDPOAM   \
  IFAMON  GRALG   GRALG-                             \
  INT8    INT16   INT32    INT64    UINT8   UINT16   \
  UINT32  UINT64

axiom_algebra_layer_7_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_7))

axiom_algebra_layer_7_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_7)))
@

\subsection{Layer8}

<<layer8>>=
axiom_algebra_layer_8 = \
  BSTREE  BTOURN   CARD     DRAWHACK  FACTFUNC FMTC  \
  FR2     FRAC2    FRUTIL   ITAYLOR   MLO      NAALG \
  NAALG-  OP       ORDCOMP2 RANDSRC   UNISEG2  XALG  \
                                      ARR2CAT  ARR2CAT-

axiom_algebra_layer_8_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_8))

axiom_algebra_layer_8_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_8)))
@

\subsection{Layer9}

<<layer9>>=
axiom_algebra_layer_9 = \
  AMR      AMR-     DEGRED   DLP      EAB      ESTOOLS1 \
  FAGROUP  FAMONOID FLINEXP  FLINEXP- FRETRCT  FRETRCT- \
  FSERIES  FT       IDPAG    IDPOAMS  INFINITY LA       \
  OMLO     ORTHPOL  PRODUCT  PADICCT  PMPRED   PMASS    \
  PTFUNC2  RADCAT   RADCAT-  RATRET   RADUTIL  UPXS2    \
  XFALG    ZLINDEP  BBTREE                              \
                    ODEIFTBL NIPROB   ODEPROB  OPTPROB  \
  PDEPROB  COLOR    SIG


axiom_algebra_layer_9_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_9))

axiom_algebra_layer_9_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_9)))
@

\subsection{Layer10}

<<layer10>>=
axiom_algebra_layer_10 = \
           BFUNCT   BPADIC   \
  BTREE    CRAPACK  DEQUEUE  DLIST    \
  DRAWCX   D01GBFA  D02EJFA  D03FAFA  \
  DRAWPT   FAMR     FAMR-    FLASORT  \
  FLAGG2   FGROUP   FM       FM1      \
  FPC      FPC-     FMONOID  INDE     \
  IPADIC   IROOT    IR2      LEXP     \
  LIECAT   LIECAT-  LIST2    LIST2MAP \
  LMOPS    LZSTAGG  LZSTAGG- MAGMA    \
  MESH     MOEBIUS  MODFIELD MODOP    \
  MRING    MTHING   NCNTFRAC NCODIV   \
  NUMTUBE  ODR      OFMONOID ONECOMP  \
  ORDCOMP  OREPCAT  OREPCAT- OWP      \
  PADIC    PATTERN2 PATLRES  PARTPERM \
  PBWLB    PENDTREE PGE      PGROEB   \
  PINTERP  PLOTTOOL PFR      PMDOWN   \
  PRTITION PMINS    PMLSAGG  PMTOOLS  \
  PSCAT    PSCAT-   QFORM    QUEUE    \
  SCACHE   SEG      SEG2     SEXOF    \
  STACK    STTAYLOR TABLBUMP TABLEAU  \
  TOPSP    TRANFUN  TRANFUN- TUBE     \
  UDPO     UNISEG   VIEW     VSPACE   \
  VSPACE-  XPOLYC   XPR    BTAGG    BTAGG-  \
  FUNDESC


axiom_algebra_layer_10_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_10))

axiom_algebra_layer_10_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_10)))
@

\subsection{Layer11}

<<layer11>>=
axiom_algebra_layer_11 = \
  APPLYORE ARRAY1   ARRAY12  ARRAY2   \
  ASTACK   COMBINAT \
  CSTTOOLS D01FCFA  E04MBFA  FARRAY   \
  FLALG    GALUTIL  HEAP              \
  IARRAY2  IFARRAY  INTCAT   INTHEORY \
  IRREDFFX LFCAT    LODOCAT  LODOCAT- \
  LWORD    MATCAT   MATCAT-  MATSTOR  \
  ORESUP   OREPCTO  OREUP    PLOT3D   \
  PR       PREASSOC PRIMARR2 REDORDER \
  STREAM   SYMPOLY  \
  TS       TUPLE    UPSCAT   UPSCAT-  \
                    XDPOLY   XEXPPKG  \
  XF       XF-      XPBWPOLY XPOLY    \
  XRPOLY   

axiom_algebra_layer_11_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_11))

axiom_algebra_layer_11_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_11)))
@

\subsection{Layer12}

<<layer12>>=
axiom_algebra_layer_12 = \
  ULSCAT                           BITS     DIRPROD2 IMATRIX \
  IVECTOR  LPOLY   LSMP    LSMP1   MATCAT2  PTCAT    TRIMAT  \
                   SYSTEM  HOSTNAME PORTNUM

axiom_algebra_layer_12_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_12))

axiom_algebra_layer_12_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_12)))
@

\subsection{Layer13}

<<layer13>>=

$(OUT)/UPOLYC.$(FASLEXT): $(OUT)/PFECAT.$(FASLEXT)

axiom_algebra_layer_13 = \
  ASSOCEQ  CARTEN   CLIF     CLIP     \
  UPOLYC   UPOLYC-                    \
  COORDSYS DBASE    DHMATRIX DIOSP    \
  DIRPCAT  DIRPCAT- D02BBFA  D02BHFA  \
  D02CJFA  FAXF     FAXF-    FFPOLY2  \
  FNLA     GRAY     HB       IRSN     \
  MCALCFN  MHROWRED NUMODE   NUMQUAD  \
  ODESYS   ODETOOLS ORDFUNS  PERMAN   \
  PFECAT   PFECAT-  POINT    PSEUDLIN \
  PTPACK   REP2     SETMN    SEX      \
  SYMFUNC  VECTOR2     CHAR  \
  INBCON   INBCON-  OUTBCON  OUTBCON-

axiom_algebra_layer_13_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_13))

axiom_algebra_layer_13_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_13)))
@

\subsection{Layer14}

<<layer14>>=
$(OUT)/FS.$(FASLEXT): $(OUT)/UPOLYC.$(FASLEXT)

axiom_algebra_layer_14 = \
  FS       FS-      ACF      ACF-     \
  ACFS    ACFS-    BALFACT  BEZOUT   BINARY   BINFILE  BOUNDZRO \
  BPADICRT BRILL    CDEN     CHVAR    \
  COMMUPC  CONTFRAC CVMP     CYCLOTOM \
  CYCLES   DDFACT   DECIMAL  DIRPROD  DISPLAY  DMP      \
  DPMO     DPOLCAT  DPOLCAT- D01AJFA  \
  D01AKFA  D01ALFA  D01AMFA  D01APFA  \
  D01AQFA  EMR      EQ       ERROR    \
  EVALCYC  E04DGFA  E04FDFA  E04GCFA  \
  E04JAFA  FACUTIL  FF       FFCG     \
  FFCGX    FFHOM    FFNB     FFNBX    \
  FFPOLY   FFX      FFSLPE   FGLMICPK \
  FILE     FINAALG  FINAALG- FINRALG  \
  FINRALG-          FLOATRP  FNAME    \
  FOP      FORMULA  FORT     FRAC     \
  FTEM     GENEEZ   GENMFACT GENPGCD  \
  GALFACTU GALPOLYU GB       GBEUCLID \
  GBF      GBINTERN GHENSEL  GMODPOL  \
  GOSPER   GRIMAGE  GROEBSOL HDMP     \
  HDP      HEXADEC  HEUGCD   IBPTOOLS \
  IFF      IBITS    ICARD    ICDEN    \
  IDECOMP  IIARRAY2 IMATLIN  IMATQF   \
  INMODGCD INNMFACT INPSIGN  INTHERTR \
  INTRAT   INTRF    INTSLPE  INTTR    \
  ISUMP    LAUPOL   LEADCDET LGROBP   \
  LIMITRF  LINDEP   LO       LPEFRAC  \
  LSPP     MATLIN   MCDEN    MDDFACT  \
  MFINFACT MFLOAT   MINT     MLIFT    \
  MMAP     MODMON   MONOTOOL MPCPF    \
  MPC2     MPC3     MPOLY    MPRFF    \
  MRATFAC  MULTSQFR NORMRETR NPCOEF   \
  NSUP     NTPOLFN  ODP      ODEPRIM  \
  ODEPRRIC OMPKG    OMSERVER PADEPAC  \
  PADICRAT PADICRC  PCOMP    PDECOMP  \
  PF       PFBR     PFBRU    PFOTOOLS \
  PFRPAC   PGCD     PINTERPA PLEQN    \
  PMPLCAT  PMQFCAT  PNTHEORY POLUTIL  \
  POLTOPOL POLYCATQ POLYLIFT POLYROOT \
  POLY2    POLY2UP  PRS      PSQFR    \
  PUSHVAR  QALGSET  QFCAT2   RADIX    \
  RATFACT  RCFIELD  RCFIELD- RDETR    \
  RDETRS   REAL0    REAL0Q   REALSOLV \
  RESRING  RETSOL   RF       RFFACTOR \
  RMATCAT  RMATCAT- RRCC     RRCC-    \
  SCPKG    SHDP     SHP      SIGNRF   \
  SMITH    SMP      SMTS     SOLVEFOR \
  SPLTREE  STINPROD STTFNC   SUBRESP  \
  SUMRF    SUP      SUPFRACF TANEXP   \
  TEMUTL   TEX      TEXTFILE TREE     \
  TWOFACT  UNIFACT  UP       UPCDEN   \
  UPDECOMP UPDIVP   UPMP     UPOLYC2  \
  UPXSCAT  UPSQFREE VIEWDEF  VIEW2D   \
  VOID     WEIER    WP       \
 EQTBL  GSTBL   HASHTBL \
  INTABL  INTFTBL  STBL    STRTBL\
  TABLE     FST SYMS     SYMTAB \
  IOBCON


axiom_algebra_layer_14_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_14))

axiom_algebra_layer_14_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_14)))
@

\subsection{Layer15}

<<layer15>>=
axiom_algebra_layer_15 = \
  DSMP     EXPUPXS  ARITY            \
  FRAMALG  FRAMALG- MDAGG    ODPOL   \
  PLOT     RMCAT2   ROIRC    SDPOL   \
  SMATCAT  SMATCAT- TUBETOOL UPXSCCA \
  UPXSCCA- JAVACODE POLY       BYTEBUF    OVERSET

axiom_algebra_layer_15_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_15))

axiom_algebra_layer_15_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_15)))
@

\subsection{Layer16}

<<layer16>>=
axiom_algebra_layer_16 = \
  DPMM     EFUPXS  FFINTBAS FRIDEAL  OPERCAT  OPERCAT- \
  FRIDEAL2 FRMOD   \
  IBATOOL  INTFACT \
  MSETAGG  MONOGEN MONOGEN- NFINTBAS \
  SPACE3  FFF

axiom_algebra_layer_16_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_16))

axiom_algebra_layer_16_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_16)))
@

\subsection{Layer17}

<<layer17>>=
axiom_algebra_layer_17 = \
  CCLASS  FSAGG2  GALFACT IALGFACT CTORCAT  CTORCAT- \
  IBACHIN MMLFORM NORMMA  ODERED  OMSAGG    OPSIG    \
  PERM    PERMGRP PRIMES  PWFFINTB \
  RDIST   SAE     SAEFACT SAERFFC  \
  SGCF VIEW3D 

axiom_algebra_layer_17_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_17))

axiom_algebra_layer_17_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_17)))
@

\subsection{Layer18}

<<layer18>>=
$(OUT)/PSETCAT.$(FASLEXT): $(OUT)/RPOLCAT.$(FASLEXT)

axiom_algebra_layer_18 = \
	INTPACK IPF     CATCTOR DOMCTOR   CTORCALL \
  KAFILE  PATRES TBCMPPK PSETCAT    PSETCAT-  \
  RPOLCAT  RPOLCAT-

axiom_algebra_layer_18_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_18))

axiom_algebra_layer_18_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_18)))
@

\subsection{Layer19}

<<layer19>>=
$(OUT)/TSETCAT.$(FASLEXT): $(OUT)/PSETCAT.$(FASLEXT) $(OUT)/RPOLCAT.$(FASLEXT)

axiom_algebra_layer_19 = \
  ACPLOT   ANTISYM  ANY      ATTRBUT \
  BOP      BOP1     COMMONOP COMPCAT \
  COMPCAT- DRAW     DRAWCFUN DROPT   \
  DROPT0   D01ANFA  D01ASFA  D03AGNT \
  EP       E04AGNT  FCPAK1   FEXPR   \
  FFCAT    FFCAT-   FFCGP    FFNBP   \
  FFP      FLOAT    FPARFRAC FR      \
  FRNAALG  FRNAALG- \
           FUNCTION GDMP     HACKPI  \
  IDEAL    INFORM   INFORM1  IPRNTPK \
  IR       ISUPS    KERNEL   LIB     \
  LMDICT   LODOOPS  MATRIX   MKFLCFN \
  MSET     M3D      NAGC02   NAGC05  \
  NAGC06   NAGD03   NAGE01   NAGE02  \
  NAGE04   NAGF07   NAGS     NAGSP   \
  NREP     NUMFMT   OC       OC-     \
  ODEPACK  ODERAT   OMERR    OMERRK  \
  OPTPACK  OSI      PATTERN  OVAR    \
  PMKERNEL PMSYM             PRIMELT \
  QALGSET2 QEQUAT   RECLOS   REP1    \
  RESULT   QUATCAT  QUATCAT- RFFACT  \
  RMATRIX  ROMAN    ROUTINE          \
           RULECOLD SAOS     SEGBIND \
  SET      SPECOUT  SQMATRIX SWITCH  \
                    SYSSOLP  UTSCAT  \
  UTSCAT-  VARIABLE WFFINTBS SPADPRSR \
  PARSER   PROPFRML TSETCAT  TSETCAT-

axiom_algebra_layer_19_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_19))

axiom_algebra_layer_19_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_19)))
@

\subsection{Layer20}

<<layer20>>=
axiom_algebra_layer_20 = \
  AF       ALGFACT  ALGFF    ALGMANIP ALGMFACT ALGPKG   \
  ALGSC    AN       APPRULE  CINTSLPE COMPFACT COMPLEX  \
  COMPLPAT CMPLXRT  CPMATCH  CRFP     \
  CTRIGMNP D01WGTS  D02AGNT  D03EEFA  \
  DBLRESP  DERHAM   DFSFUN   DRAWCURV \
  E04NAFA  E04UCFA  EF       EFSTRUC  \
  ELFUTS   ESTOOLS  EXPEXPAN EXPRODE  \
  EXPRTUBE EXPR2    FC       FDIVCAT  \
  FDIVCAT- FDIV2    FFCAT2   FLOATCP  \
  FORDER   FORTRAN  FSRED    FSUPFACT \
  FRNAAF2  FSPECF   FS2      FS2UPS   \
  GAUSSFAC GCNAALG  GENUFACT GENUPS   \
  GTSET    GPOLSET  IAN      INEP     \
  INFPROD0 INFSP    INPRODFF INPRODPF \
  INTAF    INTALG   INTEF    INTG0    \
  INTHERAL INTPAF   INTPM    INTTOOLS \
  ITRIGMNP JORDAN   KOVACIC  LF       \
  LIE      LODOF    LSQM     OMEXPR   \
  MCMPLX   MULTFACT NAGD01   NAGD02   \
  NAGF01   NAGF02   NAGF04   NCEP     \
  NLINSOL  NSMP     NUMERIC  OCT      \
  OCTCT2   ODEPAL   ODERTRIC PADE     \
  PAN2EXPR PDEPACK  PFO      PFOQ     \
  PICOERCE PMASSFS  PMFS     PMPREDFS \
  PSETPK   QUAT     QUATCT2  RADFF    \
  RDEEF    RDEEFS   RDIV     RSETCAT  \
  RSETCAT- RULE     RULESET  SIMPAN   \
  SFORT    SOLVESER SUMFS    SUTS     \
  TOOLSIGN TRIGMNIP TRMANIP  ULSCCAT  \
  ULSCCAT- UPXSSING UTSODE   UTSODETL \
  UTS2     WUTSET   

axiom_algebra_layer_20_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_20))

axiom_algebra_layer_20_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_20)))
@

\subsection{Layer21}

<<layer21>>=
axiom_algebra_layer_21 = \
  DEFINTEF DFINTTLS DEFINTRF D01TRNS  \
  EFULS    ESCONT   EXPR     EXPR2UPS \
  FDIV     FSCINT   FSINT    FS2EXPXP \
  GSERIES  HELLFDIV INVLAPLA IR2F     \
  IRRF2F   LAPLACE  LIMITPS  LODEEF   \
  NODE1    ODECONST ODEINT   REP      \
  SOLVERAD SULS     SUPXS    ULS      \
  ULSCONS  UPXS     UPXSCONS UTS 

axiom_algebra_layer_21_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_21))

axiom_algebra_layer_21_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_21)))
@

\subsection{Layer22}

<<layer22>>=
axiom_algebra_layer_22 = \
           COMBF    D01AGNT  FSPRMELT \
  INBFF    LODO     LODO1    LODO2    \
  NTSCAT   REGSET   RGCHAIN  RSETGCD  \
  RSDCMPK  SFRTCAT  SIGNEF   SNTSCAT  \
  SOLVETRA SRDCMPK  SREGSET  STTF     \
  SUBSPACE ZDSOLVE

axiom_algebra_layer_22_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_22))

axiom_algebra_layer_22_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_22)))
@

\subsection{Final layer spad files}

<<layer23>>=
axiom_algebra_layer_23 = \
  CPIMA    IRURPK   LAZM3PK  LEXTRIPK \
  NORMPK   QCMPACK  RURPK    SFRGCD   \
  SFQCMPK  INTRVL   ODEEF    DOMAIN   CATEGORY

axiom_algebra_layer_23_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_23))

axiom_algebra_layer_23_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_23)))
@

\subsection{User Layer for newly added algebra}

Rather than classify newly created algebra into the existing type lattice
we add it here.
<<USERLAYER>>=
axiom_algebra_layer_user =  \
	RINTERP	 ASTCAT   ASTCAT-  SASTCAT  SASTCAT- HEADAST  \
	LITERAL           TYPEAST  IMPTAST  MAPPAST  ATTRAST  \
	JOINAST  IFAST    RPTAST   WHILEAST INAST    CLLCAST  \
	LSTAST   EXITAST  RETAST   SEGAST   PRTDAST  CRCAST   \
	LETAST   SUCHAST  RDUCEAST COLONAST ADDAST   CAPSLAST \
	CASEAST  HASAST   ISAST    CATAST   WHEREAST COMMAAST \
	QQUTAST  DEFAST   MACROAST SPADXPT  SPADAST           \
	INBFILE  OUTBFILE IOBFILE  RGBCMDL  RGBCSPC           \
        CTOR     IP4ADDR  NETCLT   INETCLTS                   \
	FMC      FMFUN    FORTFN   FVC      FVFUN    ASP34    \
        ASP1     ASP10    ASP24    ASP4     ASP50    ASP6     \
	ASP73    ASP27    ASP28    ASP33    ASP49    ASP7     \
        ASP78    ASP9     ASP12    ASP55    ASP8     ASP19    \
        ASP20    ASP30    ASP31    ASP35    ASP41    ASP42    \
	ASP74    ASP77    ASP80    ASP29

axiom_algebra_layer_user_nrlibs = \
	$(addsuffix .NRLIB/code.$(FASLEXT),$(axiom_algebra_layer_user))

axiom_algebra_layer_user_objects = \
	$(addprefix $(OUT)/, \
	   $(addsuffix .$(FASLEXT),$(axiom_algebra_layer_user)))

$(OUT)/SASTCAT.$(FASLEXT): $(OUT)/ASTCAT.$(FASLEXT)
$(OUT)/LITERAL.$(FASLEXT): $(OUT)/SASTCAT.$(FASLEXT)
$(OUT)/HEADAST.$(FASLEXT): $(OUT)/IDENT.$(FASLEXT)
$(OUT)/SPADXPT.$(FASLEXT): $(OUT)/ASTCAT.$(FASLEXT)
$(OUT)/ATTRAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/TYPEAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/IMPTAST.$(FASLEXT): $(OUT)/TYPEAST.$(FASLEXT)
$(OUT)/MAPPAST.$(FASLEXT): $(OUT)/TYPEAST.$(FASLEXT)
$(OUT)/SIGAST.$(FASLEXT): $(OUT)/SIG.$(FASLEXT) $(OUT)/IDENT.$(FASLEXT)
$(OUT)/JOINAST.$(FASLEXT): $(OUT)/TYPEAST.$(FASLEXT)
$(OUT)/IFAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/RPTAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/WHILEAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/INAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/CLLCTAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/LSTAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/EXITAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/RETAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/SEGAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/SEQAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/PRTDAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/CRCEAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/RSTRCAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/LETAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/RDUCEAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/SUCHTAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/COLONAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/ADDAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/CAPSLAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/CASEAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/HASAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/ISAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/CATAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/WHEREAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/COMMAAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/QQUTAST.$(FASLEXT): $(OUT)/SASTCAT.$(FASLEXT)
$(OUT)/DEFAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/MACROAST.$(FASLEXT): $(OUT)/SPADXPT.$(FASLEXT)
$(OUT)/SPADAST.$(FASLEXT): \
  $(addprefix $(OUT)/,$(addsuffix .$(FASLEXT), \
     IMPTAST DEFAST MACROAST WHEREAST  CATAST CAPSLAST \
     SIGAST ATTRAST MAPPAST IFAST RPTAST WHILEAST INAST \
     CLLCTAST LSTAST EXITAST RETAST CRCEAST PRTDAST RSTRCAST \
     SEGAST SEQAST LETAST SUCHTAST COLONAST CASEAST HASAST \
     ISAST))

$(OUT)/INBFILE.$(FASLEXT): $(OUT)/FNAME.$(FASLEXT) \
	$(OUT)/INBCON.$(FASLEXT) $(OUT)/STRING.$(FASLEXT)
$(OUT)/OUTBFILE.$(FASLEXT): $(OUT)/FNAME.$(FASLEXT) \
	$(OUT)/OUTBCON.$(FASLEXT) $(OUT)/STRING.$(FASLEXT)
$(OUT)/IOBFILE.$(FASLEXT): $(OUT)/INBFILE.$(FASLEXT) \
	$(OUT)/OUTBFILE.$(FASLEXT)

$(OUT)/CTOR.$(FASLEXT): $(OUT)/CTORKIND.$(FASLEXT) \
	$(OUT)/IDENT.$(FASLEXT)

$(OUT)/NETCLT.$(FASLEXT): $(OUT)/IOBCON.$(FASLEXT)
$(OUT)/INETCLTS.$(FASLEXT): $(OUT)/NETCLT.$(FASLEXT)


$(OUT)/ASP34.$(FASLEXT): $(OUT)/FMC.$(FASLEXT)

@

\section{Broken Files}

These files are Aldor files
\begin{verbatim}
axtimer.as Timer
iviews.as  InventorRenderPackage IVREND
ffrac.as   FormalFraction FORMAL
iviews.as  InventorViewPort IVVIEW
iviews.as  InventorDataSink IVDATA
herm.as    PackedHermitianSequence PACKED
nsfip.as   NagSpecialFunctionsInterfacePackage NAGSPE
nrc.as     NagResultChecks NAGRES
nqip.as    NagQuadratureInterfacePackage NAGQUA
noptip.as  NagOptimizationInterfacePackage NAGOPT
nepip.as   NagEigenInterfacePackage NAGEIG
ndftip.as  NagDiscreteFourierTransformInterfacePackage NAGDIS
\end{verbatim}

These domains are referenced but don't exist
\begin{verbatim}
OBJECT
\end{verbatim}

\section{The Environment}

\subsection{The working directories}

We define 5 directories for this build. The{\bf IN} directory
contains the pamphlet files for the algebra. These are expanded
into the{\bf MID} directory as either .spad or .as files. The
.spad files are compiled by the native spad internal compiler.
The .as files are compiled using the Aldor compiler. The output
of the compilation has two purposes. Part of the information is
used to build various database files (daase files). The other
part is executable code which is placed in the {\bf OUT}
directory. When invoked as ``make document'' we construct
the .dvi files in the{\bf DOC} directory.

The [[OUTSRC=$(axiom_target_srcdir)/algebra]] subdirectory contains the 
algebra source files extracted from the pamphlet files. These sources 
allow the end user to change the algebra if needed.

<<environment>>=

IN=$(srcdir)
OUT=$(axiom_targetdir)/algebra
DOC=$(axiom_target_docdir)/src/algebra
OUTSRC=$(axiom_target_srcdir)/algebra
INPUT=../input

@

<<environment>>=
## We use interpsys, built from previous stage, to bootstrap the algebra
## files.  In fact, we use interpsys to build everything.
COMPILE_LISP = $(INTERPSYS) --compile --output=$@ $<

@

\subsection{The interpsys variable}
The {\bf interpsys} image is the compile-time environment for algebra
files.

<<environment>>=

INTERPSYS = ../interp/interpsys$(EXEEXT) -- --system="$(AXIOM)" \
		--sysalg="$(axiom_src_datadir)/algebra/"

@

\subsection{The SPADFILES list}
Note that we have excluded {\bf mlift.spad.jhd} from this list.
We need to figure out which mlift.spad to keep.

<<environment>>=

SPADFILES= \
 ${OUTSRC}/acplot.spad ${OUTSRC}/aggcat2.spad ${OUTSRC}/aggcat.spad \
 ${OUTSRC}/algcat.spad ${OUTSRC}/algext.spad ${OUTSRC}/algfact.spad \
 ${OUTSRC}/algfunc.spad ${OUTSRC}/allfact.spad ${OUTSRC}/alql.spad \
 ${OUTSRC}/annacat.spad ${OUTSRC}/any.spad ${OUTSRC}/array1.spad \
 ${OUTSRC}/array2.spad ${OUTSRC}/asp.spad ${OUTSRC}/attreg.spad \
 ${OUTSRC}/bags.spad ${OUTSRC}/bezout.spad ${OUTSRC}/boolean.spad \
 ${OUTSRC}/brill.spad \
 ${OUTSRC}/c02.spad ${OUTSRC}/c05.spad ${OUTSRC}/c06.spad \
 ${OUTSRC}/card.spad ${OUTSRC}/carten.spad ${OUTSRC}/catdef.spad \
 ${OUTSRC}/cden.spad ${OUTSRC}/clifford.spad ${OUTSRC}/clip.spad \
 ${OUTSRC}/cmplxrt.spad ${OUTSRC}/coerce.spad ${OUTSRC}/color.spad \
 ${OUTSRC}/combfunc.spad ${OUTSRC}/combinat.spad ${OUTSRC}/complet.spad \
 ${OUTSRC}/constant.spad ${OUTSRC}/contfrac.spad ${OUTSRC}/cont.spad \
 ${OUTSRC}/coordsys.spad ${OUTSRC}/cra.spad ${OUTSRC}/crfp.spad \
 ${OUTSRC}/curve.spad ${OUTSRC}/cycles.spad ${OUTSRC}/cyclotom.spad \
 ${OUTSRC}/d01agents.spad ${OUTSRC}/d01Package.spad \
 ${OUTSRC}/d01routine.spad ${OUTSRC}/d01.spad ${OUTSRC}/d01transform.spad \
 ${OUTSRC}/d01weights.spad ${OUTSRC}/d02agents.spad \
 ${OUTSRC}/d02Package.spad ${OUTSRC}/d02routine.spad ${OUTSRC}/d02.spad \
 ${OUTSRC}/d03agents.spad ${OUTSRC}/d03Package.spad \
 ${OUTSRC}/d03routine.spad ${OUTSRC}/d03.spad ${OUTSRC}/ddfact.spad \
 ${OUTSRC}/defaults.spad ${OUTSRC}/defintef.spad ${OUTSRC}/defintrf.spad \
 ${OUTSRC}/degred.spad ${OUTSRC}/derham.spad ${OUTSRC}/dhmatrix.spad \
 ${OUTSRC}/divisor.spad ${OUTSRC}/dpolcat.spad ${OUTSRC}/drawopt.spad \
 ${OUTSRC}/drawpak.spad ${OUTSRC}/draw.spad \
 ${OUTSRC}/e01.spad ${OUTSRC}/e02.spad ${OUTSRC}/e04agents.spad \
 ${OUTSRC}/e04Package.spad ${OUTSRC}/e04routine.spad ${OUTSRC}/e04.spad \
 ${OUTSRC}/efstruc.spad ${OUTSRC}/efuls.spad ${OUTSRC}/efupxs.spad \
 ${OUTSRC}/eigen.spad ${OUTSRC}/elemntry.spad ${OUTSRC}/elfuts.spad \
 ${OUTSRC}/equation1.spad ${OUTSRC}/equation2.spad ${OUTSRC}/error.spad \
 ${OUTSRC}/expexpan.spad ${OUTSRC}/expr2ups.spad \
 ${OUTSRC}/exprode.spad ${OUTSRC}/expr.spad \
 ${OUTSRC}/f01.spad ${OUTSRC}/f02.spad ${OUTSRC}/f04.spad \
 ${OUTSRC}/f07.spad ${OUTSRC}/facutil.spad ${OUTSRC}/ffcat.spad \
 ${OUTSRC}/ffcg.spad ${OUTSRC}/fff.spad ${OUTSRC}/ffhom.spad \
 ${OUTSRC}/ffnb.spad ${OUTSRC}/ffpoly2.spad ${OUTSRC}/ffpoly.spad \
 ${OUTSRC}/ffp.spad ${OUTSRC}/ffx.spad \
 ${OUTSRC}/files.spad ${OUTSRC}/float.spad ${OUTSRC}/fmod.spad \
 ${OUTSRC}/fname.spad ${OUTSRC}/fnla.spad ${OUTSRC}/formula.spad \
 ${OUTSRC}/fortcat.spad ${OUTSRC}/fortmac.spad ${OUTSRC}/fortpak.spad \
 ${OUTSRC}/fortran.spad ${OUTSRC}/forttyp.spad ${OUTSRC}/fourier.spad \
 ${OUTSRC}/fparfrac.spad ${OUTSRC}/fraction.spad ${OUTSRC}/free.spad \
 ${OUTSRC}/fr.spad ${OUTSRC}/fs2expxp.spad ${OUTSRC}/fs2ups.spad \
 ${OUTSRC}/fspace.spad ${OUTSRC}/funcpkgs.spad ${OUTSRC}/functions.spad \
 ${OUTSRC}/galfact.spad ${OUTSRC}/galfactu.spad ${OUTSRC}/galpolyu.spad \
 ${OUTSRC}/galutil.spad ${OUTSRC}/gaussfac.spad ${OUTSRC}/gaussian.spad \
 ${OUTSRC}/gbeuclid.spad ${OUTSRC}/gbintern.spad ${OUTSRC}/gb.spad \
 ${OUTSRC}/gdirprod.spad ${OUTSRC}/gdpoly.spad ${OUTSRC}/geneez.spad \
 ${OUTSRC}/generic.spad ${OUTSRC}/genufact.spad ${OUTSRC}/genups.spad \
 ${OUTSRC}/ghensel.spad ${OUTSRC}/gpgcd.spad ${OUTSRC}/gpol.spad \
 ${OUTSRC}/grdef.spad ${OUTSRC}/groebf.spad ${OUTSRC}/groebsol.spad \
 ${OUTSRC}/gseries.spad \
 ${OUTSRC}/ideal.spad ${OUTSRC}/idecomp.spad ${OUTSRC}/indexedp.spad \
 ${OUTSRC}/infprod.spad ${OUTSRC}/intaf.spad ${OUTSRC}/intalg.spad \
 ${OUTSRC}/intaux.spad ${OUTSRC}/intclos.spad ${OUTSRC}/intef.spad \
 ${OUTSRC}/integer.spad ${OUTSRC}/integrat.spad \
 ${OUTSRC}/interval.spad \
 ${OUTSRC}/intfact.spad ${OUTSRC}/intpm.spad \
 ${OUTSRC}/intrf.spad \
 ${OUTSRC}/irexpand.spad \
 ${OUTSRC}/irsn.spad ${OUTSRC}/ituple.spad \
 ${OUTSRC}/kl.spad ${OUTSRC}/kovacic.spad \
 ${OUTSRC}/laplace.spad ${OUTSRC}/laurent.spad ${OUTSRC}/leadcdet.spad \
 ${OUTSRC}/lie.spad ${OUTSRC}/limitps.spad ${OUTSRC}/lindep.spad \
 ${OUTSRC}/lingrob.spad ${OUTSRC}/liouv.spad ${OUTSRC}/listgcd.spad \
 ${OUTSRC}/list.spad ${OUTSRC}/lmdict.spad ${OUTSRC}/lodof.spad \
 ${OUTSRC}/lodop.spad ${OUTSRC}/lodo.spad \
 ${OUTSRC}/manip.spad ${OUTSRC}/mappkg.spad ${OUTSRC}/matcat.spad \
 ${OUTSRC}/matfuns.spad ${OUTSRC}/mathml.spad \
 ${OUTSRC}/matrix.spad ${OUTSRC}/matstor.spad \
 ${OUTSRC}/mesh.spad ${OUTSRC}/mfinfact.spad ${OUTSRC}/misc.spad \
 ${OUTSRC}/mkfunc.spad ${OUTSRC}/mkrecord.spad \
 ${OUTSRC}/mlift.spad ${OUTSRC}/moddfact.spad ${OUTSRC}/modgcd.spad \
 ${OUTSRC}/modmonom.spad ${OUTSRC}/modmon.spad ${OUTSRC}/modring.spad \
 ${OUTSRC}/moebius.spad ${OUTSRC}/mring.spad ${OUTSRC}/mset.spad \
 ${OUTSRC}/mts.spad ${OUTSRC}/multfact.spad ${OUTSRC}/multpoly.spad \
 ${OUTSRC}/multsqfr.spad \
 ${OUTSRC}/naalgc.spad ${OUTSRC}/naalg.spad \
 ${OUTSRC}/newdata.spad ${OUTSRC}/newpoint.spad \
 ${OUTSRC}/newpoly.spad ${OUTSRC}/nlinsol.spad ${OUTSRC}/nlode.spad \
 ${OUTSRC}/npcoef.spad \
 ${OUTSRC}/nregset.spad \
 ${OUTSRC}/nsregset.spad ${OUTSRC}/numeigen.spad ${OUTSRC}/numeric.spad \
 ${OUTSRC}/numode.spad ${OUTSRC}/numquad.spad ${OUTSRC}/numsolve.spad \
 ${OUTSRC}/numtheor.spad \
 ${OUTSRC}/oct.spad ${OUTSRC}/odealg.spad ${OUTSRC}/odeef.spad \
 ${OUTSRC}/oderf.spad ${OUTSRC}/omcat.spad ${OUTSRC}/omdev.spad \
 ${OUTSRC}/omerror.spad ${OUTSRC}/omserver.spad ${OUTSRC}/opalg.spad \
 ${OUTSRC}/openmath.spad ${OUTSRC}/op.spad ${OUTSRC}/ore.spad \
 ${OUTSRC}/outform.spad ${OUTSRC}/out.spad \
 ${OUTSRC}/pade.spad ${OUTSRC}/padiclib.spad ${OUTSRC}/padic.spad \
 ${OUTSRC}/paramete.spad ${OUTSRC}/partperm.spad ${OUTSRC}/patmatch1.spad \
 ${OUTSRC}/patmatch2.spad ${OUTSRC}/pattern.spad ${OUTSRC}/pcurve.spad \
 ${OUTSRC}/pdecomp.spad ${OUTSRC}/perman.spad ${OUTSRC}/permgrps.spad \
 ${OUTSRC}/perm.spad ${OUTSRC}/pfbr.spad ${OUTSRC}/pfo.spad \
 ${OUTSRC}/pfr.spad ${OUTSRC}/pf.spad ${OUTSRC}/pgcd.spad \
 ${OUTSRC}/pgrobner.spad ${OUTSRC}/pinterp.spad ${OUTSRC}/pleqn.spad \
 ${OUTSRC}/plot3d.spad ${OUTSRC}/plot.spad ${OUTSRC}/plottool.spad \
 ${OUTSRC}/polset.spad ${OUTSRC}/poltopol.spad ${OUTSRC}/polycat.spad \
 ${OUTSRC}/poly.spad ${OUTSRC}/primelt.spad ${OUTSRC}/print.spad \
 ${OUTSRC}/product.spad ${OUTSRC}/prs.spad ${OUTSRC}/prtition.spad \
 ${OUTSRC}/pscat.spad ${OUTSRC}/pseudolin.spad ${OUTSRC}/ptranfn.spad \
 ${OUTSRC}/puiseux.spad \
 ${OUTSRC}/qalgset.spad ${OUTSRC}/quat.spad \
 ${OUTSRC}/radeigen.spad ${OUTSRC}/radix.spad ${OUTSRC}/random.spad \
 ${OUTSRC}/ratfact.spad ${OUTSRC}/rdeef.spad ${OUTSRC}/rderf.spad \
 ${OUTSRC}/rdesys.spad ${OUTSRC}/real0q.spad ${OUTSRC}/realzero.spad \
 ${OUTSRC}/reclos.spad ${OUTSRC}/regset.spad ${OUTSRC}/rep1.spad \
 ${OUTSRC}/rep2.spad ${OUTSRC}/resring.spad ${OUTSRC}/retract.spad \
 ${OUTSRC}/rf.spad ${OUTSRC}/riccati.spad ${OUTSRC}/rinterp.spad \
 ${OUTSRC}/routines.spad \
 ${OUTSRC}/rule.spad \
 ${OUTSRC}/seg.spad ${OUTSRC}/setorder.spad ${OUTSRC}/sets.spad \
 ${OUTSRC}/sex.spad ${OUTSRC}/sf.spad ${OUTSRC}/sgcf.spad \
 ${OUTSRC}/sign.spad ${OUTSRC}/si.spad ${OUTSRC}/smith.spad \
 ${OUTSRC}/solvedio.spad ${OUTSRC}/solvefor.spad ${OUTSRC}/solvelin.spad \
 ${OUTSRC}/solverad.spad ${OUTSRC}/sortpak.spad ${OUTSRC}/space.spad \
 ${OUTSRC}/special.spad ${OUTSRC}/sregset.spad ${OUTSRC}/s.spad \
 ${OUTSRC}/stream.spad ${OUTSRC}/string.spad ${OUTSRC}/sttaylor.spad \
 ${OUTSRC}/sttf.spad ${OUTSRC}/sturm.spad ${OUTSRC}/suchthat.spad \
 ${OUTSRC}/suls.spad ${OUTSRC}/sum.spad ${OUTSRC}/sups.spad \
 ${OUTSRC}/supxs.spad ${OUTSRC}/suts.spad ${OUTSRC}/symbol.spad \
 ${OUTSRC}/syssolp.spad ${OUTSRC}/system.spad \
 ${OUTSRC}/tableau.spad ${OUTSRC}/table.spad ${OUTSRC}/taylor.spad \
 ${OUTSRC}/tex.spad ${OUTSRC}/tools.spad ${OUTSRC}/transsolve.spad \
 ${OUTSRC}/tree.spad ${OUTSRC}/trigcat.spad ${OUTSRC}/triset.spad \
 ${OUTSRC}/tube.spad ${OUTSRC}/twofact.spad \
 ${OUTSRC}/unifact.spad ${OUTSRC}/updecomp.spad ${OUTSRC}/updivp.spad \
 ${OUTSRC}/utsode.spad \
 ${OUTSRC}/variable.spad ${OUTSRC}/vector.spad ${OUTSRC}/view2D.spad \
 ${OUTSRC}/view3D.spad ${OUTSRC}/viewDef.spad ${OUTSRC}/viewpack.spad \
 ${OUTSRC}/void.spad \
 ${OUTSRC}/weier.spad ${OUTSRC}/wtpol.spad \
 ${OUTSRC}/xlpoly.spad ${OUTSRC}/xpoly.spad \
 ${OUTSRC}/ystream.spad \
 ${OUTSRC}/zerodim.spad

@

\subsection{The ALDORFILES list}
<<environment>>=

ALDORFILES= \
	axtimer.as \
	ffrac.as \
	herm.as \
	interval.as \
	invnode.as \
	invrender.as \
	invtypes.as \
	invutils.as \
	iviews.as \
	ndftip.as \
	nepip.as \
	noptip.as nqip.as \
	nrc.as nsfip.as 

@


\section{Test Cases}

<<environment>>=

TESTS=${INPUT}/INTHEORY.input ${INPUT}/VIEW2D.input ${INPUT}/TESTFR.input

@

<<testrules>>=

${INPUT}/TESTFR.input: $(srcdir)/fr.spad.pamphlet
	$(axiom_build_document) --tangle='TEST FR' --output=$@ $<

${INPUT}/INTHEORY.input: $(srcdir)/numtheor.spad.pamphlet
	$(axiom_build_document) --tangle='TEST INTHEORY' --output=$@ $<

${INPUT}/VIEW2D.input: $(srcdir)/view2D.spad.pamphlet
	$(axiom_build_document) --tangle='TEST VIEW2D' --output=$@ $<

@

\section{The Makefile Stanzas}

A [[spad]] pamphlet can contain many Axiom [[categories]], [[domains]], and
[[packages]]. 

For the purpose of explanation we assume that the pamphlet file is 
named [[foo.spad.pamphlet]]. It contains the domains [[BAR]], [[BAX]],
and [[BAZ]]. Thus there will be a subsection named [[foo.spad]].

Since pamphlet files (e.g. [[foo.spad.pamphlet]] contain a spad file
e.g. [[foo.spad]], it follows that every subsection contains a Makefile
stanza that extract the [[foo.spad]] file using [[notangle]].

Since pamphlet files are intended as documents it follows that each
subsection contains a Makefile stanza that extracts a [[dvi]] file
using [[noweave]].

We could have a category, domain, or package that is in
the ``bootstrap'' list. Bootstrap spad files contain their generated
lisp code in special sections. The way bootstrapping works is that
we extract the lisp code and compile it rather than extracting the
spad code. We do this because we need the domain to exist before we
can compile the domain. Some domains depend on themselves directly.
Some domains depend on themselves thru a long chain of other domains.
In either case we can't compile the domain until it exists so we
cache the generated lisp code and, when we need to bootstrap the
domain, we compile the raw lisp rather than the spad.

This will only happen when the system is built from scratch. Once
the system has been built the bootstrap code is no longer executed
and these algebra files will appear as normal algebra files. That
means that once the system has been built once only the last three
rules will ever be executed. The first two rules happen when the
system is built from scratch.

A 5 stanza group for this case performs the following functions:
\begin{enumerate}
\item compile and copy the bootstrap lisp to the final algebra directory
\item compile the extracted [[BAR]] domain
\item copy the compiled [[BAR]] to the final algebra directory
\end{enumerate}

The subtle point here occurs in the first item. The bootstrap code
group (in the [[layer0 bootstrap]] code chunk above) asks for the
compiled [[.$(FASLEXT)]] files in the \File{strap/} directory. Essentially this
code group calls for intermediate compiled files. This triggers the
bootstrap stanzas (items 1 and 2 above). All of the other layer 
chunks ask for compiled code in the [[\${OUT}]] directory which is
the final algebra directory. 

The bootstrap process works because first we ask for the compiled
lisp code stanzas (the \File{strap/BAR.$(FASLEXT)} files), THEN we ask for
the final algebra code stanzas (the [[\${OUT}/BAR.$(FASLEXT)]] files). This
is a very subtle point so think it through carefully. The layer0
bootstrap list is the only file list that calls for \File{strap/} files.
All other layers ask for [[\${OUT}]] files. Make sure you
understand this before you change things. If you break it the
world will no longer compile.

So we have a 3 stanza group for normal files, a 3+2 (5) stanza
group for normal files with default code, and a 3+2 (5) stanza
group for normal files that need to be bootstrapped. There is
another combination that occurs, namely bootstrap code that
also contains default code which gives a 3+2+2+2 (9) stanza case.
(see TSETCAT for an example. Be sure to read the items in reverse order).

A 9 stanza group for this case performs the following functions:
\begin{enumerate}
\item extract the bootstrap \File{BAR.lsp} from the \File{foo.spad.pamphlet}
\item compile the bootstrap \File{BAR.lsp} to the \File{strap/} directory
\item extract the bootstrap \File{BAR-.lsp} from the \File{foo.spad.pamphlet}
\item compile the bootstrap \File{BAR-.lsp} to the \File{strap/} directory
\item extract the spad \File{BAR.spad} from the pamphlet 
  \File{foo.spad.pamphlet}
\item compile the extracted \File{BAR.spad} domain (to get [[BAR.$(FASLEXT)]])
\item copy the \File{BAR.$(FASLEXT)} to the final algebra directory
\item compile the extracted \File{BAR-.spad} domain (to get [[BAR-.$(FASLEXT)]])
\item copy the [[BAR-.$(FASLEXT)]] to the final algebra directory
\end{enumerate}

As you can see this is just the combination of the two possible 5
stanza case. We just have to deal with the [[BAR-]] both in regular
and bootstrap files. The first four stanzas will only happen when
the system is built from scratch. Once the system is built these
four rules no longer apply and these stanzas effectively act like
the 5 stanza rules above.

I'm sure all of this seems confusing but it is very stylized code.
Basically you need to figure out which kind of stanza group you need,
copy an existing stanza group, and do a correct renaming of the parts.
The decision tree looks something like:
\begin{verbatim}
IF (you have a regular spad domain)
 THEN use a 3 stanza form (see YSTREAM)
IF (you have a default spad domain (it generates [[-]] files)) AND
   (it does not require bootstrapping)
 THEN use the first 5 stanza form explained above (see LIECAT)
IF (you have a normal spad domain) AND
   (it requires bootstrapping)
 THEN use the second 5 stanza form explained above (see VECTOR)
IF (you have a default spad domain (it generates [[-]] files)) AND
   (it requires bootstrapping)
 THEN use the 9 stanza form explained above (see TSETCAT)
\end{verbatim}

\section{Generic Make Rules}

The idea is to use generic rules to try to cut down the size of this file.

This Makefile works very hard to cache
intermediate results in order to minimize the re-build time. The cached
files are kept in the current build and \File{strap/} directories. 
If one of these
files disappears but the original pamphlet file is unchanged we only
need to rebuild the intermediate file. These rule will attempt to do
that and they succeed however these are intermediate files created by
implicit rules so they would normally be deleted. To prevent the removal
the NRLIB directory and its contents, the files are marked as .PRECIOUS.

The output of the compile step is saved in a file of the same name
and extension .$(FASLEXT)ut in the \${MID} directory. These files are useful for
deriving the dependencies by scanning the ``Loading ...'' messages.

<<genericDotOfiles>>=

.PRECIOUS: $(OUT)/%.$(FASLEXT)
${OUT}/%.$(FASLEXT): %.NRLIB/code.$(FASLEXT)
	cp $< $@

@ 

<<genericNRLIBfiles>>=
.PREVIOUS: %.spad
.PRECIOUS: %.NRLIB/code.$(FASLEXT)
%.NRLIB/code.$(FASLEXT): %.spad
	${INTERPSYS} --strap=strap --system-algebra --optimize=2 --compile $<

@

<<genericBOOTSTRAPfiles>>=
# Compile bootstrap file to machine object code, and the result
# immediately available for AXIOMsys consumption.
strap/%.$(FASLEXT): $(srcdir)/strap/%.lsp
	$(COMPILE_LISP)

@

<<genericSPADfiles>>=

$(OUTSRC)/%.spad: mk-target-src-algabra-dir

${OUTSRC}/%.spad: $(srcdir)/%.spad.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<

.PHONY: mk-target-src-algabra-dir
mk-target-src-algabra-dir:
	@ [ -d $(OUTSRC) ] || $(mkdir_p) $(OUTSRC)

@
<<genericDOCfiles>>=
.PRECIOUS: $(builddir)/%.tex
.PRECIOUS: $(builddir)/%.dvi

$(DOC)/%.dvi:  mk-target-doc-dir

.PHONY: mk-target-doc-dir
mk-target-doc-dir:
	@ [ -d $(DOC) ] || $(mkdir_p) $(DOC)

$(DOC)/%.dvi: $(builddir)/%.dvi
	@cp -p $< $@

$(builddir)/%.dvi: $(axiom_build_texdir)/diagrams.tex \
		   $(axiom_build_texdir)/axiom.sty

$(builddir)/%.dvi: $(builddir)/%.tex
	$(axiom_build_document) --latex $<

$(builddir)/%.tex: $(srcdir)/%.pamphlet
	$(axiom_build_document) --weave --output=$@ $<

$(axiom_build_texdir)/diagrams.tex: $(axiom_src_docdir)/diagrams.tex
	@cp -p $< $@
@
<<genericRules>>=

<<genericDotOfiles>>
<<genericNRLIBfiles>>
<<genericBOOTSTRAPfiles>>
<<genericSPADfiles>>
<<genericDOCfiles>>

SPADPRSR.NRLIB/code.$(FASLEXT): spad-parser.spad
	${INTERPSYS} --system-algebra --compile $<

PARSER.NRLIB/code.$(FASLEXT): script-parser.spad
	${INTERPSYS} --system-algebra --compile $<

@
<<diagrams.tex (OUT from IN)>>=

${DOC}/diagrams.tex: $(axiom_src_docdir)/diagrams.tex
	@cp -p $< $@
 
@

\section{Pamphlet file structure}

Because the individual .spad files are grouped into higher-level
algebra pamphlet files, the rules for extracting them are coded
below as simple ``awk'' scripts that are called when the Makefile
is constructed.

There are, at present, 3 kinds of algebra files to be handled.
First we have [[.as]] files which use the [[aldor]] compiler.
These are ignored here as the compiler is not yet integrated.

Second, there are the bootstrap files. These files live within
their respective pamphlet files and are "captured" lisp code.
These are necessary to create the algebra. See the 
[[src/algebra/Makefile.pamphlet]] for details.

Third, there are 3 "types" of algebra which are all treated 
the same at compile time, namely the "domain", "category", and
"package" algebra.

\subsection{Finding the algebra code}

NOTE: This construct is now moved to configure time.  Update.

Step 1 is to scan all of the algebra pamphlet files for the
chunk names which contain the string "domain", "package", or
"category". This is done using egrep (same as grep -E, which
means that the pattern is an extended regular expression) because
extended regular expressions allows the use of alternatives
written as (domain|package|category). Thus the command
\begin{verbatim}
 egrep '@<<(domain|package|category) .*>>=' *.spad.pamphlet 
\end{verbatim}
will scan the algebra files looking for special chunknames.
Axiom's chunk names are written in a stylized form so that each
algebra chunk name begins with one of those three symbols. Thus 
in zerodim.spad.pamphlet the LexTriangularPackage chunkname is:
\begin{verbatim}
@<<package LEXTRIPK LexTriangularPackage>>
\end{verbatim}
so this egrep will generate an output line, prefixed by the filename
that looks like:
\begin{verbatim}
zerodim.spad.pamphlet:@<<package LEXTRIPK LexTriangularPackage>>=
\end{verbatim}
There can be many lines of output per pamphlet file, one for
each domain, package and category cod chunk contained in the file.

Step 2 is an [[awk]] command line.

\subsection{Write the Makefile stanzas for the algebra files}

NOTE: This construct is now moved to configure time.

[awk] processes each line of the [[egrep]] output. 

The awk script uses [[-F:]] which is a flag that says that a [[:]] is
the field separator. As a result the \$1 and \$2 in the awk script
refer to the parts of the egrep output that come before and after the
[[:]] respectively.

The variable [[chunk]] is assigned the actual chunk name minus
the @<< and >>= delimiters. In the example given above this will become
\begin{verbatim}
package LEXTRIPK LexTriangularPackage
\end{verbatim}
The call to [[split]] splits the chunk into parts separated
by spaces. Thus
\begin{verbatim}
  part[1]=package
  part[2]=LEXTRIPK
  part[3]=LexTriangularPackage
\end{verbatim}
The variable [[spadfile]] in the above example is set to
\begin{verbatim}
${MID}/LEXTRIPK.spad
\end{verbatim}
Finally, in the domain example given above we print two lines.
The first line is the Makefile stanza header which depends on the
original [[zerodim.spad.pamphlet]] file.

The second line is the body of the makefile stanza which calls 
notangle to extract the algebra from the original pamphlet using
the chunk name and writes it to the intermediate subdirectory. In
the case above this would resolve to [[\${MID}/LEXTRIPK.spad]].

For the line given above it outputs the following:
\begin{verbatim}
${MID}/LEXTRIPK.spad: $(srcdir)/zerodim.spad.pamphlet
	$(axiom_build_document) --tangle='package LEXTRIPK LexTriangularPackage' --output=$@ $<
\end{verbatim}


\section{Stage markers}

We output these as each stage completes.
<<stages>>=
$(axiom_algebra_layer_0_objects): strap-stamp
$(axiom_algebra_layer_1_objects): 0-stamp
$(axiom_algebra_layer_2_objects): 1-stamp
$(axiom_algebra_layer_3_objects): 2-stamp
$(axiom_algebra_layer_4_objects): 3-stamp
$(axiom_algebra_layer_5_objects): 4-stamp
$(axiom_algebra_layer_6_objects): 5-stamp
$(axiom_algebra_layer_7_objects): 6-stamp
$(axiom_algebra_layer_8_objects): 7-stamp
$(axiom_algebra_layer_9_objects): 8-stamp
$(axiom_algebra_layer_10_objects): 9-stamp
$(axiom_algebra_layer_11_objects): 10-stamp
$(axiom_algebra_layer_12_objects): 11-stamp
$(axiom_algebra_layer_13_objects): 12-stamp
$(axiom_algebra_layer_14_objects): 13-stamp
$(axiom_algebra_layer_15_objects): 14-stamp
$(axiom_algebra_layer_16_objects): 15-stamp
$(axiom_algebra_layer_17_objects): 16-stamp
$(axiom_algebra_layer_18_objects): 17-stamp
$(axiom_algebra_layer_19_objects): 18-stamp
$(axiom_algebra_layer_20_objects): 19-stamp
$(axiom_algebra_layer_21_objects): 20-stamp
$(axiom_algebra_layer_22_objects): 21-stamp
$(axiom_algebra_layer_23_objects): 22-stamp
$(axiom_algebra_bootstrap_last_layer_objects): 23-stamp
$(axiom_algebra_layer_user_objects): bootstrap-stamp

strap-stamp: $(axiom_algebra_layer_strap_objects)
	@ rm -f strap-stamp
	@ $(STAMP) strap-stamp
	@ echo =====================================
	@ echo === algebra bootstrap complete ======
	@ echo =====================================

0-stamp: strap-stamp $(axiom_algebra_layer_0_objects)
	@ rm -f 0-stamp
	@ $(STAMP) 0-stamp
	@ echo ==================================
	@ echo === layer 0 of 23 complete ======
	@ echo ==================================

1-stamp: 0-stamp $(axiom_algebra_layer_1_objects)
	@ rm -f 1-stamp
	@ $(STAMP) 1-stamp
	@ echo ==================================
	@ echo === layer 1 of 23 complete ======
	@ echo ==================================

2-stamp: 1-stamp $(axiom_algebra_layer_2_objects)
	@ rm -f 2-stamp
	@ $(STAMP) 2-stamp
	@ echo ==================================
	@ echo === layer 2 of 23 complete ======
	@ echo ==================================

3-stamp: 2-stamp $(axiom_algebra_layer_3_objects)
	@ rm -f 3-stamp
	@ $(STAMP) 3-stamp
	@ echo ==================================
	@ echo === layer 3 of 23 complete ======
	@ echo ==================================

4-stamp: 3-stamp $(axiom_algebra_layer_4_objects)
	@ rm -f 4-stamp
	@ $(STAMP) 4-stamp
	@ echo ==================================
	@ echo === layer 4 of 23 complete ======
	@ echo ==================================

5-stamp: 4-stamp $(axiom_algebra_layer_5_objects)
	@ rm -f 5-stamp
	@ $(STAMP) 5-stamp
	@ echo ==================================
	@ echo === layer 5 of 23 complete ======
	@ echo ==================================

6-stamp: 5-stamp $(axiom_algebra_layer_6_objects)
	@ rm -f 6-stamp
	@ $(STAMP) 6-stamp
	@ echo ==================================
	@ echo === layer 6 of 23 complete ======
	@ echo ==================================

7-stamp: 6-stamp $(axiom_algebra_layer_7_objects)
	@ rm -f 7-stamp
	@ $(STAMP) 7-stamp
	@ echo ==================================
	@ echo === layer 7 of 23 complete ======
	@ echo ==================================

8-stamp: 7-stamp $(axiom_algebra_layer_8_objects)
	@ rm -f 8-stamp
	@ $(STAMP) 8-stamp
	@ echo ==================================
	@ echo === layer 8 of 23 complete ======
	@ echo ==================================

9-stamp: 8-stamp $(axiom_algebra_layer_9_objects)
	@ rm -f 9-stamp
	@ $(STAMP) 9-stamp
	@ echo ==================================
	@ echo === layer 9 of 23 complete ======
	@ echo ==================================

10-stamp: 9-stamp $(axiom_algebra_layer_10_objects)
	@ rm -f 10-stamp
	@ $(STAMP) 10-stamp
	@ echo ==================================
	@ echo === layer 10 of 23 complete ======
	@ echo ==================================

11-stamp: 10-stamp $(axiom_algebra_layer_11_objects)
	@ rm -f 11-stamp
	@ $(STAMP) 11-stamp
	@ echo ==================================
	@ echo === layer 11 of 23 complete ======
	@ echo ==================================

12-stamp: 11-stamp $(axiom_algebra_layer_12_objects)
	@ rm -f 12-stamp
	@ $(STAMP) 12-stamp
	@ echo ==================================
	@ echo === layer 12 of 23 complete ======
	@ echo ==================================

13-stamp: 12-stamp $(axiom_algebra_layer_13_objects)
	@ rm -f 13-stamp
	@ $(STAMP) 13-stamp
	@ echo ==================================
	@ echo === layer 13 of 23 complete ======
	@ echo ==================================

14-stamp: 13-stamp $(axiom_algebra_layer_14_objects)
	@ rm -f 14-stamp
	@ $(STAMP) 14-stamp
	@ echo ==================================
	@ echo === layer 14 of 23 complete ======
	@ echo ==================================

15-stamp: 14-stamp $(axiom_algebra_layer_15_objects)
	@ rm -f 15-stamp
	@ $(STAMP) 15-stamp
	@ echo ==================================
	@ echo === layer 15 of 23 complete ======
	@ echo ==================================

16-stamp: 15-stamp $(axiom_algebra_layer_16_objects)
	@ rm -f 16-stamp
	@ $(STAMP) 16-stamp
	@ echo ==================================
	@ echo === layer 16 of 23 complete ======
	@ echo ==================================

17-stamp: 16-stamp $(axiom_algebra_layer_17_objects)
	@ rm -f 17-stamp
	@ $(STAMP) 17-stamp
	@ echo ==================================
	@ echo === layer 17 of 23 complete ======
	@ echo ==================================

18-stamp: 17-stamp $(axiom_algebra_layer_18_objects)
	@ rm -f 18-stamp
	@ $(STAMP) 18-stamp
	@ echo ==================================
	@ echo === layer 18 of 23 complete ======
	@ echo ==================================

19-stamp: 18-stamp $(axiom_algebra_layer_19_objects)
	@ rm -f 19-stamp
	@ $(STAMP) 19-stamp
	@ echo ==================================
	@ echo === layer 19 of 23 complete ======
	@ echo ==================================

20-stamp: 19-stamp $(axiom_algebra_layer_20_objects)
	@ rm -f 20-stamp
	@ $(STAMP) 20-stamp
	@ echo ==================================
	@ echo === layer 20 of 23 complete ======
	@ echo ==================================

21-stamp: 20-stamp $(axiom_algebra_layer_21_objects)
	@ rm -f 21-stamp
	@ $(STAMP) 21-stamp
	@ echo ==================================
	@ echo === layer 21 of 23 complete ======
	@ echo ==================================

22-stamp: 21-stamp $(axiom_algebra_layer_22_objects)
	@ rm -f 22-stamp
	@ $(STAMP) 22-stamp
	@ echo ==================================
	@ echo === layer 22 of 23 complete ======
	@ echo ==================================

23-stamp: 22-stamp $(axiom_algebra_layer_23_objects)
	@ rm -f 23-stamp
	@ $(STAMP) 23-stamp
	@ echo ==================================
	@ echo === layer 23 of 23 complete ======
	@ echo ==================================

bootstrap-stamp: 23-stamp $(axiom_algebra_bootstrap_last_layer_objects)
	@ rm -f bootstrap-stamp
	@ $(STAMP) bootstrap-stamp
	@ echo ==================================
	@ echo ===    algebra complete     ======
	@ echo ==================================

user-stamp: $(axiom_algebra_layer_user_objects)
	@ rm -f user-stamp
	@ $(STAMP) user-stamp


@

\section{The Makefile}

<<*>>=
<<environment>>

subdir = src/algebra/

<<layer0 bootstrap>>
<<layer0 copy>>
<<layer0>> 
<<layer1>>
<<layer2>>
<<layer3>>
<<layer4>>
<<layer5>>
<<layer6>>
<<layer7>>
<<layer8>>
<<layer9>>
<<layer10>>
<<layer11>>
<<layer12>>
<<layer13>>
<<layer14>>
<<layer15>>
<<layer16>>
<<layer17>>
<<layer18>>
<<layer19>>
<<layer20>>
<<layer21>>
<<layer22>>
<<layer23>>
<<USERLAYER>>

.PHONY: all all-algebra mkdir-output-directory
all: all-ax

all-ax all-algebra: stamp
	@ echo finished $(builddir)

stamp: mkdir-output-directory ${SPADFILES} user-stamp ${TESTS}
	-rm -f stamp
	$(STAMP) stamp

mkdir-output-directory:
	$(mkdir_p) $(OUTSRC)

everything: check lib db cmd gloss
	@ echo 4303 invoking make in `pwd` with parms:

check:
	@ echo 4305 Checking that INTERP.EXPOSED and NRLIBs are consistent
	@ echo 4306 libcheck needs to use exposed.lsp, not INTERP.EXPOSED


<<genericRules>>

<<testrules>>
<<diagrams.tex (OUT from IN)>>
<<stages>>


.PHONY: all-algstrap
all-algstrap: $(addsuffix .NRLIB/code.lsp,$(axiom_algebra_bootstrap))
	for a in $(axiom_algebra_bootstrap); do \
	  old=$(srcdir)/strap/$$a.lsp; new=$$a.NRLIB/code.lsp; \
	  cmp -s $$new $$old || cp -p $$new $$old || exit 1; \
	done

mostlyclean-local:
	@rm -f $(OUT)/*.$(FASLEXT) $(OUT)/*.daase
	@rm -rf *.NRLIB
	@rm -rf *.DAASE *.daase libdb.text
	@rm -rf strap
	@rm -f *stamp

clean-local: mostlyclean-local

distclean-local: clean-local

include extract-spad.mk

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
