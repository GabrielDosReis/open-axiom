)abbrev domain SCONF SConformal
++ Author: Martin Baker
++ Date Created: September 2010
++ Date Last Updated: September 2010
++ Basic Operations: point, elt, setelt, copy, dimension, minIndex, maxIndex,
++ convert
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/graph/
++ Description: an implementation of PointCategory to represent points and
++ vectors in n+2 dimensional conformal space based on n dimensional
++ Euclidean space.

SConformal(n) : Exports == Implementation where
  ++ Domain for representing points, vectors, subspaces and properties
  ++ of conformal space 
  n: PositiveInteger
    ++ number of base dimensions (excluding point at infinity and point
    ++ at origin)
  PI ==> PositiveInteger
  DF ==> DoubleFloat
  --
  -- What I would like to do is be able to coerce to a CliffordAlgebra
  -- with a specific signature representing conformal space
  -- however Axiom does not allow a specific matrix to be
  -- created here.
  --bLin ==> squareMatrix([[1@DF,0@DF,0@DF,0@DF],_
  --                     [0@DF,1@DF,0@DF,0@DF],_
  --                     [0@DF,0@DF,1@DF,0@DF],_
  --                     [0@DF,0@DF,0@DF,1@DF]])
  --CA ==> CliffordAlgebra(4,DF,bLin)

  Exports ==  SPointCategory() with
    normalisePoint:(pt:%) -> %
      ++ normalalised point has scalar value of one, if this is not the
      ++ case then scale values

    --coerce: % -> CA
    --coerce: CA -> %

  Implementation ==>  add
    ---- start of common code to all SPointCategory implementations ----
    -- I would like to define these in SPointCategory but that won't work
    -- due to lack of polymorphism in spad

    -- Measure of how parallel two vectors are independant of the length
    -- of the vectors:
    -- 1.0 is complelely parallel
    -- 0.0 is completely perpendicular
    -- returned value will be these or between these 
    colinearity(x,y) == parallel(x,y)**2/_
                 (parallel(x,x) * parallel(y,y))

    -- convenience constructors which allow us to construct using
    -- integer values
    sipnt(a,b) == spnt(a::DoubleFloat,b::DoubleFloat)
    sipnt(a,b,c) ==
      spnt(a::DoubleFloat,b::DoubleFloat,c::DoubleFloat)
    sivec(a,b) == svec(a::DoubleFloat,b::DoubleFloat)
    sivec(a,b,c) ==
      svec(a::DoubleFloat,b::DoubleFloat,c::DoubleFloat)

    -- returns the distance between the points p1 and p2
    -- there are 2 metrics associated with any SPointCategory
    -- the underlying space and the space that it is embedded in
    -- this is the distance in the underlying space.
    distance(p1,p2) ==
      sqrt(distanceSquared(p1,p2))

    ---- end of common code to all SPointCategory implementations ----

    dim := 2**(n+2)
      ++ the total dimension of all the grades from scalar up to
      ++ pseudoscalar

    z: %

    Rep := PrimitiveArray DF

    New ==> new(dim, 0$DF)$Rep

    -- spnt(a,b) constructs a 2D point defined by a and b
    -- of type DF
    -- z.1 is point at zero which is set to -1
    -- z.2 is point at infinity which is set to a^2 + b^2
    -- z.4 is a
    -- z.8 is b
    spnt(a,b) ==
      inf:DF := (a*a + b*b)*0.5::DF
      (z := New; z.1 := -1@DF; z.2 := inf; z.4 := a; z.8 := b; z)

    -- spnt(a,b,c) constructs a 3D point defined by a,b and c
    -- of type DF
    -- z.1 is point at zero which is set to -1
    -- z.2 is point at infinity which is set to a^2 + b^2
    -- z.4 is a
    -- z.8 is b
    -- z.16 is c
    spnt(a,b,c) ==
      inf:DF := (a*a + b*b + c*c)*0.5::DF
      z := New; z.1 := -1@DF; z.2 := inf
      z.4 := a; z.8 := b
      if n>2 then z.16 := c
      z

    -- svec(a,b) constructs a 2D vector defined by a and b
    -- of type DF
    svec(a,b) ==
      inf:DF := (a*a + b*b)*0.5::DF
      (z := New; z.1 := -1@DF; z.2 := inf; z.4 := a; z.8 := b; z)

    -- svec(a,b,c) constructs a 3D vector defined by a,b and c
    -- of type DF
    -- since this is a 2D space we ignore 3rd dimension
    svec(a,b,c) ==
      inf:DF := (a*a + b*b + c*c)*0.5::DF
      z := New; z.1 := -1@DF; z.2 := inf
      z.4 := a; z.8 := b
      if n>2 then z.16 := c
      z

    dimension p == 2  -- dimension of base space

    -- Test for NaN (Not a Number)
    -- That is have we divided by zero or taken sqrt of negative number at
    -- some stage?
    -- Common Lisp does not support NaN ? So we need some sort of test for
    -- invalid numbers
    -- If not equal to itself then we assume that its not a valid number
    -- an altenative approach is to check for complex numbers 
    -- COMPLEXP(x)$Lisp since lisp supports complex numbers?
    nan?(x:DF):Boolean == x ~= x

    -- Is this a valid point? if any of its elements are not valid
    -- then return true
    -- Examples of invalid floating point numbers are when have we
    -- have divided a given element by zero or taken
    -- sqrt of negative number at some stage?
    -- Note: we can still represent a point at infinity and we can
    -- represent points using complex numbers, but we do this using
    -- projective or conformal space or by using the appropriate
    -- instance of SPointCategory, not by using invalid floating
    -- point numbers.
    Pnan?(p) ==
      nan?(p.4) => true
      nan?(p.8) => true
      false

    -- scale until length is 1
    unitVector(p) ==
      factor := sqrt(p.4*p.4 + p.8*p.8)
      pt := New
      pt.4 := p.4/factor
      pt.8 := p.8/factor
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- This returns the length of the parallel component of two vectors
    -- in the case of Euclidean space this is the dot product of two
    -- vectors. We use this function to test the colinearity
    parallel(x,y) == x.6 * y.6 + x.10 * y.10

    -- This returns a vector perpendicular to the two vectors
    -- in the case of 3D Euclidean space this is the cross product of the
    -- two vectors. We use this function to compute orthogonal
    perpendicular(x,y) ==
      pt := New
      pt.4 := 0@DF
      pt.8 := 1@DF
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- scalar multiplication
    _*(s,x) ==
      pt := New
      pt.4 := x.4 * s
      pt.8 := x.8 * s
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- addition
    _+(x,y) ==
      pt := New
      pt.4 := x.4 + y.4
      pt.8 := x.8 + y.8
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- subtraction
    _-(x,y) ==
      pt := New
      pt.4 := x.4 - y.4
      pt.8 := x.8 - y.8
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- return true if param is inside bounding box
    -- where bounding box is specified by min and max
    inBounds?(pt,mns,mxs) ==
     -- left of box - check minimum x
      qelt(pt,4) < qelt(mns,4) => false
      -- right of box - check maximum x
      qelt(pt,4) > qelt(mxs,4) => false
      -- below box - check minimum y
      qelt(pt,8) < qelt(mns,8) => false
      -- above box - check maximum y
      qelt(pt,8) > qelt(mxs,8) => false
      -- inside box so return true
      true

   -- returns the 'x'(left to right) screen coordinate
    screenCoordX(pt) == pt.4

    -- returns the 'y'(bottom to top) screen coordinate
    screenCoordY(pt) == pt.8

    -- returns the 'z'(out from screen) screen coordinate
    screenCoordZ(pt) == if n>2 then pt.16 else 0@DF

    -- returns screen coordinates as a list
    screenCoords(pt) ==
      if n>2 then return [pt.4,pt.8,pt.16]
      [pt.4,pt.8]

    -- returns extended coordinates as a list
    extendedCoords(pt) == entries(pt)


    -- normalised point has scalar value of one, if this is not the
    -- case then scale values
    normalisePoint(pt) ==
      scaleFactor:DF := pt.1
      if scaleFactor < 0.01::DF and scaleFactor > -0.01::DF then
        sayTeX$Lisp "can't apply normalisePoint to a vector"
        return pt
      if scaleFactor < -0.99::DF and scaleFactor > -1.01::DF then
        return pt
      pt2 := New
      infin := 0@DF
      for x in 1..n repeat
        index := 2**(x+1)
        pt2.index := pt.index / (-scaleFactor)
        infin := infin + ((pt2.index)*(pt2.index))*0.5::DF
      pt2.1 := -1@DF
      pt2.2 := infin
      sayTeX$Lisp concat([_
        "normalisePoint ",(mathObject2String$Lisp pt)@String,_
        " normalised to ",(mathObject2String$Lisp pt2)@String,_
        ")"])$String
      pt2

--    coerce(me: %):C ==
--      multivector(extendedCoords(me))$C

--    coerce(cmpx: C):% ==
--      [real(cmpx),imag(cmpx)]

    -- start of SetCategory definitions --

    hash(s) == 0$SingleInteger

    latex(s) == "\mbox{\bf Unimplemented}"

    -- returns true if x equals y
    _=(x,y) ==
      for i in 0..(dim-1) repeat
        if x.i ~= y.i then return false
      true

    -- returns true if x is not equal to y
    _~_=(x,y) == not(x=y)

    -- output
    coerce(pt) ==
      s:String := "proj"
      if pt.4 = 0@DF then s := "v"
      if pt.4 = 1@DF then s := "p"
      paren([s::OutputForm,(pt.4)::OutputForm,(pt.8)::OutputForm])$OutputForm
