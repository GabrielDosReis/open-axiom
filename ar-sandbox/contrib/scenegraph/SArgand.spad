)abbrev domain SARGND SArgand
++ Author: Martin Baker
++ Date Created: September 2010
++ Date Last Updated: September 2010
++ Basic Operations: point, elt, setelt, copy, dimension, minIndex, maxIndex,
++ convert
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/graph/
++ Description: an implementation of PointCategory to represent points and
++ vectors in an Argand plane

SArgand() : Exports == Implementation where
  ++ Domain for representing points, vectors, subspaces and properties
  ++ of components in a subspace as complex numbers
  DF ==> DoubleFloat
  C ==> Complex DF
  PI   ==> PositiveInteger

  Exports ==  SPointCategory() with
    coerce: % -> C
    coerce: C -> %

  Implementation ==>  add
    ---- start of common code to all SPointCategory implementations ----
    -- I would like to define these in SPointCategory but that won't work
    -- due to lack of polymorphism in spad

    -- Measure of how parallel two vectors are independant of the length
    -- of the vectors:
    -- 1.0 is complelely parallel
    -- 0.0 is completely perpendicular
    -- returned value will be these or between these 
    colinearity(x,y) == parallel(x,y)**2/_
                 (parallel(x,x) * parallel(y,y))

    -- convenience constructors which allow us to construct using
    -- integer values
    sipnt(a,b) == spnt(a::DoubleFloat,b::DoubleFloat)
    sipnt(a,b,c) ==
      spnt(a::DoubleFloat,b::DoubleFloat,c::DoubleFloat)
    sivec(a,b) == svec(a::DoubleFloat,b::DoubleFloat)
    sivec(a,b,c) ==
      svec(a::DoubleFloat,b::DoubleFloat,c::DoubleFloat)

    -- returns the distance between the points p1 and p2
    -- there are 2 metrics associated with any SPointCategory
    -- the underlying space and the space that it is embedded in
    -- this is the distance in the underlying space.
    distance(p1,p2) ==
      sqrt(distanceSquared(p1,p2))

    ---- end of common code to all SPointCategory implementations ----

    Rep := Record(r:DF,i:DF)

    -- spnt(a,b) constructs a 2D point defined by a and b
    -- of type DF
    spnt(a,b) ==
      --sayTeX$Lisp concat([_
      --  "spnt(",(mathObject2String$Lisp a)@String,_
      --  ",",(mathObject2String$Lisp b)@String,_
      --  ")"])$String
      [a,b]

    -- spnt(a,b,c) constructs a 3D point defined by a,b and c
    -- of type DF
    spnt(a,b,c) ==
      [a,b]

    -- svec(a,b) constructs a 2D vector defined by a and b
    -- of type DF
    svec(a,b) ==
      [a,b]

    -- svec(a,b,c) constructs a 3D vector defined by a,b and c
    -- of type DF
    svec(a,b,c) ==
      [a,b]

    dimension p == 2  -- dimension of base space

    -- Test for NaN (Not a Number)
    -- That is have we divided by zero or taken sqrt of negative number at
    -- some stage? Common Lisp does not support NaN ? So we need some sort
    -- of test for invalid numbers
    -- If not equal to itself then we assume that its not a valid number
    -- an altenative approach is to check for complex numbers 
    -- COMPLEXP(x)$Lisp since lisp supports complex numbers?
    nan?(x:DF):Boolean == x ~= x

    -- Is this a valid point? if any of its elements are not valid
    -- then return true
    -- Examples of invalid floating point numbers are when have we
    -- have divided a given element by zero or taken
    -- sqrt of negative number at some stage?
    -- Note: we can still represent a point at infinity and we can
    -- represent points using complex numbers, but we do this using
    -- projective or conformal space or by using the appropriate
    -- instance of SPointCategory, not by using invalid floating
    -- point numbers.
    Pnan?(p) == 
      nan?(p.r) => true
      nan?(p.i) => true
      false

    -- scale until length is 1
    unitVector(p) ==
      factor := sqrt(p.r * p.r + p.i * p.i)
      [p.r/factor,p.i/factor]

    -- returns the distance between the points p1 and p2
    -- there are 2 metrics associated with any SPointCategory
    -- the underlying space and the space that it is embedded in
    -- this is the distance in the underlying space.
    distanceSquared(p1,p2) ==
      (p1.r - p2.r)**2 + (p1.i - p2.i)**2

    -- This returns the length of the parallel component of two vectors
    -- in the case of Euclidean space this is the dot product of two
    -- vectors. We use this function to test the colinearity
    parallel(x,y) == x.r * y.r + x.i * y.i

    -- This returns a vector perpendicular to the two vectors
    -- in the case of 3D Euclidean space this is the cross product of the
    -- two vectors. We use this function to compute orthogonal
    -- In this case set to arbitary value
    perpendicular(x,y) ==
      [0@DF,1@DF]

    -- scalar multiplication
    _*(s,x) ==
      [x.r * s,x.i * s]

    -- addition
    _+(x,y) ==
      [x.r + y.r,x.i + y.i]

    -- addition
    _-(x,y) ==
      [x.r - y.r,x.i - y.i]

    -- return true if param is inside bounding box
    -- where bounding box is specified by min and max
    inBounds?(pt,mns,mxs) ==
      -- left of box - check minimum x
      pt.r pretend DoubleFloat < mns.r pretend DoubleFloat => false
      -- right of box - check maximum x
      pt.r pretend DoubleFloat > mxs.r pretend DoubleFloat => false
      -- below box - check minimum y
      pt.i pretend DoubleFloat < mns.i pretend DoubleFloat => false
      -- above box - check maximum y
      pt.i pretend DoubleFloat > mxs.i pretend DoubleFloat => false
      -- inside box so return true
      true

    -- returns the 'x'(left to right) screen coordinate
    screenCoordX(pt) == pt.r

    -- returns the 'y'(bottom to top) screen coordinate
    screenCoordY(pt) == pt.i

    -- returns the 'z'(out from screen) screen coordinate
    screenCoordZ(pt) == 0@DF

    -- returns screen coordinates as a list
    screenCoords(pt) == [pt.r,pt.i]

    -- returns extended coordinates as a list
    extendedCoords(pt) == [pt.r,pt.i]

    coerce(me: %):C ==
      complex(me.r,me.i)

    coerce(cmpx: C):% ==
      [real(cmpx),imag(cmpx)]

    -- start of SetCategory definitions --

    hash(s) == 0$SingleInteger

    latex(s) == "\mbox{\bf Unimplemented}"

    -- returns true if x equals y
    _=(x,y) ==
      if x.r ~= y.r then return false
      if x.i ~= y.i then return false
      true

    -- returns true if x is not equal to y
    _~_=(x,y) == not(x=y)

    -- output
    coerce(pt: %):OutputForm ==
      paren([(pt.r)::OutputForm,(pt.i)::OutputForm])$OutputForm
