)abbrev domain CLIF CliffordAlgebra
++ Author: Martin Baker (adapted from a version by Stephen M. Watt)
++ Date Created: August 1988
++ Date Last Updated: Dec 2009
++ Basic Operations: wholeRadix, fractRadix, wholeRagits, fractRagits
++ Related Domains: QuadraticForm, Quaternion, Complex
++ Also See:
++ AMS Classifications:
++ Keywords: clifford algebra, grassmann algebra, spin algebra
++ Examples:
++ References:
++
++ Description:
++  CliffordAlgebra(n, K, bLin) defines a module of dimension \spad{2^n}
++  over K, given a bilinear form bLin on \spad{K^n}.
++
++  Examples of Clifford Algebras are: gaussians, quaternions, exterior
++  algebras and spin algebras.

CliffordAlgebra(n, K, bLin): T == Impl where
    n: PositiveInteger
    K: Field
    bLin: SquareMatrix(n, K)

    PI ==> PositiveInteger
    NNI==> NonNegativeInteger
    SINT==> SingleInteger

    T ==> Join(Ring, Algebra(K)) with
        e: PI -> %
          ++ e(n) produces phi(e_i) where e_i is i-th basis
          ++ vector in K^n and phi is canonical embedding of
          ++ K^n into Clifford algebra.
        ee: List PI -> %
          ++ to allow entries like: ee[1,2]
        multivector: List K -> %
          ++ to allow entries like: 1+2*e1+3*e2+4*e1e2 = multivector[1,2,3,4]
        eFromBinaryMap: NNI -> %
          ++ eFromBinaryMap(n) sets the appropriate Grassmann basis, for example:
          ++ eFromBinaryMap(0) = 1  (scalar)
          ++ eFromBinaryMap(1) = e1
          ++ eFromBinaryMap(2) = e2
          ++ eFromBinaryMap(3) = e1/\e2
        ePseudoscalar: () -> %
          ++ unit pseudoscalar
        grade: (%) -> NNI
          ++ return the max grade of multivector, for example
          ++ 1 is grade 0
          ++ e1 is grade 1
          ++ e1/\e2 is grade 2 and so on
        monomial: (K, List PI) -> %
          ++ monomial(c,[i1,i2,...,iN]) produces the value given by
          ++ \spad{c*e(i1)*e(i2)*...*e(iN)}.
        coefficient:  (%, List PI) -> K
          ++ coefficient(x,[i1,i2,...,iN])  extracts the coefficient of
          ++ \spad{e(i1)*e(i2)*...*e(iN)} in x.
        recip: % -> Union(%, "failed")
          ++ recip(x) computes the multiplicative inverse of x or "failed"
          ++ if x is not invertible.
        toTable: ((%, %) -> %) -> Matrix %
          ++ displays multiplication table for binary operation which
          ++ is represented as a function with two parameters.
          ++ row number represents first operand in binary order
          ++ column number represents second operand in binary order
          ++ could have returned type 'List List %' but matrix displays better
        toTable: ((%) -> %) -> Matrix %
          ++ displays table of unary function such as inverse, reverse,
          ++ complement, or dual basis
          ++ could have returned type 'List List %' but matrix displays better
        _/_\: (%, %) -> %
          ++ Implement exterior grassmann product operator
          ++ need to check precidence when used as an infix operator
        _\_/: (%, %) -> %
          ++ Implement regressive inner,meet product operator
          ++ need to check precidence when used as an infix operator
        lc: (%, %) -> %
          ++ left contraction inner product
        rc: (%, %) -> %
          ++ right contraction inner product
        _~: (%) -> %
          ++ reverse, complement,canonical dual basis
        gradeInvolution: (%) -> %
          ++ x = ((-1)^grade(x))*x
        reverse: (%) -> %
          ++ implements reverse for a single term by using:
          ++ grade: 0  1  2  3...
          ++ multi: 1  1 -1 -1...
        conj: (%) -> %
          ++ implements Clifford conjugate for a multivector by involution and reverse
          ++ of each term seperately using:
          ++ grade: 0  1  2  3...
          ++ multi: 1 -1 -1  1...
        setMode: (String,Boolean) -> Boolean
          ++ allows override of parameters such as orthogonal
          ++ used for debugging


    Impl ==> add
        Qeelist:Vector K :=  diagonal(bLin)::Vector K
          ++ contains the diagonal terms of bLin (what the base vectors square to)
        orthogonal:Boolean :=  diagonal?(bLin)
          ++ true if bininear form is diagonal (non diagonal terms are zero)
        debug:Boolean := false
          ++ if set to true displays working when calculating results
        dim     :=  2**n
          ++ the total dimension of all the grades from scalar up to pseudoscalar
        Rep     := PrimitiveArray K
          ++ array of Field which can hold the multivector values
        New     ==> new(dim, 0$K)$Rep

        x, y, z: %
        c: K
        m: Integer

        characteristic() == characteristic()$K
        dimension(): CardinalNumber == dim::CardinalNumber

        x = y ==
            for i in 0..dim-1 repeat
                if x.i ~= y.i then return false
            true

        x + y == (z := New; for i in 0..dim-1 repeat z.i := x.i + y.i; z)
        x - y == (z := New; for i in 0..dim-1 repeat z.i := x.i - y.i; z)
        - x   == (z := New; for i in 0..dim-1 repeat z.i := - x.i; z)
        m * x == (z := New; for i in 0..dim-1 repeat z.i := m*x.i; z)
        c * x == (z := New; for i in 0..dim-1 repeat z.i := c*x.i; z)
        -- we want module over non-commutative
        -- but no available signatures for:
        --x * m == (z := New; for i in 0..dim-1 repeat z.i := x*m.i; z)
        --x * c == (z := New; for i in 0..dim-1 repeat z.i := x*c.i; z)

        0            == New
        1            == (z := New; z.0 := 1; z)
        coerce(m): % == (z := New; z.0 := m::K; z)
        coerce(c): % == (z := New; z.0 := c; z)

        -- output single term to string
        -- this produces a simple one line string unlike coerceMonom
        -- no formatting such as subscript is done
        -- this is intended mainly for debug purposes
        toStringTerm(c: K, b: SINT): String ==
            mult:String := (mathObject2String$Lisp c)@String
            b = 0 => mult
            c = 0 => "0"
            if c=1 then mult := "e"
            if c= -1 then mult := "-e"
            if c~=1 and c~= -1 then mult := concat(mult,"e")
            for i in 0..n-1 repeat
              if bit?(b,i) then mult := concat(mult,string(i+1)$String)
            mult

        -- output multivector to string
        -- this produces a simple one line string unlike coerce(x): Ex
        -- no formatting such as subscript is done
        -- this is intended mainly for debug purposes
--        toString(m:%): String ==
--            res:String := ""
--            for im in 0..dim-1 repeat
--              if m.im ~= 0 then
--                s:String := (mathObject2String$Lisp m.im)@String
--                neg:Boolean := false
--                if #s > 0 then neg := (s.1 = char "-")
--                if res ~= "" and not neg then
--                  res := concat[res,"+",toStringTerm(m.im,im)]
--                if res = "" or neg then
--                  res := concat(res,toStringTerm(m.im,im))
--            if res = "" then res:="0"
--            res
--
        -- NOTE tempoary name change to: es(n) to avoid name clash with e(l) below
        -- e(n) produces the appropriate unit element.
        --        iz   z
        -- e(1) = 1    e1
        -- e(2) = 2    e2
        -- e(3) = 4    e3
        e b ==
            b::NNI > n => error "No such basis element"
            iz := 2**((b-1)::NNI)
            z := New; z.iz := 1; z

        -- to allow entries like e[1,2]
        ee(l) ==
          lst:List % := [e i for i in l]
          reduce(_/_\, lst , 1)

        -- to allow entries like: 1+2*e1+3*e2+4*e1e2 = multivector[1,2,3,4]
--        multivector(scalar:List K) == (z := New; for i in 0..dim-1 repeat z.i := scalar(i+1); z)
--acr begin
        multivector(scalar:List K) == 
	  z := New
	  for i in 0..dim-1 repeat
	    z.i := scalar(i+1)
	  z
--acr end
        -- eFromBinaryMap(n) sets the appropriate unit elements, for example,
        -- eFromBinaryMap(0) = 1  (scalar)
        -- eFromBinaryMap(1) = e1
        -- eFromBinaryMap(2) = e2
        -- eFromBinaryMap(3) = e1/\e2
        eFromBinaryMap b ==
            b >= dim => error "Too big"
            z := New; z.b := 1; z

        -- unit pseudoscalar
        ePseudoscalar() ==
            p := New
            i := (dim-1)::NNI
            p.i := 1
            p

        -- displays multiplication table for binary operation which
        -- is represented as a function with two parameters.
        -- row number represents first operand in binary order
        -- column number represents second operand in binary order
        -- could have returned type 'List List %' but matrix displays better
        toTable(fn:(%, %) -> %) ==
          l: List % := [eFromBinaryMap(i) for i in 0..dim-1]
          matrix [[fn(k,j) for j in l] for k in l]

        -- displays table of unary function such as inverse, reverse, complement,
        -- or dual basis
        -- could have returned type 'List List %' but matrix displays better
        toTable(fn:(%) -> %) ==
          l: List % := [eFromBinaryMap(i) for i in 0..dim-1]
          matrix [[j for j in l],[fn(k) for k in l]]

        -- return the grade of the term, for example
        -- 1 is grade 0
        -- e1 is grade 1
        -- e1^e2 is grade 2 and so on
        gradeTerm(b:SINT): NNI ==
          grade:NNI := 0
          for i in 0..n-1 repeat
            if bit?(b,i) then grade := grade + 1
          grade

        -- return the max grade of multivector, for example
        -- 1 is grade 0
        -- e1 is grade 1
        -- e1/\e2 + e1 is grade 2 and so on
        grade(x:%): NNI ==
          gr:NNI := 0
          for ix in 0..dim-1 repeat
            if x.ix ~= 0 then
              gr := max(gr,gradeTerm(ix::SINT))
          gr

        -- implements gradeInvolution for a single term by using:
        -- x = ((-1)^grade(x))*x
        gradeInvolutionTerm(mult: K,type1:SINT): % ==
          resul:% := New; resul.type1:=mult
          g:NNI := gradeTerm(type1)
          sign:Integer := if odd?(g) then -1 else 1
          resul := sign*resul
          resul

        -- implements gradeInvolution for a multivector by involution
        -- of each term seperately using:
        -- x = ((-1)^grade(x))*x
        gradeInvolution(x:%): % ==
            z := New
            for ix in 0..dim-1 repeat
                if x.ix ~= 0 then z := z + gradeInvolutionTerm(x.ix,ix::SINT)
            z

        -- implements reverse for a single term by using:
        -- grade: 0  1  2  3...
        -- multi: 1  1 -1 -1...
        reverseTerm(mult: K,type1:SINT): % ==
          resul:% := New; resul.type1:=mult
          g := gradeTerm(type1)::SINT
          sign:Integer := if odd?(shift(g,-1)) then -1 else 1
          resul := sign*resul
          resul

        -- implements reversal for a multivector by reverse
        -- of each term seperately using:
        -- grade: 0  1  2  3...
        -- multi: 1  1 -1 -1...
        reverse(x:%): % ==
            z := New
            for ix in 0..dim-1 repeat
                if x.ix ~= 0 then z := z + reverseTerm(x.ix,ix::SINT)
            z

        -- implements Clifford conjugation for a single term by using:
        -- grade: 0  1  2  3...
        -- multi: 1 -1 -1  1...
        conjTerm(mult: K,type1:SINT): % ==
          resul:% := New; resul.type1:=mult
          g := gradeTerm(type1)::SINT
          sign:Integer := if odd?(shift(g+1,-1)) then -1 else 1
          resul := sign*resul
          resul

        -- implements Clifford conjugate for a multivector by involution and reverse
        -- of each term seperately using:
        -- grade: 0  1  2  3...
        -- multi: 1 -1 -1  1...
        conj(x:%): % ==
            z := New
            for ix in 0..dim-1 repeat
                if x.ix ~= 0 then z := z + conjTerm(x.ix,ix::SINT)
            z

        -- allows override of parameters such as orthogonal
        -- used for debugging
        setMode(s:String,val:Boolean): Boolean ==
          if s = "orthogonal" then (orthogonal := val; return true)
          if s = "debug" then (debug := val; return true)
          false

        -- return the base vector number from binary, for example
        -- binary for e1 is 001 which returns 1
        -- binary for e2 is 010 which  returns 2 and so on
        baseVect(b:SINT): NNI ==
          for i in 0..n-1 repeat
            if bit?(b,i) then return i+1
          0

        -- return a term from bilinear product
        bilinear(b1:SINT,b2:SINT): K ==
          bv1 := baseVect(b1)
          bv2 := baseVect(b2)
          if bv1 = 0$NNI then return 0
          if bv2 = 0$NNI then return 0
          bLin(bv1,bv2)

        -- for a given term, return the base furthest on the left, for example
        -- e1^e2^e3
        -- would return e1
        leftMostBase(b:SINT): SINT ==
          mask:SINT := 1
          for i in 0..n-1 repeat
            if And(mask,b) ~= 0 then return mask
            mask := shift(mask,1)::SINT
          0

        -- for a given term, return the base furthest on the right, for example
        -- e1^e2^e3
        -- would return e3
        rightMostBase(b:SINT): SINT ==
          mask:SINT := shift(1,(n-1)::SINT)$SINT
          for i in 0..n-1 repeat
            if And(mask,b) ~= 0 then return mask
            mask := shift(mask,-1)::SINT
          0

        -- Implement exterior grassmann product on individual term in a
        -- multivector.
        exteriorProdTerm(op1mult: K, op1type:SINT, op2mult: K, op2type:SINT): % ==
          resul:% := New
          And(op1type,op2type) ~= 0 => resul -- if common terms return without adding
          c := op1mult * op2mult
          bz := Or(op1type,op2type)-- combine terms from both operands
          for i in 0..n-1 | bit?(op1type,i) repeat
            -- Apply rule  ei*ej = -ej*ei for i ~= j
            k := 0
            for j in i+1..n-1 | bit?(op1type, j) repeat k := k+1
            for j in 0..i-1   | bit?(bz, j) repeat k := k+1
            if odd? k then c := -c
          resul.bz := resul.bz + c
          resul

        -- Implement regressive inner,meet product on individual term in a
        -- multivector.
        regressiveProdTerm(op1mult: K, op1type:SINT, op2mult: K, op2type:SINT): % ==
          op1 := New; op1.op1type := 1$K
          op2 := New; op2.op2type := 1$K
          res := _/_\(op2*ePseudoscalar(),op1*ePseudoscalar()) *ePseudoscalar()
          res := (op1mult * op2mult)*res
          res

        -- Implement exterior grassmann product
        _/_\(x:%,y:%): % ==
            z := New
            for ix in 0..dim-1 repeat
                if x.ix ~= 0 then for iy in 0..dim-1 repeat
                    if y.iy ~= 0 then z := z + exteriorProdTerm(x.ix,ix::SINT,y.iy,iy::SINT)
            z

        -- Implement regressive inner,meet product operator
        _\_/(x:%,y:%): % ==
            z := New
            for ix in 0..dim-1 repeat
                if x.ix ~= 0 then for iy in 0..dim-1 repeat
                    if y.iy ~= 0 then z := z + regressiveProdTerm(x.ix,ix::SINT,y.iy,iy::SINT)
            z

        -- Implement left contraction on individual term in a
        -- multivector.
        lcProdTerm(op1mult: K, op1type:SINT, op2mult: K, op2type:SINT): % ==
          resul:% := New
          grade1 := gradeTerm(op1type) -- grade of first operand
          grade2 := gradeTerm(op2type) -- grade of second operand
          if grade1 = 0 then -- 1st operand is scalar so return scalar product
            resul.op2type := resul.op2type + op1mult*op2mult
            return resul
          grade2 = 0 => resul -- 2nd operand is scalar so return 0
          if grade1 = 1 and grade2 = 1 then -- vect _| vect = bilinear
            resul.(0$NNI) := resul.(0$NNI) + op1mult * op2mult * bilinear(op1type,op2type) -- add scalar term
            return resul
          if grade1 = 1 then -- 1st operand is vector so apply: x_|(u^v)=(x_|u)^v - u^(x_|v)
            uType:SINT := leftMostBase(op2type) -- highest ^factor
            vType:SINT := xor(op2type,uType) -- remaining ^factors
            inner2:% := New; inner2.vType := 1$K
            left:% := _/_\(lcProdTerm(op1mult, op1type,op2mult, uType),inner2)
            inner4:% := New; inner4.uType := 1$K
            resul := resul + left + _/_\(inner4,lcProdTerm(-op1mult, op1type,op2mult, vType))
            return resul
          -- if none of the above is true then apply:
          -- (u/\v) _| w = u _| (v _| w)
          uType:SINT := leftMostBase(op1type) -- highest ^factor
          vType:SINT := xor(op1type,uType) -- remaining ^factors
          inner2:% := New
          inner2.uType := 1$K
          resul := resul+ lc(inner2,lcProdTerm(op1mult,vType,op2mult,op2type))
          resul

        -- Implement right contraction on individual term in a
        -- multivector.
        rcProdTerm(op1mult: K, op1type:SINT, op2mult: K, op2type:SINT): % ==
          resul:% := New
          grade1 := gradeTerm(op1type) -- grade of first operand
          grade2 := gradeTerm(op2type) -- grade of second operand
          if grade2 = 0 then -- 2nd operand is scalar so return scalar product
            resul.op1type := resul.op1type + op1mult*op2mult
            return resul
          grade1 = 0 => resul -- 1st operand is scalar so return 0
          if grade1 = 1 and grade2 = 1 then -- vect |_ vect = bilinear
            resul.(0$NNI) := resul.(0$NNI) + op1mult * op2mult * bilinear(op1type,op2type) -- add scalar term
            return resul
          if grade2 = 1 then -- 2nd operand is vector so apply: (v^u)|_x=v^(u|_x) - (v|_x)^u
            uType:SINT := rightMostBase(op1type) -- lowest ^factor
            vType:SINT := xor(op1type,uType) -- remaining ^factors
            inner2:% := New; inner2.vType := 1$K
            right:% := _/_\(inner2,rcProdTerm(op1mult, uType,op2mult, op2type))
            inner4:% := New; inner4.uType := 1$K
            resul := resul + _/_\(rcProdTerm(op1mult, vType,-op2mult, op2type),inner4) + right
--            if debug then
--              s1 := concat[toStringTerm(op1mult,op1type),"L",toStringTerm(op2mult,op2type)]
--              s2 := concat["= ",toStringTerm(op1mult, vType),"L",toStringTerm(-op2mult, op2type)]
--              s3 := concat["/\",toString(inner4),"+",toString(right)]
--              s4 := concat("=",toString(resul))
--              sayTeX$Lisp concat ["rcProdTerm: ",s1,s2,s3,s4]
            return resul
          -- if none of the above is true then apply:
          -- w |_ (v/\u) = (w |_ v) |_ u
          uType:SINT := rightMostBase(op2type) -- lowest ^factor
          vType:SINT := xor(op2type,uType) -- remaining ^factors
          inner2:% := New
          inner2.uType := 1$K
          resul := resul+ rc(rcProdTerm(op1mult,op1type,op2mult,vType),inner2)
--          if debug then
--            s1 := concat[toStringTerm(op1mult,op1type),"L",toStringTerm(op2mult,op2type)]
--            s2 := concat["= (",toStringTerm(op1mult,op1type),"L",toStringTerm(op2mult,vType)]
--            s3 := concat(") L",toString(inner2))
--            s4 := concat("=",toString(resul))
--            sayTeX$Lisp concat ["rcProdTerm: ",s1,s2,s3,s4]
          resul

        -- Implement left contraction inner product
        lc(x:%,y:%): % ==
            z := New
            for ix in 0..dim-1 repeat
                if x.ix ~= 0 then for iy in 0..dim-1 repeat
                    if y.iy ~= 0 then z := z + lcProdTerm(x.ix,ix::SINT,y.iy,iy::SINT)
            z

        -- Implement right contraction inner product
        rc(x:%,y:%): % ==
            z := New
            for ix in 0..dim-1 repeat
                if x.ix ~= 0 then for iy in 0..dim-1 repeat
                    if y.iy ~= 0 then z := z + rcProdTerm(x.ix,ix::SINT,y.iy,iy::SINT)
            z

        -- Implement Clifford multiplication on individual term in a
        -- multivector.
        cliffordProdTerm(op1mult: K, op1type:SINT, op2mult: K, op2type:SINT): % ==
          resul:% := New
          grade1 := gradeTerm(op1type) -- grade of first operand
          grade2 := gradeTerm(op2type) -- grade of second operand
          if grade1 = 0 then -- 1st operand is scalar so return scalar product
            resul.op2type := resul.op2type + op1mult*op2mult
            return resul
          if grade2 = 0 then -- 2nd operand is scalar so return scalar product
            resul.op1type := resul.op1type + op1mult*op2mult
            return resul
          if grade1 = 1 and grade2 = 1 then -- vect * vect = bilinear + x/\y
            resul.(0$NNI) := resul.(0$NNI) + op1mult * op2mult * bilinear(op1type,op2type) -- add scalar term
            resul := resul + exteriorProdTerm(op1mult,op1type,op2mult,op2type) -- add exterior term
            return resul
          if grade1 = 1 then -- 1st operand is vector so apply:
            -- x*(u/\v) = x /\ u /\ v + x _| (u/\v)
            -- = x/\u/\v + (x_|u)/\v + gradeinvolution(u) /\ (x _| v)
            uType:SINT := leftMostBase(op2type) -- highest ^factor
            vType:SINT := xor(op2type,uType) -- remaining ^factors
            xt:% := New; xt.op1type := 1$K
            ut:% := New; ut.uType := 1$K
            vt:% := New; vt.vType := 1$K
            resul := _/_\(xt,exteriorProdTerm(1$K,uType,1$K,vType))_
              +  _/_\(lcProdTerm(1$K,op1type,1$K,uType),vt)_
              +  _/_\(gradeInvolutionTerm(1$K,uType),lcProdTerm(1$K,op1type,1$K,vType)) -- gradeinvolution(u) /\ (x _| v)
            resul := (op1mult*op2mult)*resul -- apply 'scalar' multipliers
            return resul
          if grade2 = 1 then -- 2nd operand is vector so apply:
            -- (v/\u)*x = v /\ u /\ x + rc(v/\u,x)
            -- = v/\u/\x + v/\rc(u,x) +  rc(u, x)/\ gradeinvolution(v)
            uType:SINT := rightMostBase(op1type) -- lowest ^factor
            vType:SINT := xor(op1type,uType) -- remaining ^factors
            xt:% := New; xt.op2type := 1$K
            ut:% := New; ut.uType := 1$K
            vt:% := New; vt.vType := 1$K
            resul := _/_\(exteriorProdTerm(1$K,vType,1$K,uType),xt)_
              +  _/_\(vt,rcProdTerm(1$K,uType,1$K,op2type))_
              +  _/_\(rcProdTerm(1$K,vType,1$K,op2type),gradeInvolutionTerm(1$K,uType)) -- (v |_ x)/\ gradeinvolution(u)
            resul := (op1mult*op2mult)*resul -- apply 'scalar' multipliers
            return resul
          -- if none of the above is true then apply:
          -- (u /\ x) * v = u * (x _| v + x /\v) - (u |_ x) * v
          xType:SINT := rightMostBase(op1type) -- highest ^factor
          uType:SINT := xor(op1type,xType) -- remaining ^factors
          ut:% := New; ut.uType := 1$K
          vt:% := New; vt.op2type := 1$K
          -- factor1 := x * v = x _| v + x /\v
          -- factor1:% := cliffordProdTerm(1$K,xType,1$K,op2type)
          factor1:% := lcProdTerm(1$K,xType,1$K,op2type)_
            + exteriorProdTerm(1$K,xType,1$K,op2type)
          -- factor2 := u |_ x
          factor2:% := rcProdTerm(1$K,uType,1$K,xType)
          resul := ut * factor1 - factor2 * vt
--          if debug then
--            s1 := concat[toStringTerm(op1mult,op1type),"*",toStringTerm(op2mult,op2type)]
--            s2 := concat["=",toString(ut),"*",toString(factor1)]
--            s3 := concat["-",toString(factor2),"*",toString(vt)]
--            s4 := concat["=",toString(resul)]
--            sayTeX$Lisp concat ["cliffordProdTerm: ",s1,s2,s3,s4]
          resul := (op1mult*op2mult)*resul -- apply 'scalar' multipliers
          resul

        -- Implement Clifford multiplication for orthogonal bases
        -- on individual term in a multivector.
        -- If the bilinear form is diagonal then this may be
        -- more efficient than cliffordProdTerm as it does not
        -- require recursion.
        -- The ei*ej products could instead be precomputed in
        -- a (2^n)^2 multiplication table although only
        -- practical for low dimension size.
        cliffordDiagonalTerm(op1mult: K, op1type:SINT, op2mult: K, op2type:SINT): % ==
            c  := op1mult * op2mult
            bz := op2type
            for i in 0..n-1 | bit?(op1type,i) repeat
                -- Apply rule  ei*ej = -ej*ei for i ~= j
                k := 0
                for j in i+1..n-1 | bit?(op1type, j) repeat k := k+1
                for j in 0..i-1   | bit?(bz, j) repeat k := k+1
                if odd? k then c := -c
                -- Apply rule  ei^2 = Q(ei)
                if bit?(bz,i) then
                    c := c * Qeelist.(i+1)
                    bz:= bz - (2**i)::SINT
                else
                    bz:= bz + (2**i)::SINT
            result := New; result.bz := c
            result

        -- Clifford product
        -- if orthogonal then this operation will use faster algorithm
        x * y ==
          z := New
          if orthogonal then
            for ix in 0..dim-1 repeat
              if x.ix ~= 0 then for iy in 0..dim-1 repeat
                if y.iy ~= 0 then
                  z := z + cliffordDiagonalTerm(x.ix,ix::SINT,y.iy,iy::SINT)
          if not orthogonal then
            for ix in 0..dim-1 repeat
              if x.ix ~= 0 then for iy in 0..dim-1 repeat
                if y.iy ~= 0 then
                  z := z + cliffordProdTerm(x.ix,ix::SINT,y.iy,iy::SINT)
          z

        -- Implement reverse, complement,canonical dual basis
        _~(x:%): % ==
            x * ePseudoscalar()

        -- used by monomial which is used by recip
        -- this only uses the diagonal terms in the bilinear form
        -- so may not be completely general
        canonMonom(c: K, lb: List PI): Record(coef: K, basel: NNI) ==
            -- 0. Check input
            for b in lb repeat b > n => error "No such basis element"
            -- 1. Apply identity ei*ej = -ej*ei, i ~= j.
            -- The Rep assumes n is small so bubble sort is ok.
            -- Using bubble sort keeps the exchange info obvious.
            wasordered   := false
            exchanges := 0
            while not wasordered repeat
                wasordered := true
                for i in 1..#lb-1 repeat
                    if lb.i > lb.(i+1) then
                        t := lb.i; lb.i := lb.(i+1); lb.(i+1) := t
                        exchanges := exchanges + 1
                        wasordered := false
            if odd? exchanges then c := -c
            -- 2. Prepare the basis element
            -- Apply identity ei*ei = Q(ei).
            bz := 0
            for b in lb repeat
                bn := (b-1)::NNI
                if bit?(bz, bn) then
                    c := c * Qeelist bn
                    bz:= ( bz - 2**bn )::NNI
                else
                    bz:= bz + 2**bn
            [c, bz::NNI]

        -- monomial(c,[i1,i2,...,iN]) produces the value given by
        -- \spad{c*e(i1)*e(i2)*...*e(iN)}.
        -- this uses canonMonom which only uses the diagonal terms in the bilinear form
        -- so may not be completely general
        -- (K, List PI) -> %
        monomial(c, lb) ==
            r := canonMonom(c, lb)
            z := New
            z r.basel := r.coef
            z

        -- coefficient(x,[i1,i2,...,iN])  extracts the coefficient of
        -- \spad{e(i1)*e(i2)*...*e(iN)} in x.
        -- (%, List PI) -> K
        coefficient(z, lb) ==
            r := canonMonom(1, lb)
            r.coef = 0 => error "Cannot take coef of 0"
            z r.basel/r.coef

        -- use Ex instead of OutputForm
        Ex ==> OutputForm

        -- output single term to output device
        -- vector bases have the form e1, e2 ...
        -- bivector bases have the form e12, e23 ...
        -- and so on
        coerceMonom(c: K, b: NNI): Ex ==
            b = 0 => c::Ex
            ml := [sub("e"::Ex, i::Ex) for i in 1..n | bit?(b,i-1)]
            be := reduce("*", ml)
            c = 1 => be
            c::Ex * be

        -- output multivector to output device
        -- as sum of terms, like,
        -- 1 + 2*e1 + 3*e2 + 4*e1e2
        coerce(x): Ex ==
            tl := [coerceMonom(x.i,i) for i in 0..dim-1 | x.i ~= 0]
            null tl => "0"::Ex
            reduce("+", tl)

        localPowerSets(j:NNI): List(List(PI)) ==
          l: List List PI := list []
          j = 0 => l
          Sm := localPowerSets((j-1)::NNI)
          Sn: List List PI := []
          for x in Sm repeat Sn := cons(cons(j pretend PI, x),Sn)
          append(Sn, Sm)

        powerSets(j:NNI):List List PI == map(reverse, localPowerSets j)

        Pn:List List PI := powerSets(n)

        -- Clifford multiplicative inverse
        -- not guaranteed to exist, if we cant
        -- find an inverse then we return the string "failed"
        -- this generates a matrix representation and then inverts matrix
        -- this uses monomial which uses canonMonom which only uses the
        -- diagonal terms in the bilinear form so may not be completely general
        recip(x: %): Union(%, "failed") ==
          one:% := 1
          -- tmp:c := x*yC - 1$C
          rhsEqs : List K := []
          lhsEqs: List List K := []
          lhsEqi: List K
          for pi in Pn repeat
            rhsEqs := cons(coefficient(one, pi), rhsEqs)
            lhsEqi := []
            for pj in Pn repeat
                lhsEqi := cons(coefficient(x*monomial(1,pj),pi),lhsEqi)
            lhsEqs := cons(reverse(lhsEqi),lhsEqs)
          ans := particularSolution(matrix(lhsEqs),
            vector(rhsEqs))$LinearSystemMatrixPackage(K, Vector K, Vector K, Matrix K)
          ans case "failed" => "failed"
          ansP := parts(ans)
          ansC:% := 0
          for pj in Pn repeat
            cj:= first ansP
            ansP := rest ansP
            ansC := ansC + cj*monomial(1,pj)
          ansC
