)abbrev package SOCKLIB SockLib

SockLib(): Public == Private where

    Public == Type with

	listener: SingleInteger -> SingleInteger
              ++ Set up listening server.  SOCKETERROR = -1,
	      ++ BINDERROR = -2, LISTENERROR = -3.  listener
	      ++ returns the file descriptor for the listening
	      ++ socket or one of the preceding error codes.
	      ++ listener takes the port number to listen on as
	      ++ its single argument.
	listenerAccept: SingleInteger -> SingleInteger
              ++
        spadSelect: (SingleInteger,SingleInteger,SingleInteger) -> SingleInteger
              ++
	readByte!: SingleInteger -> Maybe Byte
	      ++ readByte!(sock) attempts to read a byte from the
	      ++ socket sock.  Returns the read byte if successful,
	      ++ otherwise \spad{nothing}.
	readBytes!: (SingleInteger,ByteBuffer) -> NonNegativeInteger
	      ++ readBytes!(sock,b) reads byte sequences from socket sock into
	      ++ the byte buffer `b'.  The actual number of bytes written
	      ++ is returned, and the length of `b' is set to that amount.
        readBytesNoBlock!: (singleInteger,ByteBuffer,singleInteger) -> NonNegativeInteger
              ++
        writeByte!: (SingleInteger,Byte) -> Maybe Byte
	      ++ writeByte!(sock,b) attempts to write the byte `b' on
	      ++ the socket sock.  Returns the written byte if successful,
	      ++ otherwise, returns \spad{nothing}.
        writeBytes!: (SingleInteger,ByteBuffer) -> NonNegativeInteger
	      ++ writeBytes!(sock,b) write bytes from buffer `b' 
	      ++ onto the socket sock.  The actual number of written 
	      ++ bytes is returned.
	close!: SingleInteger -> SingleInteger
	      ++
        panServer: SingleInteger -> SingleInteger
              ++ webServer(port) requires port = port number
        

    Private == add

        import parseAndEvalToStringEqNum: String -> List String
	    from Foreign Builtin

	loadNativeModule("./socklib.so")$System

	import Listener: SingleInteger -> SingleInteger
	    from Foreign C

	listener(n) == Listener(n)

	import ListenerAccept: SingleInteger -> SingleInteger
	    from Foreign C

	listenerAccept(n) == ListenerAccept(n)

        import SpadSelect: (SingleInteger, SingleInteger, SingleInteger) -> SingleInteger
            from Foreign C

        spadSelect(sock,secs,usecs) == SpadSelect(sock,secs,usecs)

	readByte! sock ==
	    readByteFromStreamSocket(sock)$Lisp

	readBytes!(sock,b) ==
	    n: NonNegativeInteger :=
	        readFromStreamSocket(sock,b::PrimitiveArray(Byte), capacity b)$Lisp
	    setLength!(b,n)

	writeByte!(sock,b) ==
	    writeByteToStreamSocket(sock,b)$Lisp

	writeBytes!(sock,b) ==
	    writeToStreamSocket(sock,b::PrimitiveArray(Byte), #b)$Lisp

	close! sock ==
	    closeSocket(sock)$Lisp

        headersplit: String -> List(List(String))
        getContentType: String -> String
        sendFile: (SingleInteger,String) -> Integer
        headerReturn: (SingleInteger,ByteBuffer) -> Integer
        multiServ: SingleInteger -> SingleInteger
        sendCommand: (SingleInteger,String) -> SingleInteger
	formatMessages: String -> String
        lastStep: () -> String
        getType: String -> String
        lastType: () -> String
        sendCompCellString: SingleInteger -> SingleInteger
        handleCompCellString: (SingleInteger,String) -> SingleInteger
        handleInsert: (SingleInteger,String) -> SingleInteger
        sendInsertFile: SingleInteger -> SingleInteger


--  'panServer' listens on any interface, INADDR_ANY in the C code,
--  and on port number 'port'.  However on the javascript side the
--  port is still hardcoded as '8085' so for now it will only work
--  if port = 8085.
--  
--  I have a problem with quitting cleanly from 'panServer'.
--  I've tried to make it so that entering 
--  'http://127.0.0.1:8085/quit' in the browser URL bar makes
--  panServer break out of the while loop and end.  This works
--  after initially loading the blank page, i.e. before entering
--  any commands, but as soon as a command is entered it doesn't.
--  It gets to the 'panServer end' message but doesn't return to
--  the prompt.  The sockets go into the 'TIME_WAIT' (netstat -tcp -a)
--  state and then close after the appropriate time interval but the 
--  program has still hung.

        panServer(port) ==
	    retval := 0:SingleInteger
            connfd:SingleInteger
	    listenfd:SingleInteger := listener(port)
	    if listenfd < 0 
	        then 
		    retval := -1
		    print message("listenfd negative")$OutputForm
	    	else
                    quit := 0:SingleInteger
                    while quit = 0 repeat
                        connfd := listenerAccept(listenfd)
                        if connfd < 0
                            then 
                                retval := -2
                                print message("connfd negative, connection failure")$OutputForm
                            else
                                quit := multiServ(connfd)
    	    close! listenfd
            messagePrint("panServer end" )$OutputForm
            retval

--  I've eliminated the use of regular expressions but would like to 
--  have them for dealing with strings.  In 'headersplit' I do a rudimentary
--  transformation of the headers received from the browser but would like
--  to do more although I'm not certain what the final form should be like.
--  
--  The previous use of regular expressions depended on GCL's implementation
--  and SBCL doesn't even have them.  They are not part of the common lisp
--  specification.  To get lisp agnostic regular expressions probably means
--  interfacing the C regular expressions but I've so far found it difficult
--  to do so because of need to pass non-atomic parameters between spad and C.

        multiServ(connfd) ==
            retval := 0:SingleInteger
            headers := empty()$ByteBuffer
            buf := byteBuffer(1024)$ByteBuffer
            totalread:NonNegativeInteger := 0
            nread := readBytes!(connfd,buf)
            headers := concat(headers,buf)
            totalread := totalread + nread
            if nread = 1024 then
                while spadSelect(connfd,0,1) > 0 repeat
                    nread := readBytes!(connfd,buf)
                    headers := concat(headers,buf)
                    totalread := totalread + nread
            print message(concat ["message read length:" string(totalread)])$OutputForm
            headerList:List(List(String)) := headersplit(headers::String)
            reqtype:String := headerList.1.1
            if reqtype = "GET" then
                pathvar:String := headerList.1.2
                if pathvar = "/quit" then
                    retval := 1
                else if position("compCellString=yes",headers::String,1)$String > 0 then
                    sendCompCellString(connfd)
                else
                    sendFile(connfd,pathvar)
            else if reqtype = "POST" then
                if position("command=",headers::String,1)$String > 0 then
                    sendCommand(connfd,headers::String)
                else if position("compCellString=",headers::String,1)$String > 0 then
                    handleCompCellString(connfd,headers::String)
                else if position("filePick",headers::String,1)$String > 0 then
                    handleInsert(connfd,headers::String)
                else if position("fileInsert=yes",headers::String,1)$String > 0 then
                    sendInsertFile(connfd)
            close! connfd
            retval

--  I've eliminated the use of regular expressions but would like to 
--  have them for dealing with strings.  In 'headersplit' I do a rudimentary
--  transformation of the headers received from the browser but would like
--  to do more although I'm not certain what the final form should be like.
--  
--  The previous use of regular expressions depended on GCL's implementation
--  and SBCL doesn't even have them.  They are not part of the common lisp
--  specification.  To get lisp agnostic regular expressions probably means
--  interfacing the C regular expressions but I've so far found it difficult
--  to do so because of need to pass non-atomic parameters between spad and C.

        headersplit(headers) ==
            l:List(String) := split(headers,char(STRING(NewLine$Lisp)$Lisp)$Character)$String
            headerlist:List(List(String)) := []
            req:List(String) := split(l.1,char " ")
            headerlist := cons(req,headerlist)
            for j in 2..#l repeat
                p := position(char ":",l.j,1)$String
                headerlist := cons([(l.j)(1..p-1),(l.j)(p+1..)],headerlist)
            headerlist := reverse headerlist
            if req.1 = "GET" then
                pathvar:String := req.2
                contentType:String := getContentType(pathvar)
            for x in headerlist repeat
                --messagePrint(x.1)$OutputForm
                --messagePrint(x.2)$OutputForm
                WriteLine(x.1)$Lisp
                WriteLine(x.2)$Lisp
            headerlist                 
            

        getContentType(pathvar:String):String ==
            -- set default content type
            contentType:String := "text/plain"
            extension:String := split(pathvar,char ".").last
            -- test for extensions, add as necessary
            if extension = "html" then
                contentType:String := "text/html"
            else if extension = "htm" then
                contentType:String := "text/html"
            else if extension = "xml" then
                contentType:String := "text/xml"
            else if extension = "xhtml" then
                contentType:String := "application/xhtml+xml"
            else if extension = "js" then
                contentType:String := "text/javascript"
            else if extension = "css" then
                contentType:String := "text/css"
            else if extension = "png" then
                contentType:String := "image/png"
            else if extension = "jpg" then
                contentType:String := "image/jpeg"
            else if extension = "jpeg" then
                contentType:String := "image/jpeg"
            contentType

--  This function is for development purposes only.  Putting a call
--  to 'headerReturn' in the appropriate place will return the browser's
--  headers as an html page.

        headerReturn(connfd,text) ==
            s:String := "<html><head><title>Spad Serve</title></head><body><h3>"
            length := (# s - 1)
            htmlhead := byteBuffer(1024)$ByteBuffer
            for i in 0..length repeat
                qsetelt!(htmlhead,i,(ord(elt(s,i+1)$String)$Character)::Byte)$ByteBuffer
            setLength!(htmlhead,# s)
            text := concat(htmlhead,text)
            s := "</h3></body></html>"
            length := (# s - 1)
            htmlfoot := byteBuffer(1024)$ByteBuffer
            for i in 0..length repeat
                qsetelt!(htmlfoot,i,(ord(elt(s,i+1)$String)$Character)::Byte)$ByteBuffer
            setLength!(htmlfoot,# s)
            text := concat(text,htmlfoot)
            writeBytes!(connfd,text)
            0            

--  'sendFile' provides the standard response to GET requests.

        sendFile(connfd,pathvar) ==
            retval := 0:SingleInteger
            contentType := getContentType(pathvar)
            q:=panOpen(pathvar)$Lisp
            if NOT(NULL(q)$Lisp)$Lisp then
                file:String := ""
                r := MAKE_-STRING_-OUTPUT_-STREAM()$Lisp
                while (c := READ_-CHAR(q,NIL$Lisp,NIL$Lisp)$Lisp) repeat
                    WRITE_-CHAR(c,r)$Lisp
                filestream:String := GET_-OUTPUT_-STREAM_-STRING(r)$Lisp
                CLOSE(r)$Lisp
                CLOSE(q)$Lisp
                filelength:String := string(#filestream)
                file := concat ["Content-Length: ",filelength,STRING(NewLine$Lisp)$Lisp,STRING(NewLine$Lisp)$Lisp,file]
                file := concat ["Connection: close",STRING(NewLine$Lisp)$Lisp,file]
                file := concat ["Content-Type: ",contentType,STRING(NewLine$Lisp)$Lisp,file]
                file := concat ["HTTP/1.1 200 OK",STRING(NewLine$Lisp)$Lisp,file]
                file := concat [file,filestream]
                length := # file - 1
                for i in 0..length repeat
                    writeByte!(connfd,(ord(elt(file,i+1)$String)$Character)::Byte)
            retval

        sendCommand(connfd,headers) ==
            WriteLine$Lisp "sendCommand start"
            retval := 0:SingleInteger
            p := position("command=",headers,1)$String
            command := headers((p+8)..)
            WriteLine$Lisp "command:" command ":command"
            tmpmathml := MAKE_-STRING_-OUTPUT_-STREAM()$Lisp
	    tmpalgebra := MAKE_-STRING_-OUTPUT_-STREAM()$Lisp
	    savemathml := _$texOutputStream$Lisp
	    savealgebra := _$algebraOutputStream$Lisp
            SETQ(_$texOutputStream$Lisp,tmpmathml)$Lisp
            SETQ(_$algebraOutputStream$Lisp,tmpalgebra)$Lisp
            --      parseAndInterpret$Lisp command
            --      parseAndEvalStr$Lisp command
            -- The previous two commands don't exit nicely when a syntactically incorrect command is
            -- given to them.  They somehow need to be wrapped in CATCH statements but I haven't
            -- figured out how to do this.  parseAndEvalToStringEqNum  uses the following CATCH
            -- statements to call parseAndEvalStr but when I try these they don't work.  I get a
            -- "NIL is not a valid identifier to use in AXIOM" message. Using parseAndEvalToStringEqNum
            -- works and doesn't crash on a syntax error.
            --        v := CATCH('SPAD__READER, CATCH('top__level, parseAndEvalStr$Lisp command)$Lisp)$Lisp
            --        v = 'restart => ['"error"]
	    -- update 2011.01.01  In OpenAxiom the parseAndEvalToStringEqNum started crashing on syntax
	    -- errors too.  It turns out 'ans' is empty in that case so I now test for that and issue a
	    -- non-specific error message in that case.
	    ans:String := concat parseAndEvalToStringEqNum command
	    if ans ~= "" 
	        then
                    WriteLine$Lisp concat ["parse answer: ",ans]
                    resultmathml := GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp
                    resultalgebra := GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp
                    SETQ(_$texOutputStream$Lisp,savemathml)$Lisp
                    SETQ(_$algebraOutputStream$Lisp,savealgebra)$Lisp
                    CLOSE(tmpmathml)$Lisp
                    CLOSE(tmpalgebra)$Lisp
                    -- Since strings returned from axiom are going to be displayed in html I
                    -- should really check for the characters &,<,> and replace them with
                    -- &amp;,&lt;,&gt;.  At present I only check for ampersands in formatMessages.
                    mathml:String := resultmathml
                    algebra:String := resultalgebra
                    algebra := formatMessages(algebra)
                    --algebra:String := ""
                    -- At this point mathml contains the mathml for the output but does not
                    -- include step number or type information.  We should also save the command.
                    -- I get the type from 'ans' and step number from the $internalHistoryTable
                    --axans:String := concat ["<div class=_"stepnum_">", lastStep(), "</div><div class=_"command_">", command, "</div><div class=_"algebra_">",algebra,"</div><div class=_"mathml_">",mathml,"</div><div class=_"type_">",getType(ans),"</div>"]
        	    axans:String := concat ["<div class=_"stepnum_">", lastStep(), "</div><div class=_"command_">", command, "</div><div class=_"algebra_">",algebra,"</div><div class=_"mathml_">",mathml,"</div><div class=_"type_">",getType(ans),"</div>"]
        --            WriteLine$Lisp concat ["mathml answer: ",mathml]
        --            WriteLine$Lisp concat ["algebra answer: ",algebra]
                else
        	    axans:String := concat ["<div class=_"stepnum_">-1</div><div class=_"command_">", command, "</div><div class=_"algebra_"></div><div class=_"mathml_"><math xmlns=_"http://www.w3.org/1998/Math/MathML_" mathsize=_"big_" display=_"block_"><mtext>There is something wrong with your command, probably a syntax error.</mtext></math></div><div class=_"type_">Error</div>"]		                  
                    SETQ(_$texOutputStream$Lisp,savemathml)$Lisp
                    SETQ(_$algebraOutputStream$Lisp,savealgebra)$Lisp
                    CLOSE(tmpmathml)$Lisp
                    CLOSE(tmpalgebra)$Lisp
            length := # axans - 1
            for i in 0..length repeat
                writeByte!(connfd,(ord(elt(axans,i+1)$String)$Character)::Byte)
            WriteLine$Lisp "sendCommand end"
            retval

        formatMessages(str) ==
            -- I need to replace any ampersands with &amp; and may also need to
            -- replace < and > with &lt; and &gt;
            strlist:List String
            strlist := split(str,char "&")
            str := ""
            -- oops, if & is the last character in the string this method
            -- will eliminate it.  Need to redo this.
            for s in strlist repeat
                str := concat [str,s,"&amp;"]
            strlen:Integer := #str
            str := str.(1..(#str - 5))
            -- Here I split the string into lines and put each line in a "div".
	    --strlist := split(str, NewLine$Lisp)
	    --strlist := split(str,char(STRING(NewLine$Lisp)$Lisp)$Character)
            strlist := split(str,newline)
            str := ""
            for s in strlist repeat
                str := concat [str,"<div>",s,"</div>"]
            str

        lastStep ==
	    WRITE_-TO_-STRING(CAR(CAR(_$internalHistoryTable$Lisp)$Lisp)$Lisp)$Lisp

        getType(ans) ==
            p := position("Type: ",ans,1)$String
            ans((p+6)..(#ans))

--  These next functions provide a minimal way to save and restore work.
--  This is complicated in a html web interface because of the javascript
--  security policy which doesn't give the browser access to the local
--  file system.
--  
--  The function 'handleCompCellString' receives the serialized compcell
--  from an AJAX request and sets the global system variable
--  'COMPCELLSTRING$Lisp' to this string.  The function 'sendCompCellString'
--  then responds to the 'download' button on the context menu and sends
--  the string back to be saved using the 'save page' menu item on the 
--  browser.
--  
--  The functions 'handleInsert' and 'sendInsertFile' provide a way to
--  restore a compcell that was previously saved. 'handleInsert' receives
--  the uploaded file and sets the global system variable 'FILEINSERT$Lisp'
--  to this string.  Then 'sendInsertFile' sends the string back for 
--  inserting into the page.
--  
--  On the javascript side there's a problem in that the context menu only
--  becomes available once a compcell has been created, and the saved compcell
--  can only then be inserted as a child of that new compcell.  It should be
--  possible to insert saved work on a blank page. 

        handleCompCellString(connfd,headers) ==
            WriteLine$Lisp "handleCompCellString begin"
            retval := 0:SingleInteger
            p := position("compCellString=",headers,1)$String
            compCellString := headers((p+15)..)
            SETQ(_$COMPCELLSTRING$Lisp,compCellString)$Lisp
            print message(compCellString)$OutputForm
            length := # compCellString - 1
            for i in 0..length repeat
                writeByte!(connfd,(ord(elt(compCellString,i+1)$String)$Character)::Byte)
            WriteLine$Lisp "handleCompCellString end"
            retval

        sendCompCellString(connfd) ==
            retval := 0:SingleInteger
            WriteLine$Lisp "sendCompCellString begin"
            sendString:String := ""
            sendString := concat [sendString,"HTTP/1.1 200 OK",STRING(NewLine$Lisp)$Lisp]
            sendString := concat [sendString,"Content-Type: text/xml",STRING(NewLine$Lisp)$Lisp]
            sendString := concat [sendString,STRING(NewLine$Lisp)$Lisp]
            sendString := concat [sendString,_$COMPCELLSTRING$Lisp]
            length := # sendString - 1
            for i in 0..length repeat
                writeByte!(connfd,(ord(elt(sendString,i+1)$String)$Character)::Byte)
            WriteLine$Lisp "sendCompCellString end"
            retval


        handleInsert(connfd,headers) ==
            retval:SingleInteger := 0
--            WriteLine$Lisp "handleInsert begin"
            response:String := "HTTP/1.1 204 OK"
            length := # response - 1
            for i in 0..length repeat
                writeByte!(connfd,(ord(elt(response,i+1)$String)$Character)::Byte)               
            -- get boundary of multipart/form-data
            pstart := position("<div",headers,1)$String
            n:Integer := 0
            pend:Integer := 0
            while (n := position("</div>",headers,n+1)$String) > 0 repeat pend := n
            pend := pend + 5
            fileInsert := headers(pstart..pend) 
            SETQ(_$FILEINSERT$Lisp,fileInsert)$Lisp
--            WriteLine$Lisp "handleInsert end"
            retval

        sendInsertFile(connfd) ==
            retval:SingleInteger := 0
            fileInsert:String := _$FILEINSERT$Lisp
            length := # fileInsert - 1
            for i in 0..length repeat
                writeByte!(connfd,(ord(elt(fileInsert,i+1)$String)$Character)::Byte)
            retval
